[{"title":"Phar 构建工具","url":"/2025/08/07/php/php-phar-builder/","content":"\n## 背景\n\n在 PHP 开发中，我们经常需要使用各种第三方包来加速开发进程。然而，在某些情况下，我们可能会遇到以下问题：\n\n1. 项目依赖的某个包需要更新，但直接更新可能会破坏现有代码的兼容性\n2. 我们需要将自己的项目打包成一个独立的文件，方便分发给其他开发者使用\n3. 我们希望在不影响现有项目的情况下，测试某个包的新版本\n\nPhar (PHP Archive) 文件是一种将多个 PHP 文件和资源打包成单个文件的格式，它可以帮助我们解决上述问题。通过将项目或库打包成 Phar 文件，我们可以：\n\n- 保持依赖版本的稳定性\n- 方便地分发和部署应用程序\n- 在不影响现有项目的情况下测试新的包版本\n\n本工具提供了一个简单的方式来创建自定义的 Phar 文件，无需强制更新现有依赖。\n\n## 代码实现\n\n以下是 `builder.php` 文件的完整代码：\n\n~~~\n<?php\n\nclass Builder\n{\n    /**\n     * @var Phar\n     */\n    protected $phar;\n    /**\n     * @var string[]\n     */\n    protected $exclude = [\n        'composer.lock',\n        '.idea',\n        '.git',\n        '.vscode'\n    ];\n    /**\n     * @var string\n     */\n    protected $index = 'index.php';\n\n    /**\n     * 构造函数\n     * @param string $fname 要创建的 Phar 文件路径\n     */\n    public function __construct($fname)\n    {\n        // 如果文件已存在，则删除它\n        if (is_file($fname)) {\n            unlink($fname);\n        }\n        // 创建新的 Phar 对象\n        $this->phar = new \\Phar($fname, FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::KEY_AS_FILENAME);\n    }\n\n    /**\n     * 创建自动加载文件\n     * 如果入口文件不存在，则创建一个包含自动加载代码的入口文件\n     */\n    public function autoloadfile()\n    {\n        if (!is_file($this->index)) {\n            $text = '<?php' . PHP_EOL;\n            $text .= 'if (is_file(__DIR__ . \\'/vendor/autoload.php\\')) {' . PHP_EOL;\n            $text .= 'require __DIR__ . \\'/vendor/autoload.php\\';' . PHP_EOL;\n            $text .= '}';\n            file_put_contents($this->index, $text);\n        }\n    }\n\n    public function buildExcludeRegex()\n    {\n        $this->exclude[] = __FILE__;\n        $escaped = array_map(function ($v) {\n            return preg_quote($v, '/');\n        }, $this->exclude);\n        // 构造正则：排除匹配到任意一个文件名\n        return '/^(?!.*(' . implode('|', $escaped) . ')).*$/i';\n    }\n\n    /**\n     * 构建 Phar 文件\n     * @param string $path 要打包的目录路径\n     */\n    public function build($path)\n    {\n        // 确保自动加载文件存在\n        $this->autoloadfile();\n        // 开始缓冲 Phar 写入操作\n        $this->phar->startBuffering();\n        // 从指定目录构建 Phar 文件，排除匹配正则表达式的文件\n        $pattern = $this->buildExcludeRegex();\n        $this->phar->buildFromDirectory($path, $pattern);\n        // 设置 Phar 文件的存根（入口点）\n        $this->phar->setStub($this->phar->createDefaultStub($this->index));\n        // 停止缓冲并写入 Phar 文件\n        $this->phar->stopBuffering();\n    }\n}\n\nif (PHP_SAPI !== 'cli') {\n    fwrite(STDERR, \"错误：此脚本必须通过命令行执行！\\n\");\n    exit(1);\n}\n$pharFile = basename(__DIR__);\nif (isset($argv[1])) {\n    $pharFile = $argv[1];\n}\n$filename = $pharFile . '.phar';\n(new Builder(__DIR__ . DIRECTORY_SEPARATOR . $filename))->build(__DIR__);\n~~~\n\n## 本地运行生成 Phar 文件\n\n### 步骤 1: 准备独立SDK(guzzlehttp/guzzle)\n\n~~~\nmkdir guzzle && cd guzzle\ncomposer require guzzlehttp/guzzle:^7.0\n~~~\n\n### 步骤 2: \n\n将上述代码保存为 `build.php` 文件，并放置在您要打包的 PHP 项目根目录下。\n\n### 步骤 2: 运行构建脚本\n\n打开终端，导航到项目根目录，运行以下命令：\n\n```bash\n# 基本用法 - 生成与目录同名的 Phar 文件\nphp -d phar.readonly=0 build.php\n\n# 自定义文件名 - 生成指定名称的 Phar 文件\nphp -d phar.readonly=0 build.php guzzle\n```\n\n### 步骤 3: 验证生成的文件\n\n运行成功后，您会在项目根目录下看到生成的 `.phar` 文件（如 `guzzle.phar`）。\n\n## 使用 Phar 文件\n\n生成 Phar 文件后，您可以通过以下方式使用它：\n\n### 包含到其他项目中\n\n您可以在其他 PHP 项目中包含这个 Phar 文件：\n\n```php\n<?php\nrequire 'guzzle.phar';\nuse GuzzleHttp\\Client;\n$client = new Client();\n// 发送 GET 请求\n$response = $client->request('GET', 'https://www.zhiqiang.wang');\n// 获取响应状态码\n$statusCode = $response->getStatusCode();\necho \"Status code: $statusCode\\n\";\n```\n\n### 作为命令行工具使用\n\n如果您的 Phar 文件设计为命令行工具，可以通过以下方式运行：\n\n## 注意事项\n\n1. 运行脚本时需要禁用 `phar.readonly` 选项（使用 `-d phar.readonly=0`）\n2. 确保您有写入当前目录的权限\n3. 如果您的项目有特殊的自动加载需求，可能需要手动修改生成的 `index.php` 文件\n4. Phar 文件打包后，原始代码的路径结构会被保留，因此请确保您的代码中使用的是相对路径\n\n## 扩展建议\n\n- 添加更多命令行参数选项（如指定排除文件列表、压缩级别等）\n- 支持自定义入口脚本内容\n- 添加版本号和元数据信息到 Phar 文件中\n- 实现增量构建功能，只打包修改过的文件\n","tags":["composer","phar"],"categories":["php"]},{"title":"SSH配置","url":"/2025/07/30/soft/sshd-config/","content":"\n默认配置`/etc/ssh/sshd_config`\n\n~~~\n# 包含额外的配置文件（例如 /etc/ssh/sshd_config.d/*.conf）\nInclude /etc/ssh/sshd_config.d/*.conf\n\n# 指定监听地址族（any 表示 IPv4 和 IPv6）\nAddressFamily any\n\n# 是否允许 root 用户登录（建议使用 prohibit-password 或 no 提高安全性）\n# yes 表示允许 root 用户使用密码、公钥等任意方式登录（不安全）\nPermitRootLogin prohibit-password  # 建议仅允许公钥登录\n\n# 允许使用交互式键盘认证（通常用于 PAM），已关闭更安全\nKbdInteractiveAuthentication no\n\n# 是否启用 PAM（Pluggable Authentication Modules，可配合系统用户验证）\nUsePAM yes\n\n# 是否启用 X11 转发（用于图形界面程序，若无需求可关闭）\nX11Forwarding yes\n\n# 登录后是否显示 /etc/motd 文件内容（登录提示）\nPrintMotd no\n\n# 是否使用 DNS 反查客户端主机名（关闭可加快登录速度）\nUseDNS no\n\n# 接收客户端的本地语言环境变量（常用于国际化）\nAcceptEnv LANG LC_*\n\n# SFTP 子系统配置（指定 sftp-server 路径）\nSubsystem sftp /usr/lib/openssh/sftp-server\n\n# 启用密码认证（若使用公钥验证可关闭以提升安全）\nPasswordAuthentication yes\n\n# 禁止空密码账户登录\nPermitEmptyPasswords no\n\n# 可选优化项（默认未启用，如需使用请取消注释）：\n\n# 指定监听端口（默认 22）\n#Port 22\n\n# 指定监听地址（可指定某个 IP）\n#ListenAddress 0.0.0.0\n#ListenAddress ::\n\n# 主机密钥文件路径\n#HostKey /etc/ssh/ssh_host_rsa_key\n#HostKey /etc/ssh/ssh_host_ecdsa_key\n#HostKey /etc/ssh/ssh_host_ed25519_key\n\n# 设置重新协商加密密钥的限制\n#RekeyLimit default none\n\n# 设置日志等级\n#SyslogFacility AUTH\n#LogLevel INFO\n\n# 登录超时时间（默认 2 分钟）\n#LoginGraceTime 2m\n\n# 是否启用权限严格检查\n#StrictModes yes\n\n# 最大认证尝试次数\n#MaxAuthTries 6\n\n# 最大并发会话数\n#MaxSessions 10\n\n# 是否启用公钥认证（默认是开启的）\n#PubkeyAuthentication yes\n\n# 指定 authorized_keys 文件路径\n#AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\n\n# 主机认证相关配置（一般用不到）\n#HostbasedAuthentication no\n#IgnoreUserKnownHosts no\n#IgnoreRhosts yes\n\n# 是否启用 Kerberos/GSSAPI 等高级认证（默认关闭）\n#KerberosAuthentication no\n#GSSAPIAuthentication no\n\n# 是否允许客户端进行代理转发（用于 ssh -A）\n#AllowAgentForwarding yes\n\n# 是否允许 TCP 端口转发（如 ssh -L/ssh -R）\n#AllowTcpForwarding yes\n\n# 启用网关端口（使远程端口映射可以监听公网）\n#GatewayPorts no\n\n# 客户端连接保活（防止断线）\n#ClientAliveInterval 0\n#ClientAliveCountMax 3\n\n# 最大启动连接数量（防止 DoS 攻击）\n#MaxStartups 10:30:100\n\n# 启用隧道支持\n#PermitTunnel no\n\n# chroot 限制目录\n#ChrootDirectory none\n\n# 版本信息追加说明（可加版本号标识等）\n#VersionAddendum none\n\n# 登录前显示 Banner 内容（可用于显示警告、声明）\n#Banner none\n\n# Match 匹配规则（可根据用户、组等定义不同配置）\n#Match User anoncvs\n#\tX11Forwarding no\n#\tAllowTcpForwarding no\n#\tPermitTTY no\n#\tForceCommand cvs server\n~~~\n\n# 安全升级\n\n## 修改端口号\n\n~~~\n# 修改端口号（建议使用1024-65535之间的端口）\nPort 2022\n~~~\n\n## 禁用密码登录，启用密钥认证\n\n~~~\n# 禁用密码登录（包括 cleartext 密码）\nPasswordAuthentication no\n# 允许公钥认证\nPubkeyAuthentication yes\n~~~\n\n> 生成SSH密钥对\n>\n> ~~~\n> # 客户端生成密钥对\n> ssh-keygen -t rsa -b 4096 -C \"zhiqiang2033@gmail.com\"\n> # 将公钥复制到服务器\n> ssh-copy-id -p 2022 user@server_ip\n> ~~~\n\n## 配置Fail2ban动态防护\n\n~~~\n# 安装 Fail2ban\nsudo apt update && sudo apt install fail2ban -y\n# 配置 Fail2ban 来保护 SSH\ncat > /etc/fail2ban/jail.local << EOF\n[sshd]\nenabled = true                      # 启用 SSH 防护规则\nport = ssh                          # 监听的端口（默认为 22）\nfilter = sshd                       # 使用默认的 sshd 过滤器\nlogpath = /var/log/auth.log         # 登录失败日志路径（Ubuntu 系统）\nmaxretry = 5                        # 允许的最大失败次数\nfindtime = 600                      # 时间窗口：10 分钟内超过 maxretry 次则封禁\nbantime = 3600                      # 封禁时间：单位为秒，这里是 1 小时\n# ignoreip = 127.0.0.1/8              # 忽略本地回环 IP，不对其封禁（白名单）\nEOF\n~~~\n\n> 查看封禁状态\n>\n> ~~~\n> sudo fail2ban-client status sshd\n> ~~~\n>\n> 手动解封IP\n>\n> ~~~\n> sudo fail2ban-client set sshd unbanip 192.168.0.100\n> ~~~\n>\n> 手动封禁IP\n>\n> ~~~\n> sudo fail2ban-client set sshd banip 192.168.0.100\n> ~~~\n>\n> 查看封禁日志\n>\n> ~~~\n> sudo fail2ban-client get sshd banip\n> ~~~\n>\n> 重启 Fail2ban 服务\n>\n> ~~~\n> sudo systemctl restart fail2ban\n> ~~~\n\n## 启用双因子认证（2FA）\n\n~~~\n# 安装 Google Authenticator PAM 模块\nsudo apt update && sudo apt install libpam-google-authenticator -y\n\n# 运行2FA配置向导\ngoogle-authenticator\n1.按提示回答问题（建议全部选择“是”以增强安全性）\n2.会生成一个二维码和一串密钥，扫码到手机 Google Authenticator 或其他兼容 App\n3.记录好备用密钥，用于恢复\n\n# 修改配置/etc/ssh/sshd_config\n# 增加一行\nChallengeResponseAuthentication yes\n# 强制认证方式：先公钥，再交互式（即 2FA）\nAuthenticationMethods publickey,keyboard-interactive\n\n\n# 修改配置/etc/pam.d/sshd文件顶部附近添加\n# nullok 表示如果用户没配置 2FA 不会强制失败，可去掉以强制所有用户必须 2FA。\nauth required pam_google_authenticator.so nullok\n~~~\n\n# 最佳的配置/etc/ssh/sshd_config\n\n> 这份 SSH 配置禁用密码和 root 登录，只允许公钥认证，改用非默认端口，限制登录尝试次数和会话数，关闭了 X11 和 TCP 转发，防止暴力破解和未授权访问，整体安全且实用，适合严格控制服务器访问。\n\n~~~\n# 包含额外的 sshd 配置文件\nInclude /etc/ssh/sshd_config.d/*.conf\n# 支持 IPv4 和 IPv6\nAddressFamily any\n# 禁用键盘交互认证（非2FA场景）\nKbdInteractiveAuthentication no\n# 启用 PAM（可支持2FA等）\nUsePAM yes\n# 登录时不打印 MOTD\nPrintMotd no\n# 接受客户端传递的环境变量\nAcceptEnv LANG LC_*\n# sftp 子系统路径\nSubsystem sftp /usr/lib/openssh/sftp-server\n\n# --- 基础安全配置 ---\n# SSH 端口（非默认端口）\nPort 2022\n# 主机密钥路径\nHostKey /etc/ssh/ssh_host_rsa_key\nHostKey /etc/ssh/ssh_host_ecdsa_key\nHostKey /etc/ssh/ssh_host_ed25519_key\n\n# --- 认证相关 ---\n\n# 禁止 root 账户密码登录\nPermitRootLogin no\n# 禁止密码认证，仅允许密钥登录\nPasswordAuthentication no\n# 禁止空密码\nPermitEmptyPasswords no\n# 启用公钥认证\nPubkeyAuthentication yes\n# 只允许公钥认证（无2FA）\nAuthenticationMethods publickey\n\n# --- 连接限制 ---\n# 最大认证失败尝试次数\nMaxAuthTries 3\n# 最大会话数\nMaxSessions 10\n# 最大连接数及限制策略（防止拒绝服务）\nMaxStartups 3:30:10\n# 登录超时，超过1分钟自动断开\nLoginGraceTime 1m\n# 客户端活动检测时间间隔（秒）\nClientAliveInterval 300\n# 客户端最大无响应次数\nClientAliveCountMax 2\n# 关闭DNS反查，加快连接速度\nUseDNS no\n\n# --- 用户限制 ---\n# 允许登录的用户列表\nAllowUsers ubuntu\n# 拒绝登录的用户列表\nDenyUsers root guest nobody\n\n# --- 其他安全选项 ---\n# 禁用 X11 转发\nX11Forwarding no\n# 禁止 TCP 转发\nAllowTcpForwarding no\n# 禁止网关端口转发\nGatewayPorts no\n# 禁止隧道接口\nPermitTunnel no\n~~~\n\n# 创建ubuntu账号\n\n~~~\nuseradd -m -d /home/ubuntu -s /bin/bash ubuntu\necho \"ubuntu:123456\" | chpasswd\n~~~\n\n\n\n","tags":["ubuntu"],"categories":["运维"]},{"title":"Nginx 优化配置详解","url":"/2025/07/19/soft/nginx-conf-optimization/","content":"\n## 一、基础配置调优\n\n### 1.1 工作进程配置\n\n```nginx\nworker_processes auto;            # 根据CPU核心数自动设置工作进程数\nworker_cpu_affinity auto;         # 绑定工作进程到对应CPU核心，减少调度开销\nworker_connections 65535;         # 单个工作进程允许的最大连接数\nworker_rlimit_nofile 65535;       # 工作进程最大打开文件数，需配合系统限制\n```\n\n### 1.2 事件模型优化\n\n```\nevents {\n    use epoll;                   # Linux高性能事件模型，支持大量连接\n    multi_accept on;             # 一次事件循环可接受多个新连接，提升效率\n    worker_connections 65535;    # 单进程最大连接数\n    accept_mutex off;            # 关闭连接接受锁，减少锁竞争，高负载适用\n}\n```\n\n### 1.3 网络连接优化\n\n~~~\nsendfile on;                    # 启用零拷贝发送文件，降低CPU消耗\ntcp_nopush on;                  # 优化TCP包发送，减少碎片\ntcp_nodelay on;                 # 禁用Nagle算法，减少延迟\nkeepalive_timeout 65;           # TCP长连接保持时间\nkeepalive_requests 100;         # 单连接最大请求数\nclient_header_timeout 15;       # 请求头超时时间，防止慢请求\nclient_body_timeout 15;         # 请求体超时时间\nsend_timeout 15;                # 响应发送超时时间\n\n~~~\n\n## 二、内存和缓冲区调优\n\n### 2.1 缓冲区设置\n\n```\nclient_header_buffer_size 4k;         # 请求头缓冲区大小\nlarge_client_header_buffers 8 8k;     # 大请求头缓冲区组数和大小\nclient_body_buffer_size 128k;          # 请求体缓冲区大小\nclient_max_body_size 100m;              # 最大请求体大小限制\nproxy_buffer_size 4k;                   # 代理响应头缓冲区\nproxy_buffers 8 4k;                     # 代理响应体缓冲区组\nproxy_busy_buffers_size 8k;             # 代理忙碌缓冲区空间限制\nfastcgi_buffer_size 4k;                 # FastCGI响应头缓冲区\nfastcgi_buffers 8 4k;                   # FastCGI响应体缓冲区组\nfastcgi_busy_buffers_size 8k;           # FastCGI忙碌缓冲区限制\n```\n\n### 2.2 文件缓存配置\n\n```\nopen_file_cache max=100000 inactive=20s;   # 打开文件缓存数量及失效时间\nopen_file_cache_valid 30s;                  # 缓存有效时间\nopen_file_cache_min_uses 2;                  # 文件访问次数达到才缓存\nopen_file_cache_errors on;                   # 缓存文件打开错误，减少IO\n\naccess_log /var/log/nginx/access.log main buffer=32k flush=5s;   # 访问日志缓冲写入\nerror_log /var/log/nginx/error.log warn;                         # 错误日志级别设置\n```\n\n------\n\n## 三、压缩优化\n\n### 3.1 Gzip压缩\n\n```\ngzip on;                             # 启用gzip压缩\ngzip_vary on;                       # 支持代理缓存区分Accept-Encoding\ngzip_min_length 1000;                # 小于此长度不压缩\ngzip_comp_level 6;                   # 压缩等级，兼顾性能和压缩率\ngzip_proxied any;                   # 代理请求均压缩\ngzip_buffers 16 8k;                 # gzip缓冲区大小\ngzip_http_version 1.1;              # HTTP协议版本\ngzip_types                          # 启用压缩的MIME类型\n    text/plain\n    text/css\n    text/xml\n    text/javascript\n    application/javascript\n    application/json\n    application/xml+rss\n    application/atom+xml\n    image/svg+xml;\n```\n\n### 3.2 Brotli压缩（模块支持）\n\n```\nbrotli on;                         # 启用Brotli压缩\nbrotli_comp_level 6;               # 压缩等级\nbrotli_min_length 1000;            # 小于此长度不压缩\nbrotli_types                       # 启用压缩类型\n    text/plain\n    text/css\n    text/xml\n    text/javascript\n    application/javascript\n    application/json\n    application/xml\n    application/rss+xml\n    application/atom+xml\n    image/svg+xml;\n```\n\n------\n\n## 四、SSL/TLS优化\n\n### 4.1 SSL配置优化\n\n```\nssl_protocols TLSv1.2 TLSv1.3;                  # 启用安全的TLS协议版本\nssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:        # 选择安全加密套件\n             ECDHE-RSA-AES256-GCM-SHA384:\n             ECDHE-RSA-AES128-SHA256:\n             ECDHE-RSA-AES256-SHA384;\nssl_prefer_server_ciphers on;                    # 优先使用服务器端套件\nssl_session_cache shared:SSL:50m;                # SSL会话缓存大小\nssl_session_timeout 1d;                           # 会话缓存超时\nssl_session_tickets off;                          # 禁用会话票据，防止重放攻击\nssl_stapling on;                                  # 启用OCSP Stapling\nssl_stapling_verify on;                           # 验证OCSP响应\nssl_trusted_certificate /path/to/ca-bundle.crt;  # CA证书链路径\n```\n\n### 4.2 HTTP/2配置\n\n```\n# 在server块中监听443端口并开启HTTP/2\nlisten 443 ssl http2;\nhttp2_push_preload on;                         # 启用HTTP/2资源推送\n```\n\n------\n\n## 五、负载均衡和代理优化\n\n### 5.1 上游服务器配置\n\n```\nupstream backend {\n    ip_hash;                          # 基于客户端IP的会话保持负载均衡\n    server 192.168.1.10:8080 weight=3 max_fails=3 fail_timeout=30s;  # 主服务器，权重3\n    server 192.168.1.11:8080 weight=2 max_fails=3 fail_timeout=30s;  # 主服务器，权重2\n    server 192.168.1.12:8080 weight=1 max_fails=3 fail_timeout=30s backup; # 备份服务器\n\n    keepalive 32;                     # 保持与后端的长连接数\n    keepalive_requests 100;           # 单连接最大请求数\n    keepalive_timeout 60s;            # 长连接超时时间\n}\n```\n\n### 5.2 代理配置优化\n\n```\nlocation / {\n    proxy_pass http://backend;           # 转发请求到后端upstream\n\n    proxy_connect_timeout 5s;            # 连接超时\n    proxy_send_timeout 60s;              # 发送超时\n    proxy_read_timeout 60s;              # 读取超时\n\n    proxy_buffering on;                  # 启用代理缓冲\n    proxy_buffer_size 4k;                # 代理缓冲区大小\n    proxy_buffers 8 4k;                  # 代理缓冲区组大小\n\n    proxy_set_header Host $host;                     # 转发主机头\n    proxy_set_header X-Real-IP $remote_addr;         # 转发真实客户端IP\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 代理链客户端IP\n    proxy_set_header X-Forwarded-Proto $scheme;      # 请求协议\n\n    proxy_http_version 1.1;            # 使用HTTP 1.1与后端通信\n    proxy_set_header Connection \"\";   # 清除Connection头，避免升级连接\n}\n```\n\n------\n\n## 六、缓存策略\n\n### 6.1 静态资源缓存\n\n```\nlocation ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ {\n    expires 1y;                                  # 设置缓存时间1年\n    add_header Cache-Control \"public, immutable\"; # 资源不可变，浏览器可长期缓存\n    add_header Vary Accept-Encoding;             # 根据压缩方式区分缓存\n}\n\nlocation ~* \\.(woff|woff2|ttf|eot)$ {\n    expires 1y;\n    add_header Cache-Control \"public\";           # 字体文件缓存\n    add_header Access-Control-Allow-Origin *;   # 允许跨域访问字体\n}\n```\n\n### 6.2 代理缓存\n\n```\nproxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;\n\nserver {\n    location / {\n        proxy_cache my_cache;                       # 启用代理缓存\n        proxy_cache_valid 200 302 10m;              # 成功响应缓存10分钟\n        proxy_cache_valid 404 1m;                    # 404响应缓存1分钟\n        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504; # 容灾缓存\n        proxy_cache_lock on;                         # 防止缓存击穿\n        proxy_cache_lock_timeout 5s;                 # 缓存锁超时\n\n        proxy_cache_key $scheme$proxy_host$request_uri;  # 缓存key定义\n        add_header X-Cache-Status $upstream_cache_status; # 缓存状态响应头\n\n        proxy_pass http://backend;\n    }\n}\n```\n\n------\n\n## 七、安全加固\n\n### 7.1 基础安全配置\n\n```\nserver_tokens off;    # 隐藏Nginx版本信息，降低攻击风险\n\nadd_header X-Frame-Options \"SAMEORIGIN\" always;           # 防止点击劫持\nadd_header X-Content-Type-Options \"nosniff\" always;       # 防止MIME类型混淆\nadd_header X-XSS-Protection \"1; mode=block\" always;       # 浏览器XSS防护\nadd_header Referrer-Policy \"strict-origin-when-cross-origin\" always; # 控制Referer发送策略\n\n# 限制请求方法，只允许GET、HEAD、POST，拒绝其他\nif ($request_method !~ ^(GET|HEAD|POST)$) {\n    return 405;\n}\n```\n\n### 7.2 请求限制\n\n```\nlimit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;     # API接口限速\nlimit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;    # 登录接口限速\n\nserver {\n    location /api/ {\n        limit_req zone=api burst=20 nodelay;      # 请求速率限制，允许突发20请求\n        limit_req_status 429;                      # 超过限制返回429\n    }\n\n    location /login {\n        limit_req zone=login burst=5 nodelay;     # 登录限速，允许突发5请求\n        limit_req_status 429;\n    }\n\n    # 连接数限制\n    limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;\n    limit_conn conn_limit_per_ip 10;               # 单IP最大连接数10\n}\n```\n\n------\n\n## 八、监控和日志\n\n### 8.1 访问日志优化\n\n```\nlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n                '$status $body_bytes_sent \"$http_referer\" '\n                '\"$http_user_agent\" \"$http_x_forwarded_for\" '\n                '$request_time $upstream_response_time';\n\nmap $status $loggable {\n    ~^[23]  0;    # 2xx和3xx状态不记录日志，减少磁盘压力\n    default 1;\n}\n\naccess_log /var/log/nginx/access.log main buffer=32k flush=5s if=$loggable;\n```\n\n8.2 Nginx运行状态\n\n```\nlocation /nginx_status {\n    stub_status on;                 # 启用stub_status状态页面\n    access_log off;                 # 禁止访问日志\n    allow 127.0.0.1;                # 只允许本机或内网访问\n    deny all;                       # 拒绝其他IP\n}\n```\n\n------\n\n## 九、最佳实践总结\n\n- 合理设置`worker_processes`，优先 `auto`；\n- 按业务调优`缓冲区`和`keepalive`；\n- `Gzip`压缩开启，`Brotli`可选；\n- 使用`HTTP/2`，提升性能；\n- 合理配置`缓存策略`；\n- 限流、限制连接数保障服务稳定；\n- 配置日志、开启状态监控；\n- 定期压力测试，按需动态调整配置。\n","tags":["nginx"],"categories":["运维"]},{"title":"在不同平台实现守护进程的方式","url":"/2025/07/18/soft/daemon-on-platforms/","content":"\n# 在liunx系统下\n\n## 创建 systemd 服务单元文件\n\n在 `/etc/systemd/system/` 目录下创建 `sshtun.service` 文件：\n\n```\n[Unit]\nDescription=SSH Tunnel Daemon\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/usr/local/bin/sshtun --config /root/.ssh/sshtun.yaml\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n```\n\n> 请根据实际情况修改 `--config` 后面的配置文件路径。\n>\n> `Restart=always` 保证服务异常退出后自动重启。\n\n## 常见命令\n\n~~~\n//重新加载 systemd 配置并启动服务\nsudo systemctl daemon-reload\nsudo systemctl enable sshtun.service\nsudo systemctl start sshtun.service\n\n//查看服务状态\nsudo systemctl status sshtun.service\n// 停止服务\nsudo systemctl stop sshtun.service\n//重启服务\nsudo systemctl restart sshtun.service\n//日志查看\nsudo journalctl -u sshtun.service -f\n// 卸载\nsudo systemctl stop sshtun.service\nsudo systemctl disable sshtun.service\nsudo rm /etc/systemd/system/sshtun.service\nsudo systemctl daemon-reload\nsudo rm /usr/local/bin/sshtun\nrm ~/.ssh/sshtun.yaml\n~~~\n\n# 在macOS系统下\n\n## 选择运行类型\n\n| 类型         | 路径                      | 权限需求  | 适用场景               |\n| ------------ | ------------------------- | --------- | ---------------------- |\n| LaunchAgent  | `~/Library/LaunchAgents/` | 普通用户  | 用户登录后自动运行     |\n| LaunchDaemon | `/Library/LaunchDaemons/` | 需要 root | 开机后就运行（系统级） |\n\n⚠️ 建议：**如果你只为自己用，用 LaunchAgent 就行**。\n\n请将路径 `/usr/local/bin/sshtun` 和 `/Users/yourname/.ssh/sshtun.yaml` 替换成你的实际路径。\n\n你需要替换的内容：\n\n| 占位                               | 示例                                         |\n| ---------------------------------- | -------------------------------------------- |\n| `/usr/local/bin/sshtun`            | 替换成你的 Go 可执行文件绝对路径             |\n| `/Users/yourname/.ssh/sshtun.yaml` | 替换为你的配置文件绝对路径                   |\n| `/Users/yourname/Library/Logs/...` | 改为你 Mac 当前用户名的路径（或用 `~` 展开） |\n\n示例替换后（以用户为 zhiqiang 举例）\n\n> 示例文件：`~/Library/LaunchAgents/com.sshtun.daemon.plist`\n\n~~~\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\"\n \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <!-- 唯一标识 -->\n    <key>Label</key>\n    <string>com.sshtun.daemon</string>\n\n    <!-- 要执行的程序路径 -->\n    <key>ProgramArguments</key>\n    <array>\n        <string>/usr/local/bin/sshtun</string>\n        <string>--config</string>\n        <string>/Users/zhiqiang/.ssh/sshtun.yaml</string>\n    </array>\n\n    <!-- 是否在登录后自动运行 -->\n    <key>RunAtLoad</key>\n    <true/>\n\n    <!-- 如果程序崩溃是否重启 -->\n    <key>KeepAlive</key>\n    <true/>\n\n    <!-- 日志路径 -->\n    <key>StandardOutPath</key>\n    <string>/Users/zhiqiang/Library/Logs/sshtun.out.log</string>\n    <key>StandardErrorPath</key>\n    <string>/Users/zhiqiang/Library/Logs/sshtun.err.log</string>\n</dict>\n</plist>\n~~~\n\n## 常见命令\n\n~~~\n// 修改权限\nchmod 644 ~/Library/LaunchAgents/com.sshtun.daemon.plist\n\n//加载服务\nlaunchctl load ~/Library/LaunchAgents/com.sshtun.daemon.plist\n\n//检查是否成功运行\nlaunchctl list | grep sshtun\n\n//移除服务\nlaunchctl unload ~/Library/LaunchAgents/com.sshtun.daemon.plist\n\n//重启\nlaunchctl unload ~/Library/LaunchAgents/com.sshtun.daemon.plist\nlaunchctl load ~/Library/LaunchAgents/com.sshtun.daemon.plist\n~~~\n\n# 在windows系统下\n\n## 1. 创建任务（自动启动 sshtun）\n\n1. 打开 **任务计划程序**（任务栏搜索“任务计划程序”即可打开）\n2. 点击右侧的“创建任务…”\n3. 在“常规”标签页：\n   - 名称填写：`sshtun`\n   - 选择“使用最高权限运行”\n   - 配置为“Windows 10”或对应系统版本\n4. 在“触发器”标签页：\n   - 点击“新建”\n   - 选择“登录时”或“开机时”启动\n   - 确认\n5. 在“操作”标签页：\n   - 点击“新建”\n   - 操作选择“启动程序”\n   - 程序/脚本填写 `C:\\path\\to\\sshtun.exe`\n   - 在“添加参数”填写 `--config C:\\path\\to\\config.yaml` （根据实际路径修改）\n   - 点击确定\n6. “条件”和“设置”页根据需求调整，通常默认即可。\n7. 保存任务。\n\n## 2. 启动和停止\n\n- 任务计划程序会根据触发器自动运行，无需手动启动。\n- 需要停止时，可以直接结束程序进程，或在任务计划程序中禁用该任务。\n\n------\n\n## 3. 删除任务（卸载）\n\n- 打开任务计划程序\n- 找到你创建的 `sshtun` 任务\n- 右键选择“删除”即可移除自动启动配置\n\n\n\n","tags":["liunx","macOS","windows"],"categories":["运维"]},{"title":"php配置优点","url":"/2025/06/07/php/php-config/","content":"\n### PHP核心配置优化\n\n#### 内存管理策略\n\n~~~\n; php.ini 内存配置\nmemory_limit=256M\n~~~\n\n> - 小型应用：64M-128M\n> - 中型应用：256M-512M\n> - 大型应用：1G以上，需配合监控调整\n\n#### OPcache深度配置\n\n~~~\n; php.ini OPcache配置\nopcache.enable=1\nopcache.memory_consumption=128      ; 根据项目大小调整\nopcache.interned_strings_buffer=16  ; 大型应用可增至32\nopcache.max_accelerated_files=10000 ; 大于项目文件总数\nopcache.revalidate_freq=180         ; 生产环境建议值\nopcache.fast_shutdown=1\n~~~\n\n### 文件与进程管理优化\n\n#### 文件上传配置\n\n~~~\n; 安全高效的文件上传配置\nfile_uploads=On\nupload_max_filesize=10M       ; 根据业务需求调整\npost_max_size=12M             ; 应大于upload_max_filesize\nmax_file_uploads=5            ; 单次请求最大上传数\nupload_tmp_dir=\"/tmp/php_uploads\" ; 指定专用临时目录\n~~~\n\n#### 执行时间与异步处理\n\n~~~\nmax_execution_time=30         ; 常规Web请求\nmax_input_time=60             ; 处理输入数据的最长时间\n~~~\n\n**异步任务处理示例**：\n\n```\n// 使用消息队列处理耗时任务\n$queue=new RedisQueue('report_generation');\n$queue->push([\n  'report_type'=>'zhiqiang',\n  'user_id'=>1\n]);\n// 立即响应客户端\nechojson_encode(['status'=>'queued','job_id'=>$queue->getLastJobId()]);\n```\n\n### 会话与缓存高级策略\n\n#### Redis会话管理\n\n~~~\n; 使用Redis存储会话\nsession.save_handler=redis\nsession.save_path=\"tcp://127.0.0.1:6379?auth=yourpassword\"\nsession.gc_maxlifetime=1440   ; 24分钟过期时间\n~~~\n\n**Redis连接优化脚本**：\n\n~~~\n$redis=new Redis();\n$redis->connect('127.0.0.1',6379,2.5);// 2.5秒连接超时\n$redis->setOption(Redis::OPT_SERIALIZER,Redis::SERIALIZER_IGBINARY);\n~~~\n\n#### 输出缓冲控制\n\n~~~\n; 输出缓冲配置\noutput_buffering=4096         ; 4KB缓冲块\nimplicit_flush=Off            ; 禁用自动刷新\nzlib.output_compression=On    ; 启用Gzip压缩\n~~~\n\n### 系统级性能优化\n\n#### 真实路径缓存优化\n\n~~~\n; 真实路径缓存配置\nrealpath_cache_size=256K      ; 大型应用可增至1M\nrealpath_cache_ttl=3600       ; 缓存1小时\n~~~\n\n#### 进程管理与FPM调优\n\n~~~\n; php-fpm.conf 优化配置\npm=dynamic\npm.max_children=50            ; 最大子进程数\npm.start_servers=10           ; 启动时进程数\npm.min_spare_servers=5        ; 最小空闲进程\npm.max_spare_servers=15       ; 最大空闲进程\npm.max_requests=1000          ; 每个进程处理请求数后重启\n~~~\n\n### 高级性能优化技巧\n\n#### 预加载优化(PHP 7.4+)\n\n~~~\n; 预加载配置\nopcache.preload=/path/to/preload.php\nopcache.preload_user=www-data\n~~~\n\n**preload.php示例**：\n\n~~~\n\n<?php\n// 预加载常用类文件\nopcache_compile_file('vendor/autoload.php');\nopcache_compile_file('app/Models/User.php');\n~~~\n\n####  JIT编译(PHP 8.0+)\n\n~~~\n; PHP 8 JIT配置\nopcache.jit_buffer_size=100M\nopcache.jit=tracing            ; 对大多数应用最佳\n~~~\n\n### 监控与持续优化\n\n#### 性能监控脚本\n\n~~~\n// 综合性能检查\n$start=microtime(true);\n$memoryStart=memory_get_usage();\n\n// 业务代码...\n\n$timeElapsed=microtime(true)-$start;\n$memoryUsed=memory_get_usage()-$memoryStart;\n\nfile_put_contents('performance.log',sprintf(\n\"[%s] Time: %.2fms Memory: %.2fMB\\n\",\ndate('Y-m-d H:i:s'),\n$timeElapsed*1000,\n$memoryUsed/1024/1024\n),FILE_APPEND);\n~~~\n\n#### 基准测试工具\n\n**Apache Bench测试示例**：\n\n~~~\nab -n 1000-c 100 https://www.zhiqiang.wang\n~~~\n\n### 架构层面的优化建议\n\n1. CDN集成\n\n   将静态资源卸载到CDN\n\n2. 数据库优化\n\n   使用查询缓存和索引优化\n\n3. HTTP/2支持\n\n   减少网络延迟\n\n4. OPcache预热\n\n   部署时预先缓存所有PHP文件\n\n### 性能优化路线图\n\n1. 基础优化\n\n   ：配置OPcache，调整内存设置\n\n2. 中级优化\n\n   ：会话管理，输出缓冲，FPM调优\n\n3. 高级优化\n\n   ：预加载，JIT编译，异步处理\n\n4. 持续监控\n\n   ：建立性能基准，定期测试","tags":["php调试优"],"categories":["php"]},{"title":"docker日志清理","url":"/2025/06/07/docker/log/","content":"\n日志默认位置：\n\n```\n/var/lib/docker/containers/<container-id>/<container-id>-json.log\n```\n\n### 运行容器时设置轮转策略\n\n~~~\ndocker run -d \\\n  --name myapp \\\n  --log-driver json-file \\\n  --log-opt max-size=10m \\\n  --log-opt max-file=3 \\\n  myapp:latest\n~~~\n\n**参数解释：**\n\n- `max-size=10m`：单个日志文件最大 10MB\n- `max-file=3`：最多保留 3 个轮转文件（最多 30MB）\n\n**容器总日志控制在 30MB 内，绝不爆炸！**\n\n### **修改 Docker 配置**\n\n该配置适用于所有容器\n\n编辑配置文件 `/etc/docker/daemon.json`：\n\n~~~\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"5\"\n  }\n}\n~~~\n\n重启 Docker 服务\n\n~~~\nsystemctl restart docker\n~~~\n\n### **正在运行的容器**\n\n~~~\necho \"\" > $(docker inspect --format='{{.LogPath}}' <container-id>)\n~~~\n\n或者更稳一点：\n\n1. `docker stop` 停掉容器\n2. `docker rm` 删除容器\n3. 使用轮转参数重新 run容器\n\n###  **禁用日志输出**\n\n这个操作慎用，有可能影响应用运行，而且不方便后续排查\n\n~~~\ndocker run --log-driver=none 容器名\n~~~\n\n### **日志快速清理**\n\n仅推荐在磁盘告急时临时使用！\n\n```\nfind /var/lib/docker/containers -name *-json.log -exec truncate -s 0 {} \\;\n```\n\n根据不同场景推荐配置值。\n\n| 场景     | 建议参数                    |\n| :------- | :-------------------------- |\n| 开发环境 | `max-size=5m``max-file=3`   |\n| 测试环境 | `max-size=10m``max-file=5`  |\n| 生产环境 | `max-size=50m``max-file=10` |","tags":["Docker"],"categories":["docker"]},{"title":"语义版本控制（Semantic Versioning，简称 SemVer）","url":"/2025/04/29/management/software-version/","content":"\n\n\n在绝大多数项目中，尤其是开源社区，采用的都是**语义版本控制（Semantic Versioning，简称 SemVer）**。\n\nSemVer 建议将版本号划分为三个部分：\n\n~~~\n主版本号.次版本号.补丁版本号\nX.Y.Z\n~~~\n\n各部分含义分别是：\n\n- • **主版本号（X）**：出现破坏性改动时增加，表明与过去版本不兼容。\n- • **次版本号（Y）**：新增功能，且保持向后兼容时增加。\n- • **补丁版本号（Z）**：进行向后兼容的问题修正时增加。\n\n例如，Node.js 的某个版本 `20.2.1` 中：\n\n- • `20` 表示主版本，意味着与前一个主版本相比，可能有重大变化；\n- • `2` 表示新增了功能，但保持兼容；\n- • `1` 表示修复了小问题。\n","tags":["git","开源项目"],"categories":["版本控制"]},{"title":"git开发流程","url":"/2025/04/29/git/development-process/","content":"\n团队开发中，遵循一个合理、清晰的 Git 规范，是非常重要的。\n\n否则，每个人都提交一堆杂乱无章的 commit 和 分支，项目很快就会变得难以协调和维护。\n\n## **分支规范**\n\n- main：主分支。\n\n主分支，始终与正式环境代码保持一致。 不能将代码直接 commit 到该分支，仅合并 develop 在测试服验证完成的代码。\n\n- develop：开发分支。\n\n开发分支，在测试环境验证过的分支请求合并到该分支。 不能将代码直接 commit 到该分支，合并 feature、fixbug 分支的代码。\n\n- develop-cicd：开发分支，与测试服代码保持一致。\n- feature：功能开发分支。\n\n开发功能分支，当有新功能需要开发时，则从 develop 拉新 feature 出来。\n\n- fixbug：bug 修复分支。\n\n### **新需求**\n\n来新需求了，从哪里开新分支？\n\n直接从 develop 拉新 feature 分支即可。\n\n### **需求完成**\n\n需求完成了，合并到哪个分支？\n\n请求合并到 develop-cicd 分支即可，然后到测试环境验证。\n\n### **测试服解决bug**\n\n测试环境中出现 bug 了，在哪个分支修复？\n\n直接在对应的 feature 分支进行修改后再请求合并到 develop-cicd 进行测试。\n\n### **更新正式服**\n\n测试完成，请求合并到哪个分支进行发布？\n\n测试环境验证完成后再请求合并到 develop 分支。\n\n从 develop 分支请求合并到 main 分支。\n\n### **正式服解决bug**\n\n测试环境没测试出来，正式环境出现 bug 了，在哪个分支进行修复？\n\n直接从 develop 拉新 fixbug 分支进行解决，然后请求合并到 develop-cicd 进行测试。\n\n测试环境验证完成后再请求合并到 develop 分支。\n\n## **Commit message 规范**\n\n格式化的 Commit message，有几个好处。\n\n1. 提供更多的历史信息，方便快速浏览。\n2. 可以过滤某些 commit（比如文档改动、依赖升级等），便于快速查找信息。\n3. 可以直接从 commit 生成 Change log。\n\n提交规则：不允许大量代码一起提交，所提交的内容必须是在 commit message 描述中有体现。\n\n### **前缀**\n\n- feature：新功能，新业务。\n- fixbug：修补 bug。\n- docs：文档。\n- refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）。\n- test：增加测试。\n- style：格式（不影响代码运行的变动）。\n- up：依赖升级。\n\n### **举例**\n\n- feature：用户模块实体、mapper、service。\n- feature：用户模块接口。\n- feature：member表新增字段。\n- fixbug：修改用户信息名称字段使用错误。\n- docs：开发规范类注释模板修改。\n- refactor：用户实体名称修改。\n- test：增加修改用户名称测试。\n- style：代码格式化。\n- up：Spring依赖升级，从2.x到3.x。\n","tags":["branch"],"categories":["git"]},{"title":"liunx挂载磁盘","url":"/2025/02/21/soft/liunx-mount-disk/","content":"\n1. **查看磁盘信息**\n\n~~~\nfdisk -l\n~~~\n\n找到你要挂载的磁盘设备，比如 `/dev/sdb`。\n\n2. **创建分区（如果磁盘未分区）**\n\n~~~\nsudo fdisk /dev/sdb\n~~~\n\n在 `fdisk` 交互模式下：\n\n- 输入 `n` 创建新分区\n- 选择 `p` 作为主分区\n- 选择默认的分区编号\n- 直接回车使用默认大小\n- 输入 `w` 保存分区\n\n然后刷新分区表：\n\n~~~\nsudo partprobe /dev/sdb\n~~~\n\n3. **格式化分区**\n\n如果是新分区，格式化它（例如 ext4）：\n\n~~~\nsudo mkfs.ext4 /dev/sdb1\n~~~\n\n4. **创建挂载目录**\n\n~~~\nsudo mkdir -p /data\n~~~\n\n5. **手动挂载磁盘**\n\n~~~\nsudo mount /dev/sdb1 /data\n~~~\n\n然后可以 `cd /mnt/data` 进去看看。\n\n6. **设置开机自动挂载**\n\n~~~\necho \"/dev/sdb1 /data ext4 defaults 0 0\" >> /etc/fstab\n~~~\n\n然后运行：\n\n```\nsudo mount -a\n```\n\n7. **防止崩溃**\n\n确认没有报错，即可重启生效。\n\n`mount -a` —— 立即验证是否有错误\n\n`lsblk` / `df -h` —— 查看是否成功挂载\n\n`findmnt --verify` —— 语法检查\n\n`systemd-analyze verify /etc/fstab` —— 深入分析\n\n重启前加 `nofail`，防止崩溃 \n\n~~~\n/dev/sdb1 /mnt/data ext4 defaults,nofail 0 0\n~~~\n\n","tags":["liunx","磁盘挂载","ubuntu"],"categories":["运维"]},{"title":"Git LFS基本使用","url":"/2025/01/02/git/lfs/","content":"\n# 1. Git LFS 简介\n\n> Git LFS: An open source Git extension for versioning large files\n> Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.\n\nGit LFS (Large File Storage）是一个开源的Git大文件版本控制的解决方案和工具集，工具自身是基于Golang进行实现，并在Github上开源。原理上是通过对Git客户端进行扩展的方式，从而集成并兼容了原生的Git客户端。Git LFS良好的设计，让用户感觉在对大文件处理过程中，与普通Git的使用方式上没有任何差别，也就是说，在使用方式上Git LFS对用户是完全透明的。\n\n参考文档：\n\n- [GIT Large File Storage](https://git-lfs.com/)\n- [github - git-lfs/git-lfs](https://github.com/git-lfs/git-lfs)\n- [关于 Git Large File Storage](https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-git-large-file-storage)\n- [什么是Git LFS大文件存储?](https://help.aliyun.com/document_detail/206887.html)\n- [如何使用 Git LFS](https://help.aliyun.com/document_detail/206889.html)\n\n# 2. 下载和安装Git LFS\n\n## 2.1. 官方脚本安装\n\n1、下载适合系统的 [git-lfs/releases](https://github.com/git-lfs/git-lfs/releases)\n\n2、解压安装\n解压后，执行 `install.sh` 脚本，这个脚本会做两个事情：\n\n- 在`$PATH`中安装Git LFS的二进制可执行文件\n- 执行`git lfs install`命令，让当前环境支持全局的LFS配置\n\n安装成功，会输出：\n\n```\nGit LFS initialized.\n```\n\n## 2.2. Linux\n\n参考文档：[Git LFS - Installation instructions](https://packagecloud.io/github/git-lfs/install)\n\nLinux Debian：\n\n```\ncurl -s http://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash\n```\n\nRPM packages：\n\n```\ncurl -s http://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash\n```\n\n## 2.3. MacOS\n\n```\nbrew install git-lfs\n```\n\n## 2.4. Windows\n\n目前lfs已经集成在了Git for Windows 中，直接下载和使用最新版本的Windows Git即可。\n\n# 3. 让仓库支持Git LFS\n\n```\ngit lfs install\n```\n\n如果官方脚本安装，那么不需要执行这条命令。\n\n# 4. 使用Git LFS\n\n1、设置LFS追踪 mp4 类型的文件\n\n```\ngit lfs track \"*.mp4\"\n```\n\ntrack 命令实际上是修改了仓库中的 `.gitattributes` 文件。\n\n2、查看LFS追踪的文件类型\n\n```\ngit lfs track\n```\n\n3、提交 `.gitattributes` 文件\n\n```\ngit add .gitattributes\ngit commit -m \"Add LFS config\"\n```\n\n4、放入一个 mp4 类型的文件到仓库中\n\n5、提交并推送 mp4 类型文件\n\n```\ngit add test.mp4\ngit commit -m \"Add a bigfile\"\ngit push\n```\n\n推送后，查看该mp4文件，会显示 Stored with Git LFS 。\n\n注意：github中fork的仓库是不支持LFS上传大文件的，详情参考：[can not upload new objects to public fork](https://github.com/git-lfs/git-lfs/issues/1906)。如果想要上传大文件，需要源仓库管理员授权push的权限。\n","tags":["git","LFS"],"categories":["git"]},{"title":"Go 常见错误及如何避免","url":"/2024/10/26/golang/errors-and-avoidance/","content":"\n## 代码及工程组织\n\n### 意外的变量隐藏 \n\n避免变量隐藏（外部作用域变量被内部作用域同名变量隐藏），有助于避免变量引用错误，有助于他人阅读理解。\n\n### 不必要的代码嵌套 \n\n避免不必要的、过多的嵌套层次，并且让正常代码路径尽量左对齐（而不是放在分支路径中），有助于构建可读性更好的代码。\n\n### 误用 init 函数 \n\n初始化变量时，请记住 init 函数具有有限的错误处理能力，并且会使状态处理和测试变得更加复杂。在大多数情况下，初始化应该作为特定函数来处理。\n\n### 滥用 getters/setters \n\n在 Go 语言中，强制使用 getter 和 setter 方法并不符合 Go 惯例。在实践中，应该找到效率和盲目遵循某些惯用法之间的平衡点。\n\n### 接口污染 \n\n抽象应该被发现，而不是被创造。为了避免不必要的复杂性，需要时才创建接口，而不是预见到需要它，或者至少可以证明这种抽象是有价值的。\n\n### 将接口定义在实现方一侧 \n\n将接口保留在引用方一侧（而不是实现方一侧）可以避免不必要的抽象。\n\n### 将接口作为返回值 \n\n为了避免在灵活性方面受到限制，大多数情况下函数不应该返回接口，而应该返回具体的实现。相反，函数应该尽可能地使用接口作为参数。\n\n### `any` 没传递任何信息 \n\n只有在需要接受或返回任意类型时，才使用 `any`，例如 `json.Marshal`。其他情况下，因为 `any` 不提供有意义的信息，可能会导致编译时问题，如允许调用者调用方法处理任意类型数据。\n\n### 困惑何时该用范型 \n\n使用泛型，可以通过类型参数分离具体的数据类型和行为，避免写很多重复度很高的代码。然而，不要过早地使用泛型、类型参数，只有在你看到真正需要时才使用。否则，它们会引入不必要的抽象和复杂性。\n\n### 未意识到类型嵌套的可能问题 \n\n使用类型嵌套也可以避免写一些重复代码，然而，在使用时需要确保不会导致不合理的可见性问题，比如有些字段应该对外隐藏不应该被暴露。\n\n### 不使用 function option 模式 \n\n为了设计并提供更友好的 API（可选参数），为了更好地处理选项，应该使用 function option 模式。\n\n### 工程组织不合理 (工程结构和包的组织) \n\n遵循像 project-layout 的建议来组织 Go 工程是一个不错的方法，尤其是你正在寻找一些类似的经验、惯例来组织一个新的 Go 工程的时候。\n\n### 创建工具包 \n\n命名是软件设计开发中非常重要的一个部分，创建一些名如 `common`、`util`、`shared` 之类的包名并不会给读者带来太大价值，应该将这些包名重构为更清晰、更具体的包名。\n\n### 忽略了包名冲突 \n\n为了避免变量名和包名之间的冲突，导致混淆或甚至错误，应为每个变量和包使用唯一的名称。如果这不可行，可以考虑使用导入别名 `import importAlias 'importPath'` 以区分包名和变量名，或者考虑一个更好的变量名。\n\n### 代码缺少文档 \n\n为了让使用方、维护人员能更清晰地了解你的代码的意图，导出的元素（函数、类型、字段）需要添加注释。\n\n### 不使用 linters 检查 \n\n为了改善代码质量、整体代码的一致性，应该使用 linters 和 formatters。\n\n## 数据类型\n\n### 八进制字面量引发的困惑 \n\n在阅读现有代码时，请记住以 0 开头的整数字面量是八进制数。此外，为了提高可读性，可以通过在前面加上 0o 来显式地表示八进制整数。\n\n### 未注意可能的整数溢出 \n\n在 Go 中整数上溢出和下溢是静默处理的，所以你可以实现自己的函数来捕获它们。\n\n### 没有透彻理解浮点数 \n\n比较浮点数时，通过比较二者的 delta 值是否介于一定的范围内，能让你写出可移植性更好的代码。\n\n在进行加法或减法时，将具有相似数量级的操作分成同一组以提高精度 (过早指数对齐丢失精度)。此外，在进行加法和减法之前，应先进行乘法和除法 (加减法误差会被乘除放大)。\n\n### 不理解 slice 的长度和容量\n\n理解 slice 的长度和容量的区别，是一个 Go 开发者的核心知识点之一。slice 的长度指的是 slice 已经存储的元素的数量，而容量指的是 slice 当前底层开辟的数组最多能容纳的元素的数量。\n\n### 不高效的 slice 初始化 \n\n当创建一个 slice 时，如果其长度可以预先确定，那么可以在定义时指定它的长度和容量。这可以改善后期 append 时一次或者多次的内存分配操作，从而改善性能。对于 map 的初始化也是如此。\n\n### 困惑于 nil 和空 slice \n\n为了避免常见的对 nil 和 empty slice 处理行为的混淆，例如在使用 encoding/json 或 reflect 包时，你需要理解 nil 和 empty slice 的区别。两者都是长度为零、容量为零的切片，但是 nil 切片不需要分配内存。\n\n### 没有适当检查 slice 是否为空 \n\n检查一个 slice 是否包含任何元素，可以检查其长度，不管 slice 是 nil 还是 empty，检查长度都是有效的。这个检查方法也适用于 map。\n\n为了设计更明确的 API，API 不应区分 nil 和空切片。\n\n### 没有正确拷贝 slice \n\n使用 `copy` 拷贝一个 slice 元素到另一个 slice 时，需要记得，实际拷贝的元素数量是二者 slice 长度中的较小值。\n\n### slice append 带来的预期之外的副作用 \n\n如果两个不同的函数操作的 slice 复用了相同的底层数组，它们对 slice 执行 append 操作时可能会产生冲突。使用 copy 来完整复制一个 slice 或者使用完整的 slice 表达式 `[low:high:max]` 限制最大容量，有助于避免产生冲突。当想对一个大 slice 进行 shrink 操作时，两种方式中，只有 copy 才可以避免内存泄漏。\n\n### slice 和内存泄漏 \n\n对于 slice 元素为指针，或者 slice 元素为 struct 但是该 struct 含有指针字段，当通过 `slice[low:high]` 操作取 subslice 时，对于那些不可访问的元素可以显式设置为 nil 来避免内存泄露。\n\n### map 和内存泄漏\n\n一个 map 的 buckets 占用的内存只会增长，不会缩减。因此，如果它导致了一些内存占用的问题，你需要尝试不同的方式来解决，比如重新创建一个 map 代替原来的（原来的 map 会被 GC 掉），或者 `map[keyType]valueType` 中的 valueType 使用指针代替长度固定的数组或者 sliceHeader 来缓解过多的内存占用。\n\n### 不正确的值比较 \n\nGo 中比较两个类型值时，如果是可比较类型，那么可以使用 `==` 或者 `!=` 运算符进行比较，比如：booleans、numerals、strings、pointers、channels，以及字段全部是可比较类型的 structs。其他情况下，你可以使用 `reflect.DeepEqual` 来比较，用反射的话会牺牲一点性能，也可以使用自定义的实现和其他库来完成。\n\n## 控制结构\n\n### 忽略了 `range` 循环变量是一个拷贝 \n\n`range` 循环中的循环变量是遍历容器中元素值的一个拷贝。因此，如果元素值是一个 struct 并且想在 `range` 中修改它，可以通过索引值来访问并修改它，或者使用经典的 for 循环+索引值的写法（除非遍历的元素是一个指针）。\n\n### 忽略了 `range` 循环中迭代目标值的计算方式 (channels 和 arrays) \n\n传递给 `range` 操作的迭代目标对应的表达式的值，只会在循环执行前被计算一次，理解这个有助于避免犯一些常见的错误，例如不高效的 channel 赋值操作和 slice 迭代操作。\n\n### 忽略了 `range` 循环中指针元素的影响 \n\n这里其实强调的是 `range` 迭代过程中，迭代变量实际上是一个拷贝。假设给另外一个容器元素（指针类型）赋值，且需要对迭代变量取地址转换成指针再赋值的话，这里潜藏着一个错误，就是 for 循环迭代变量是 per-variable-per-loop 而不是 per-variable-per-iteration。如果是通过局部变量（用迭代变量来初始化）或者使用索引值来直接引用迭代的元素，将有助于避免拷贝指针(迭代变量的地址)之类的 bug。\n\n### map 迭代过程中的错误假设（遍历顺序和迭代过程中插入）\n\n使用 map 时，为了能得到确定一致的结果，应该记住 Go 中的 map 数据结构： * 不会按照 key 对 data 进行排序，遍历时 key 不是有序的； * 遍历时的顺序，也不是按照插入时的顺序； * 没有一个确定性的遍历顺序，每次遍历顺序是不同的； * 不能保证迭代过程中新插入的元素，在当前迭代中能够被遍历到；\n\n### 忽略了 `break` 语句是如何工作的 \n\n配合 label 使用 `break` 和 `continue`，能够跳过一个特定的语句，在某些循环中存在 `switch` 和 `select` 语句的场景中就比较有帮助。\n\n### 在循环中使用 `defer` \n\n在循环中使用 defer 不能在每轮迭代结束时执行 defer 语句，但是将循环逻辑提取到函数内部会在每次迭代结束时执行 defer 语句。\n\n## 字符串\n\n### 没有理解 rune \n\n理解 rune 类型对应的是一个 unicode 码点，每一个 unicode 码点其实是一个多字节的序列，不是一个 byte。这应该是 Go 开发者的核心知识点之一，理解了这个有助于更准确地处理字符串。\n\n### 不正确的字符串遍历 \n\n使用 `range` 操作符对一个 string 进行遍历实际上是对 string 对应的 `[]rune` 进行遍历，迭代变量中的索引值，表示的当前 rune 对应的 `[]rune` 在整个 `[]rune(string)` 中的起始索引。如果要访问 string 中的某一个 rune（比如第三个），首先要将字符串转换为 `[]rune` 然后再按索引值访问。\n\n### 误用 trim 函数 \n\n`strings.TrimRight`/`strings.TrimLeft` 移除在字符串尾部或者开头出现的一些 runes，函数会指定一个 rune 集合，出现在集合中的 rune 将被从字符串移除。而 `strings.TrimSuffix`/`strings.TrimPrefix` 是移除字符串的一个后缀/前缀。\n\n### 不经优化的字符串拼接操作 \n\n对一个字符串列表进行遍历拼接操作，应该通过 `strings.Builder` 来完成，以避免每次迭代拼接时都分配一个新的 string 对象出来。\n\n### 无用的字符串转换 \n\n`bytes` 包提供了一些和 `strings` 包相似的操作，可以帮助避免 []byte/string 之间的转换。\n\n### 子字符串和内存泄漏 \n\n使用一个子字符串的拷贝，有助于避免内存泄漏，因为对一个字符串的 `s[low:high]` 操作返回的子字符串，其使用了和原字符串 s 相同的底层数组。\n\n## 函数和方法\n\n### 不知道使用哪种接收器类型 \n\n对于接收器类型是采用 value 类型还是 pointer 类型，应该取决于下面这几种因素，比如：方法内是否会对它进行修改，它是否包含了一个不能被拷贝的字段，以及它表示的对象有多大。如果有疑问，接收器可以考虑使用 pointer 类型。\n\n### 从不使用命名的返回值 \n\n使用命名的返回值，是一种有效改善函数、方法可读性的方法，特别是返回值列表中有多个类型相同的参数。另外，因为返回值列表中的参数是经过零值初始化过的，某些场景下也会简化函数、方法的实现。但是需要注意它的一些潜在副作用。\n\n### 使用命名的返回值时预期外的副作用 \n\n使用命名的返回值，因为它已经被初始化了零值，需要注意在某些情况下异常返回时是否需要给它赋予一个不同的值，比如返回值列表定义了一个有名参数 `err error`，需要注意 `return err` 时是否正确地对 `err` 进行了赋值。\n\n### 返回一个 nil 接收器 \n\n当返回一个 interface 参数时，需要小心，不要返回一个 nil 指针，而是应该显式返回一个 nil 值。否则，可能会发生一些预期外的问题，因为调用方会收到一个非 nil 的值。\n\n### 使用文件名作为函数入参 \n\n设计函数时使用 `io.Reader` 类型作为入参，而不是文件名，将有助于改善函数的可复用性、易测试性。\n\n### 忽略 `defer` 语句中参数、接收器值的计算方式 (参数值计算, 指针, 和 value 类型接收器) \n\n为了避免 `defer` 语句执行时就立即对 defer 要执行的函数的参数进行计算，可以考虑将要执行的函数放到闭包里面，然后通过指针传递参数给闭包内函数（或者通过闭包捕获外部变量），来解决这个问题。\n\n## 错误管理\n\n### Panicking \n\n使用 `panic` 是 Go 中一种处理错误的方式，但是只能在遇到不可恢复的错误时使用，例如：通知开发人员一个强依赖的模块加载失败了。\n\n### 未考虑何时才应该包装 error \n\nWrapping（包装）错误允许您标记错误、提供额外的上下文信息。然而，包装错误会创建潜在的耦合，因为它使得原来的错误对调用者可见。如果您想要防止这种情况，请不要使用包装错误的方式。\n\n### 不正确的错误类型比较 \n\n如果你使用 Go 1.13 引入的特性 `fmt.Errorf` + `%w` 来包装一个错误，当进行错误比较时，如果想判断该包装后的错误是不是指定的错误类型，就需要使用 `errors.As`，如果想判断是不是指定的 error 对象就需要用 `errors.Is`。\n\n### 不正确的错误对象值比较 \n\n为了表达一个预期内的错误，请使用错误值的方式，并通过 `==` 或者 `errors.Is` 来比较。而对于意外错误，则应使用特定的错误类型（可以通过 `errors.As` 来比较）。\n\n### 两次处理同一个错误 \n\n大多数情况下，错误仅需要处理一次。打印错误日志也是一种错误处理。因此，当函数内发生错误时，应该在打印日志和返回错误中选择其中一种。包装错误也可以提供问题发生的额外上下文信息，也包括了原来的错误（可考虑交给调用方负责打日志）。\n\n### 不处理错误 \n\n不管是在函数调用时，还是在一个 `defer` 函数执行时，如果想要忽略一个错误，应该显式地通过 `_` 来忽略（可注明忽略的原因）。否则，将来的读者就会感觉到困惑，忽略这个错误是有意为之还是无意中漏掉了。\n\n### 不处理 `defer` 中的错误 \n\n大多数情况下，你不应该忽略 `defer` 函数执行时返回的错误，或者显式处理它，或者将它传递给调用方处理，可以根据情景进行选择。如果你确定要忽略这个错误，请显式使用 `_` 来忽略。\n\n## 并发编程: 基础\n\n### 混淆并发和并行 \n\n理解并发（concurrency）、并行（parallelism）之间的本质区别是 Go 开发人员必须要掌握的。并发是关于结构设计上的，并行是关于具体执行上的。\n\n### 认为并发总是更快\n\n要成为一名熟练的开发人员，您必须意识到并非所有场景下都是并发的方案更快。对于任务中的最小工作负载部分，对它们进行并行化处理并不一定就有明显收益或者比串行化方案更快。对串行化、并发方案进行 benchmark 测试，是验证假设的好办法。\n\n### 不清楚何时使用 channels 或 mutexes \n\n了解 goroutine 之间的交互也可以在选择使用 channels 或 mutexes 时有所帮助。一般来说，并行的 goroutine 需要同步，因此需要使用 mutexes。相反，并发的 goroutine 通常需要协调和编排，因此需要使用 channels。\n\n### 不明白竞态问题 (数据竞态 vs. 竞态条件和 Go 内存模型) \n\n掌握并发意味着要认识到数据竞争（data races）和竞态条件（race conditions）是两个不同的概念。数据竞争，指的是有多个 goroutines 同时访问相同内存区域时，缺乏必要的同步控制，且其中至少有一个 goroutine 执行的是写操作。同时要认识到，没有发生数据竞争不代表程序的执行是确定性的、没问题的。当在某个特定的操作顺序或者特定的事件发生顺序下，如果最终的行为是不可控的，这就是竞态条件。\n\n> ps：数据竞争是竞态条件的子集，竞态条件不仅局限于访存未同步，它可以发生在更高的层面。`go test -race` 检测的是数据竞争，需要同步来解决，而开发者还需要关注面更广的竞态条件，它需要对多个 goroutines 的执行进行编排。\n\n理解 Go 的内存模型以及有关顺序和同步的底层保证是防止可能的数据竞争和竞态条件的关键。\n\n### 不理解不同工作负载类型对并发的影响 \n\n当创建一定数量的 goroutines 时，需要考虑工作负载的类型。如果工作负载是 CPU 密集型的，那么 goroutines 数量应该接近于 `GOMAXPROCS` 的值（该值取决于主机处理器核心数）。如果工作负载是 IO 密集型的，goroutines 数量就需要考虑多种因素，比如外部系统（考虑请求、响应速率）。\n\n### 误解了 Go contexts \n\nGo 的上下文（context）也是 Go 并发编程的基石之一。上下文允许您携带截止时间、取消信号和键值列表。\n\n## 并发编程: 实践\n\n### 传递不合适的 context \n\n当我们传递了一个 context，我们需要知道这个 context 什么时候可以被取消，这点很重要，例如：一个 HTTP 请求处理器在发送完响应后取消 context。\n\n> ps: 实际上 context 表达的是一个动作可以持续多久之后被停止。\n\n### 启动了一个 goroutine 但是不知道它何时会停止 \n\n避免 goroutine 泄漏，要有这种意识，当创建并启动一个 goroutine 的时候，应该有对应的设计让它能正常退出。\n\n### 不注意处理 goroutines 和循环中的迭代变量 \n\n为了避免 goroutines 和循环中的迭代变量问题，可以考虑创建局部变量并将迭代变量赋值给局部变量，或者 goroutines 调用带参数的函数，将迭代变量值作为参数值传入，来代替 goroutines 调用闭包。\n\n### 使用 select + channels 时误以为分支选择顺序是确定的 \n\n要明白，`select` 多个 channels 时，如果多个 channels 上的操作都就绪，那么会随机选择一个 `case` 分支来执行，因此要避免有分支选择顺序是从上到下的这种错误预设，这可能会导致设计上的 bug。\n\n### 不正确使用通知 channels \n\n发送通知时使用 `chan struct{}` 类型。\n\n> ps: 先明白什么是通知 channels，一个通知 channels 指的是只是用来做通知，而其中传递的数据没有意义，或者理解成不传递数据的 channels，这种称为通知 channels。其中传递的数据的类型为 struct{} 更合适。\n\n### 不使用 nil channels \n\n使用 nil channels 应该是并发处理方式中的一部分，例如，它能够帮助禁用 `select` 语句中的特定的分支。\n\n### 不清楚该如何确定 channel size \n\n根据指定的场景仔细评估应该使用哪一种 channel 类型（带缓冲的，不带缓冲的）。只有不带缓冲的 channels 可以提供强同步保证。\n\n使用带缓冲的 channels 时如果不确定 size 该如何设置，可以先设为 1，如果有合理的理由再去指定 channels size。\n\n> ps: 根据 disruptor 这个高性能内存消息队列的实践，在某种读写 pacing 下，队列要么满要么空，不大可能处于某种介于中间的稳态。\n\n### 忘记了字符串格式化可能带来的副作用（例如 etcd 数据竞争和死锁）\n\n意识到字符串格式化可能会导致调用现有函数，这意味着需要注意可能的死锁和其他数据竞争问题。\n\n> ps: 核心是要关注 `fmt.Sprintf` + `%v` 进行字符串格式化时 `%v` 具体到不同的类型值时，实际上执行的操作是什么。比如 `%v` 这个 placeholder 对应的值是一个 `context.Context`，那么会就遍历其通过 `context.WithValue` 附加在其中的 values，这个过程可能涉及到数据竞争问题。书中提及的另一个导致死锁的案例本质上也是一样的问题，只不过又额外牵扯到了 `sync.RWMutex` 不可重入的问题。\n\n### 使用 append 不当导致数据竞争 \n\n调用 `append` 不总是没有数据竞争的，因此不要在一个共享的 `slice` 上并发地执行 `append`。\n\n### 误用 mutexes 和 slices、maps \n\n请记住 slices 和 maps 是引用类型，有助于避免常见的数据竞争问题。\n\n> ps: 这里实际是因为错误理解了 slices 和 maps，导致写出了错误地拷贝 slices 和 maps 的代码，进而导致锁保护无效、出现数据竞争问题。\n\n### 误用 `sync.WaitGroup` \n\n正确地使用 `sync.WaitGroup` 需要在启动 goroutines 之前先调用 `Add` 方法。\n\n### 忘记使用 `sync.Cond` \n\n你可以使用 `sync.Cond` 向多个 goroutines 发送重复的通知。\n\n### 不使用 `errgroup` \n\n你可以使用 `errgroup` 包来同步一组 goroutines 并处理错误和上下文。\n\n### 拷贝一个 `sync` 下的类型 \n\n`sync` 包下的类型不应该被拷贝。\n\n## 标准库\n\n### 使用了错误的 time.Duration \n\n注意有些函数接收一个 `time.Duration` 类型的参数时，尽管直接传递一个整数是可以的，但最好还是使用 time API 中的方法来传递 duration，以避免可能造成的困惑和 bug。\n\n> ps: 重点是注意 time.Duration 定义的是 nanoseconds 数。\n\n### `time.After` 和内存泄漏 \n\n避免在重复执行很多次的函数（如循环中或 HTTP 处理函数）中调用 `time.After`，这可以避免内存峰值消耗。由 `time.After` 创建的资源仅在计时器超时才会被释放。\n\n### JSON 处理中的常见错误 \n\n- 类型嵌套导致的预料外的行为\n\n要当心在 Go 结构体中嵌入字段，这样做可能会导致诸如嵌入的 `time.Time` 字段实现 `json.Marshaler` 接口，从而覆盖默认的 JSON 序列。\n\n- JSON 和单调时钟\n\n当对两个 `time.Time` 类型值进行比较时，需要记住 `time.Time` 包含了一个墙上时钟（wall clock）和一个单调时钟 （monotonic clock），而使用 `==` 运算符进行比较时会同时比较这两个。\n\n- Map 键对应值为 `any`\n\n当提供一个 map 用来 unmarshal JSON 数据时，为了避免不确定的 value 结构我们会使用 `any` 来作为 value 的类型而不是定义一个 struct，这种情况下需要记得数值默认会被转换为 `float64`。\n\n### 常见的 SQL 错误 \n\n- 忘记了 `sql.Open` 并没有与 db 服务器建立实际连接\n\n需要调用 `Ping` 或者 `PingContext` 方法来测试配置并确保数据库是可达的。\n\n- 忘记了使用连接池\n\n作为生产级别的应用，访问数据库时应该关注配置数据库连接池参数。\n\n- 没有使用 prepared 语句\n\n使用 SQL prepared 语句能够让查询更加高效和安全。\n\n- 误处理 null 值\n\n使用 `sql.NullXXX` 类型处理表中的可空列。\n\n- 不处理行迭代时的错误\n\n调用 `sql.Rows` 的 `Err` 方法来确保在准备下一个行时没有遗漏错误。\n\n### 不关闭临时资源（HTTP 请求体、`sql.Rows` 和 `os.File`） \n\n最终要注意关闭所有实现 `io.Closer` 接口的结构体，以避免可能的泄漏。\n\n### 响应 HTTP 请求后没有返回语句 \n\n为了避免在 HTTP 处理函数中出现某些意外的问题，如果想在发生 `http.Error` 后让 HTTP 处理函数停止，那么就不要忘记使用 `return` 语句来阻止后续代码的执行。\n\n### 直接使用默认的 HTTP client 和 server \n\n对于生产级别的应用，不要使用默认的 HTTP client 和 server 实现。这些实现缺少超时和生产环境中应该强制使用的行为。\n\n## 测试\n\n### 不对测试进行分类 （build tags, 环境变量，短模式）\n\n对测试进行必要的分类，可以借助 build tags、环境变量以及短模式，来使得测试过程更加高效。你可以使用 build tags 或环境变量来创建测试类别（例如单元测试与集成测试），并区分短测试与长时间测试，来决定执行哪种类型的。\n\n> ps: 了解下 go build tags，以及 `go test -short`。\n\n### 不打开 race 开关 \n\n打开 `-race` 开关在编写并发应用时非常重要。这能帮助你捕获可能的数据竞争，从而避免软件 bug。\n\n### 不打开测试的执行模式开关 (parallel 和 shuffle) \n\n打开开关 `-parallel` 有助于加速测试的执行，特别是测试中包含一些需要长期运行的用例的时候。\n\n打开开关 `-shuffle` 能够打乱测试用例执行的顺序，避免一个测试依赖于某些不符合真实情况的预设，有助于及早暴露 bug。\n\n### 不使用表驱动的测试 \n\n表驱动的测试是一种有效的方式，可以将一组相似的测试分组在一起，以避免代码重复和使未来的更新更容易处理。\n\n### 在单元测试中执行 sleep 操作 \n\n使用同步的方式、避免 sleep，来尽量减少测试的不稳定性和提高鲁棒性。如果无法使用同步手段,可以考虑重试的方式。\n\n### 没有高效地处理 time API \n\n理解如何处理使用 time API 的函数，是使测试更加稳定的另一种方式。您可以使用标准技术，例如将时间作为隐藏依赖项的一部分来处理，或者要求客户端提供时间。\n\n### 不使用测试相关的工具包 (`httptest` 和 `iotest`) \n\n这个 `httptest` 包对处理 HTTP 应用程序很有帮助。它提供了一组实用程序来测试客户端和服务器。\n\n这个 `iotest` 包有助于编写 io.Reader 并测试应用程序是否能够容忍错误。\n\n### 不正确的基准测试 \n\n- 不要重置或者暂停 timer\n\n使用 time 方法来保持基准测试的准确性。\n\n- 做出错误的微基准测试假设\n\n增加 `benchtime` 或者使用 `benchstat` 等工具可以有助于微基准测试。\n\n小心微基准测试的结果，如果最终运行应用程序的系统与运行微基准测试的系统不同。\n\n- 对编译期优化要足够小心\n\n确保测试函数是否会产生一些副作用，防止编译器优化欺骗你得到的基准测试结果。\n\n- 被观察者效应所欺骗\n\n为了避免被观察者效应欺骗，强制重新创建CPU密集型函数使用的数据。\n\n### 没有去探索 go test 所有的特性 \n\n- 代码覆盖率\n\n使用 `-coverprofile` 参数可以快速查看代码的测试覆盖情况，方便快速查看哪个部分需要更多的关注。\n\n- 在不同的包中执行测试\n\n单元测试组织到一个独立的包中，对于对外层暴露的接口，需要写一些测试用例。测试应该关注公开的行为，而非内部实现细节。\n\n- Utility 函数\n\n处理错误时，使用 `*testing.T` 变量而不是经典的 `if err != nil` 可以让代码更加简洁易读。\n\n- 设置和销毁\n\n你可以使用 setup 和 teardown 函数来配置一个复杂的环境，比如在集成测试的情况下。\n\n## 优化技术\n\n### 不理解 CPU cache \n\n- CPU 架构\n\n理解 CPU 缓存的使用对于优化 CPU 密集型应用很重要，因为 L1 缓存比主存快 50 到 100 倍。\n\n- Cache line\n\n意识到 cache line 概念对于理解如何在数据密集型应用中组织数据非常关键。CPU 并不是一个一个字来获取内存。相反，它通常复制一个 64 字节长度的 cache line。为了获得每个 cache line 的最大效用，需要实施空间局部性。\n\n- 一系列 struct 元素构成的 slice vs. 多个 slice 字段构成的 struct\n- 概率性的问题\n\n提高 CPU 执行代码时的可预测性，也是优化某些函数的一个有效方法。比如，固定步长或连续访问对 CPU 来说是可预测的，但非连续访问（例如链表）就是不可预测的。\n\n- cache 放置策略\n\n要注意现代缓存是分区的（set associative placement，组相连映射），要注意避免使用 `critical stride`，这种步长情况下只能利用 cache 的一小部分。\n\n> critical stride，这种类型的步长，指的是内存访问的步长刚好等于 cache 大小。这种情况下，只有少部分 cacheline 被利用。\n\n### 写的并发处理逻辑会导致 false sharing \n\n了解 CPU 缓存的较低层的 L1、L2 cache 不会在所有核间共享，编写并发处理逻辑时能避免写出一些降低性能的问题，比如伪共享（false sharing）。内存共享只是一种假象。\n\n### 没有考虑指令级的并行 \n\n使用指令级并行（ILP）优化代码的特定部分，以允许 CPU 尽可能执行更多可以并行执行的指令。识别指令的数据依赖问题（data hazards）是主要步骤之一。\n\n### 不了解数据对齐 \n\n记住 Go 中基本类型与其自身大小对齐，例如，按大小降序重新组织结构体的字段可以形成更紧凑的结构体（减少内存分配，更好的空间局部性），这有助于避免一些常见的错误。\n\n### 不了解 stack vs. heap \n\n了解堆和栈之间的区别是开发人员的核心知识点，特别是要去优化一个 Go 程序时。栈分配的开销几乎为零，而堆分配则较慢，并且依赖 GC 来清理内存。\n\n### 不知道如何减少内存分配次数（API 调整，编译器优化和 `sync.Pool`） \n\n减少内存分配次数也是优化 Go 应用的一个重要方面。这可以通过不同的方式来实现，比如仔细设计 API 来避免不必要的拷贝，以及使用 `sync.Pool` 来对分配对象进行池化。\n\n### 不注意使用内联 \n\n使用快速路径的内联技术来更加有效地减少调用函数的摊销时间。\n\n### 不使用 Go 问题诊断工具 \n\n了解 Go profiling 工具、执行时 tracer 来辅助判断一个应用程序是否正常，以及列出需要优化的部分。\n\n### 不理解 GC 是如何工作的 \n\n理解如何调优 GC 能够带来很多收益，例如有助于更高效地处理突增的负载。\n\n### 不了解 Docker 或者 K8S 对运行的 Go 应用的性能影响 \n\n为了避免 CPU throttling（CPU 限频）问题，当我们在 Docker 和 Kubernetes 部署应用时，要知道 Go 语言对 CFS（完全公平调度器）无感知。\n","tags":["Golang"],"categories":["golang"]},{"title":"一段shell获取mysql需监控信息","url":"/2024/10/16/data/mysql_monitor_sh/","content":"\n\n\n## mysql_monitor.sh\n\n~~~\n#!/bin/bash\n# 数据库主机的IP地址\nhost=\"127.0.0.1\"\n# MySQL的监听端口号，默认是3306\nport=\"3306\"\n# 数据库连接的用户名\nuserName=\"root\"\n# 用户名对应的密码，用于身份验证\npassword=\"123456\"\n# 要连接的数据库名称\ndbname=\"mysql\"\n# MySQL客户端工具的路径\nbase='/usr/bin/mysql'\n\n# 定义函数执行MySQL查询\nmysql_query() {\n    query=$1\n    $base -h$host -u$userName -p$password $dbname -P$port -e \"$query\" 2>/dev/null | awk 'NR==2 {print $2}'\n}\n\necho \"========= 基本配置信息 ===========\"\n\nlower_case_table_names_val=$(mysql_query \"show variables like 'lower_case_table_names';\")\necho \"不区分大小写：$lower_case_table_names_val\"\n\n_port_val=$(mysql_query \"show variables like 'port';\")\necho \"端口：$_port_val\"\n\nsocket_val=$(mysql_query \"show variables like 'socket';\")\necho \"socket的值：$socket_val\"\n\nskip_name_resolve_val=$(mysql_query \"show variables like 'skip_name_resolve';\")\necho \"域名解析skip_name_resolve：$skip_name_resolve_val\"\n\ncharacter_set_server_val=$(mysql_query \"show variables like 'character_set_server';\")\necho \"数据库字符集character_set_server：$character_set_server_val\"\n\ninteractive_timeout_val=$(mysql_query \"show variables like 'interactive_timeout';\")\necho \"交互式连接超时时间：$interactive_timeout_val 秒\"\n\nwait_timeout_val=$(mysql_query \"show variables like 'wait_timeout';\")\necho \"非交互式连接超时时间：$wait_timeout_val 秒\"\n\nquery_cache_type_val=$(mysql_query \"show variables like 'query_cache_type';\")\necho \"查询缓存query_cache_type：$query_cache_type_val\"\n\ninnodb_version_val=$(mysql_query \"show variables like 'innodb_version';\")\necho \"数据库版本：$innodb_version_val\"\n\ntrx_isolation_val=$(mysql_query \"show variables like 'tx_isolation';\")\necho \"隔离级别trx_isolation：$trx_isolation_val\"\n\ndatadir_val=$(mysql_query \"show variables like '%datadir%';\")\necho \"mysql 数据文件存放位置：$datadir_val\"\n\necho \"========= 连接数配置信息 ===========\"\n\nmax_connections_val=$(mysql_query \"show variables like 'max_connections';\")\necho \"最大连接数：$max_connections_val\"\n\nMax_used_connections_val=$(mysql_query \"show status like 'Max_used_connections';\")\necho \"当前连接数：$Max_used_connections_val\"\n\nmax_connect_errors_val=$(mysql_query \"show variables like 'max_connect_errors';\")\necho \"最大错误连接数：$max_connect_errors_val\"\n\necho \"========= binlog配置信息 ===========\"\n\nsync_binlog_val=$(mysql_query \"show variables like 'sync_binlog';\")\necho \"sync_binlog：$sync_binlog_val\"\n\nbinlog_format_val=$(mysql_query \"show variables like 'binlog_format';\")\necho \"binlog格式：$binlog_format_val\"\n\nlog_bin_val=$(mysql_query \"show variables like 'log-bin';\")\necho \"binlog文件：$log_bin_val\"\n\nexpire_logs_days_val=$(mysql_query \"show variables like 'expire_logs_days';\")\necho \"binlog文件过期时间：$expire_logs_days_val\"\n\necho \"========= GTID配置信息 ===========\"\n\ngtid_mode_val=$(mysql_query \"show variables like 'gtid_mode';\")\necho \"是否开启gtid_mode：$gtid_mode_val\"\n\nenforce_gtid_consistency_val=$(mysql_query \"show variables like 'enforce_gtid_consistency';\")\necho \"enforce_gtid_consistency是否开启：$enforce_gtid_consistency_val\"\n\nlog_slave_updates_val=$(mysql_query \"show variables like 'log_slave_updates';\")\necho \"级联复制是否开启log_slave_updates：$log_slave_updates_val\"\n\necho \"======== InnoDB配置信息 =========\"\n\ninnodb_buffer_pool_size_val=$(mysql_query \"show variables like 'innodb_buffer_pool_size';\")\necho \"innodb_buffer_pool_size：$innodb_buffer_pool_size_val\"\n\ninnodb_log_file_size_val=$(mysql_query \"show variables like 'innodb_log_file_size';\")\necho \"innodb_log_file_size：$innodb_log_file_size_val\"\n\ninnodb_flush_log_at_trx_commit_val=$(mysql_query \"show variables like 'innodb_flush_log_at_trx_commit';\")\necho \"innodb_flush_log_at_trx_commit：$innodb_flush_log_at_trx_commit_val\"\n\ninnodb_io_capacity_val=$(mysql_query \"show variables like 'innodb_io_capacity';\")\necho \"innodb_io_capacity：$innodb_io_capacity_val\"\n\n# 新增监控指标\necho \"================= 监控指标 ===============================\"\n\n# 监控内存使用情况\ninnodb_buffer_pool_size_mb=$(($innodb_buffer_pool_size_val / 1024 / 1024))\necho \"InnoDB 数据和索引缓存：$innodb_buffer_pool_size_mb MB\"\n\n# 查询缓存命中率\nquery_cache_hits=$(mysql_query \"show status like 'Qcache_hits';\")\necho \"查询缓存命中次数：$query_cache_hits\"\n\nquery_cache_inserts=$(mysql_query \"show status like 'Qcache_inserts';\")\necho \"查询缓存插入次数：$query_cache_inserts\"\n\n# 监控线程使用情况\nthreads_connected=$(mysql_query \"show status like 'Threads_connected';\")\necho \"当前连接线程数：$threads_connected\"\n\nthreads_running=$(mysql_query \"show status like 'Threads_running';\")\necho \"当前运行线程数：$threads_running\"\n\nthreads_created=$(mysql_query \"show status like 'Threads_created';\")\necho \"创建的线程数：$threads_created\"\n\nthreads_cached=$(mysql_query \"show status like 'Threads_cached';\")\necho \"缓存的线程数：$threads_cached\"\n\n# 慢查询日志\nslow_queries=$(mysql_query \"show status like 'Slow_queries';\")\necho \"慢查询次数：$slow_queries\"\n\n# InnoDB 相关性能指标\ninnodb_rows_read=$(mysql_query \"show status like 'Innodb_rows_read';\")\necho \"InnoDB 读取的行数：$innodb_rows_read\"\n\ninnodb_rows_inserted=$(mysql_query \"show status like 'Innodb_rows_inserted';\")\necho \"InnoDB 插入的行数：$innodb_rows_inserted\"\n\ninnodb_rows_updated=$(mysql_query \"show status like 'Innodb_rows_updated';\")\necho \"InnoDB 更新的行数：$innodb_rows_updated\"\n\ninnodb_rows_deleted=$(mysql_query \"show status like 'Innodb_rows_deleted';\")\necho \"InnoDB 删除的行数：$innodb_rows_deleted\"\n~~~\n\n## 运行结果\n\n~~~\n========= 基本配置信息 ===========\n不区分大小写：0\n端口：3306\nsocket的值：/var/run/mysqld/mysqld.sock\n域名解析skip_name_resolve：ON\n数据库字符集character_set_server：latin1\n交互式连接超时时间：28800 秒\n非交互式连接超时时间：28800 秒\n查询缓存query_cache_type：OFF\n数据库版本：5.7.44\n隔离级别trx_isolation：REPEATABLE-READ\nmysql 数据文件存放位置：/var/lib/mysql/\n========= 连接数配置信息 ===========\n最大连接数：500\n当前连接数：31\n最大错误连接数：100\n========= binlog配置信息 ===========\nsync_binlog：1\nbinlog格式：MIXED\nbinlog文件：\nbinlog文件过期时间：10\n========= GTID配置信息 ===========\n是否开启gtid_mode：OFF\nenforce_gtid_consistency是否开启：OFF\n级联复制是否开启log_slave_updates：OFF\n======== InnoDB配置信息 =========\ninnodb_buffer_pool_size：268435456\ninnodb_log_file_size：134217728\ninnodb_flush_log_at_trx_commit：1\ninnodb_io_capacity：200\n================= 监控指标 ===============================\nInnoDB 数据和索引缓存：256 MB\n查询缓存命中次数：0\n查询缓存插入次数：0\n当前连接线程数：22\n当前运行线程数：1\n创建的线程数：31\n缓存的线程数：9\n慢查询次数：0\nInnoDB 读取的行数：16824795\nInnoDB 插入的行数：63983\nInnoDB 更新的行数：130420\nInnoDB 删除的行数：919\n~~~\n\n","tags":["mysql","监控","sh"],"categories":["运维"]},{"title":"gitea在ubuntu安装","url":"/2024/07/18/git/gitea-install/","content":"\n#### 创建用户和用户组\n\n~~~\nsudo adduser --system --group --disabled-password --shell /bin/bash --home /home/git --gecos 'git version control' git\n~~~\n\n## 下载\n\n~~~\nwget -O /tmp/gitea https://dl.gitea.io/gitea/1.22.1/gitea-1.22.1-linux-amd64\n\nsudo mv /tmp/gitea /usr/local/bin\n\nsudo chmod +x /usr/local/bin/gitea\n\nsudo mkdir -p /var/lib/gitea/{custom,data,indexers,public,log}\nsudo chown git:git /var/lib/gitea/{data,indexers,log}\nsudo chmod 750 /var/lib/gitea/{data,indexers,log}\nsudo mkdir /etc/gitea\nsudo chown git:git /etc/gitea\nsudo chmod 770 /etc/gitea\n~~~\n\n## 创建Systemd 服务\n\n~~~\nwget https://cdn.jsdelivr.net/gh/go-gitea/gitea@main/contrib/systemd/gitea.service -P /etc/systemd/system/\n\n\nsudo systemctl daemon-reload\nsudo systemctl start gitea\nsudo systemctl enable gitea\nsudo systemctl status gitea\n~~~\n\n## 云服务商配置\n\n安全组放通3000端口\n\n## 可视化安装\n\nhttp://ip:3000\n\n## nginx代理\n\n~~~\nserver {\n    listen 80;\n    server_name gitea.zhiqiang.wang;\n    proxy_read_timeout 720s;\n    proxy_connect_timeout 720s;\n    proxy_send_timeout 720s;\n    client_max_body_size 50m;\n    \n    ssl_certificate    /etc/nginx/ssl/gitea.zhiqiang.wang.cer;\n    ssl_certificate_key   /etc/nginx/ssl/gitea.zhiqiang.wang.key;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    # Proxy headers\n    proxy_set_header X-Forwarded-Host $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    proxy_set_header X-Real-IP $remote_addr;\n    # log files\n    access_log /var/log/nginx/gitea.zhiqiang.wang.access.log;\n    error_log /var/log/nginx/gitea.zhiqiang.wang.error.log;\n    # Handle / requests\n    location / {\n       proxy_redirect off;\n       proxy_pass http://127.0.0.1:3000;\n    }\n}\n~~~\n\n> 白嫖SSL：https://github.com/acmesh-official/acme.sh.git\n\n## 编辑配置`/etc/gitea/app.ini`\n\n~~~\n[server]\nDOMAIN           = gitea.zhiqiang.wang\nROOT_URL         = https://gitea.zhiqiang.wang/\n~~~\n\n## 重启gitea\n\n~~~\nsudo systemctl restart gitea\n~~~\n\n","tags":["git","gitea"],"categories":["运维"]},{"title":"兆字节和兆比特","url":"/2024/07/14/data/basic-unit-data-size/","content":"\n## 数据尺寸的基本单位\n\n在计算机科学中，**位（Bit）** 是最基本的数据尺寸单位，它只有两种可能的状态：`0` 或者 `1`。然而，位对于描述大规模数据来说过于微小，因此我们通常使用更大的单位——**字节（Byte）**，`1` 字节等于 `8` 位。\n\n**字节** 是计算机存储和处理数据的基础。例如，一个 ASCII 字符（包括大部分的拉丁字母，数字和符号）通常使用一个字节来存储。\n\n## 数据尺寸的常用单位\n\n当我们谈论更大的数据尺寸时，我们通常使用字节的倍数单位来描述：\n\n- 千字节（KB - KiloByte）：1KB 等于 1024 字节。KB 是文档、小图片或者简短音频文件的常用度量单位。\n- 兆字节（MB - MegaByte）：1MB 等于 1024KB 或者 1,048,576 字节。MB 是高质量图片、MP3 音频文件或者文本电子书的常用度量单位。\n- 吉字节（GB - GigaByte）：1GB 等于 1024MB，或者 1,073,741,824 字节。GB 是大型视频文件、电影或者复杂软件应用的常用度量单位。\n- 太字节（TB - TeraByte）：1TB 等于 1024GB，或者 1,099,511,627,776 字节。TB 是大型数据库、高清电影合集或者大规模云存储的常用度量单位。\n- 拍字节（PB，PetaByte）：1PB 等于 1024TB。\n- 艾字节（EB，ExaByte）：1EB 等于 1024PB。这个单位在互联网公司中被使用，用于描述他们存储和处理的海量数据。\n- 泽字节（ZB，ZettaByte）：1ZB 等于 1024 ZB。\n- 尧字节（YB，YottaByte）：1YB 等于 1024 ZB。\n\n## 数据尺寸的实际影响\n\n数据尺寸的大小对于存储、处理和传输数据都有直接的影响：\n\n- 存储：存储空间是有限的。如果你的数据尺寸超过了你的存储容量，你将无法保存更多的数据。此外，大尺寸的数据文件还会使得备份和恢复数据更加困难。\n- 处理：数据的尺寸大小直接影响了数据处理的时间。例如，排序一个包含百万条记录的数据集一般会比排序一个包含千条记录的数据集要慢很多。\n- 传输：如果你需要通过网络发送或者接收数据，那么数据的尺寸大小将直接决定了传输的时间。大尺寸的数据文件可能需要很长时间才能完成上传或者下载。\n\n理解数据尺寸的大小及其影响是使用计算机和网络的基本技能。通过合理地管理和处理数据，我们可以提高存储效率，优化数据处理过程，以及提高数据传输的速度。无论你是一名程序员、数据科学家，还是普通的电脑用户，都需要对数据尺寸有一个基本的理解。\n\n## 1MB 与 1Mb 区别\n\n- 1MB（Megabyte）：表示数据容量等于 1,048,576 或 2^20 字节，也就是兆字节。注意这里的 **`B`** 是大写的，它表示 `Byte`，也就是字节。这个单位通常用于表示文件大小，存储空间等数据容量。\n- 1Mb（Megabit）：表示网络速度等于 1Mb/s，也就是兆比特。注意这里的 **`b`** 是小写的，它表示 `bit`，也就是比特，而不是 `Byte` 字节。1Mb 的网络速度意味着在每秒钟，网络可以传输 1,000,000 比特的数据。这个单位通常用于表示网络带宽、下载速度等。\n\n由于 1 字节等于 8 比特，因此 1MB 等于 8Mb。换句话说，如果你的网络速度是 1Mb/s，那么在理想状态下（忽略了网络延迟、丢包等问题），你每秒可以下载 0.125MB（1Mb/8bit） 的数据。相当于你要下载一个 1MB 的文件，那么在 1Mb/s 的网络速度下，理想状态下你需要大约 8 秒才能下载完。\n","tags":["数据单位","单位换算"],"categories":["data"]},{"title":"使用`maatwebsite/excel`进行表格操作","url":"/2024/07/10/php/maatwebsite-excel/","content":"\n# 安装\n\n~~~\ncomposer require maatwebsite/excel ^3.1\n~~~\n\n# 导出\n\n1. 定义导出类\n\n~~~\nuse App\\Exports\\Sheets\\TeamRegistration\\Enterprise;\nuse App\\Exports\\Sheets\\TeamRegistration\\School;\nuse Maatwebsite\\Excel\\Concerns\\Exportable;\nuse Maatwebsite\\Excel\\Concerns\\WithMultipleSheets;\n\nclass TestSheets implements WithMultipleSheets\n{\n    use Exportable;\n\n    public function sheets(): array\n    {\n        $sheets = [];\n        //Sheet1\n        $sheets[] = new Sheet1();\n        //Sheet2\n\t\t\t\t//$sheets[] = new Sheet1();\n        return $sheets;\n    }\n}\n~~~\n\n2. 定义第1个sheets\n\n~~~\nuse Maatwebsite\\Excel\\Concerns\\FromArray;\nuse Maatwebsite\\Excel\\Concerns\\WithHeadings;\nuse Maatwebsite\\Excel\\Concerns\\WithTitle;\n\nclass Sheet1 implements FromArray, WithHeadings, WithTitle\n{\n    public function array(): array\n    {\n        $list[0]['h1'] = 'h11';\n        $list[0]['h2'] = 'h22';\n        $list[0]['h3'] = 'h33';\n        return  $list;\n    }\n    public function headings(): array\n    {\n        return  [\"h1\",\"h2\",\"h3\"];\n    }\n\n    public function title(): string\n    {\n        return \"sheet1\";\n    }\n}\n~~~\n\n3. 使用\n\n~~~\n return (new TestSheets())->download(\"test-name.xlsx\");\n~~~\n\n","tags":["excel"],"categories":["php"]},{"title":"将laravel中hash加密方式在go中怎么实现","url":"/2024/07/10/algorithm/laravel-hash-go/","content":"\n我们经常使用laravel中的hash进行对数据进行加密，下面我们将laravel中的方法转变成go中的方法\n\n驱动使用默认的 `bcrypt`\n\n## 生成\n\n~~~\n\\Illuminate\\Support\\Facades\\Hash::make(\"123456\")\n会产生随机字符串并不是固定值\n// $2y$10$ozKiyZy7eudP64XhJHqSfu1PkviK0Ahg2348iX0cDDUKnw9r8pwLO\n\n// $2y$10$VH1VZUo32vNzm1AsoU0qXO14hkp61O1TfL9M1wDiWXOg1QPoisnbO\n~~~\n\n在看看go怎么实现\n\n~~~\nhashedValue, _ := bcrypt.GenerateFromPassword([]byte(\"123456\"), bcrypt.DefaultCost)\nfmt.Print(string(hashedValue))\n\n// $2a$10$2W9wylmq3GaxUQBfdfCTYeJitxJfRuz6xJKRD2A/L/Zs8BUriiJJS\n// $2a$10$kKAS.WmPwLBAKLQQifEx6.LIlgHBEHzAa.oaMV/UuMcmwRNdENEU2\n~~~\n\n## 验证\n\n~~~\n\\Illuminate\\Support\\Facades\\Hash::check(\"123456\",'$2y$10$ozKiyZy7eudP64XhJHqSfu1PkviK0Ahg2348iX0cDDUKnw9r8pwLO')\n// true\n\\Illuminate\\Support\\Facades\\Hash::check(\"123456\",'$2y$10$VH1VZUo32vNzm1AsoU0qXO14hkp61O1TfL9M1wDiWXOg1QPoisnbO')\n// true\n\n\\Illuminate\\Support\\Facades\\Hash::check(\"123456\",'$2a$10$2W9wylmq3GaxUQBfdfCTYeJitxJfRuz6xJKRD2A/L/Zs8BUriiJJS')\n// true\n\\Illuminate\\Support\\Facades\\Hash::check(\"123456\",'$2a$10$kKAS.WmPwLBAKLQQifEx6.LIlgHBEHzAa.oaMV/UuMcmwRNdENEU2')\n// true\n~~~\n\n在看看go怎么实现\n\n~~~\nvar err error\nerr = bcrypt.CompareHashAndPassword([]byte(\"$2y$10$ozKiyZy7eudP64XhJHqSfu1PkviK0Ahg2348iX0cDDUKnw9r8pwLO\"), []byte(\"123456\"))\nfmt.Println(err)\n// nil\nerr = bcrypt.CompareHashAndPassword([]byte(\"$2y$10$VH1VZUo32vNzm1AsoU0qXO14hkp61O1TfL9M1wDiWXOg1QPoisnbO\"), []byte(\"123456\"))\nfmt.Println(err)\n// nil\nerr = bcrypt.CompareHashAndPassword([]byte(\"$2a$10$2W9wylmq3GaxUQBfdfCTYeJitxJfRuz6xJKRD2A/L/Zs8BUriiJJS\"), []byte(\"123456\"))\nfmt.Println(err)\n// nil\nerr = bcrypt.CompareHashAndPassword([]byte(\"$2a$10$kKAS.WmPwLBAKLQQifEx6.LIlgHBEHzAa.oaMV/UuMcmwRNdENEU2\"), []byte(\"123456\"))\nfmt.Println(err)\n// nil\n~~~\n\n> 为nil 相当于就是true\n\n","tags":["php","laravel","go","hash"],"categories":["algorithm"]},{"title":"Linux 统计Web服务日志命令","url":"/2024/07/06/soft/liunx-log-stat/","content":"\n### Apache日志统计\n\n~~~\n# 列出当天访问次数最多的IP命令\nroot@zhiqiang.wang:~# # cut -d- -f 1 access.log | uniq -c | sort -rn | head -20\n\n# 查看当天有多少个IP访问\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort | uniq | wc -l\n\n# 查看某一个页面总计被访问的次数\nroot@zhiqiang.wang:~# # cat access.log | grep \"index.php\" | wc -l\n\n# 查看每一个IP访问了多少个页面\nroot@zhiqiang.wang:~# # awk '{++S[$1]} END {for (a in S) print a,S[a]}' access.log\n\n# 将每个IP访问的页面数进行从小到大排序\nroot@zhiqiang.wang:~# # awk '{++S[$1]} END {for (a in S) print S[a],a}' access.log | sort -n\n\n# 查看某一个IP访问了哪些页面\nroot@zhiqiang.wang:~# # grep \"^192.168.1.2\" access.log | awk '{print $1,$7}'\n\n# 去掉搜索引擎统计当天的页面\nroot@zhiqiang.wang:~# # awk '{print $12,$1}' access.log | grep ^\"Mozilla\" | awk '{print $2}' |sort | uniq | wc -l\n\n# 查看21/Nov/2019:03:40:26这一个小时内有多少IP访问\nroot@zhiqiang.wang:~# # awk '{print $4,$1}' access.log | grep \"21/Nov/2019:03:40:26\" | awk '{print $2}'| sort | uniq | wc -l\n~~~\n\n### Nginx 日志统计\n\n~~~\n\n# 列出所有的IP访问情况\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort -n | uniq\n\n# 查看访问最频繁的前100个IP\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort -n | uniq -c | sort -rn | head -n 100\n\n# 查看访问100次以上的IP\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort -n | uniq -c | awk '{if($1 >100) print $0}' | sort -rn\n\n# 查询某个IP的详细访问情况,按访问频率排序\nroot@zhiqiang.wang:~# # grep '192.168.1.2' access.log | awk '{print $7}' | sort | uniq -c | sort -rn | head -n 100\n\n# 页面访问统计：查看访问最频繁的前100个页面\nroot@zhiqiang.wang:~# # awk '{print $7}' access.log | sort | uniq -c | sort -rn | head -n 100\n\n# 页面访问统计：查看访问最频繁的前100个页面(排除php|py)\nroot@zhiqiang.wang:~# # grep -E -v \".php|.py\"  access.log | awk '{print $7}' | sort |uniq -c | sort -rn | head -n 100\n\n# 页面访问统计：查看页面访问次数超过100次的页面\nroot@zhiqiang.wang:~# # cat access.log | cut -d ' ' -f 7 | sort |uniq -c | awk '{if ($1 > 100) print$0}'\n\n# 页面访问统计：查看最近1000条记录中,访问量最高的页面\nroot@zhiqiang.wang:~# # tail -1000 access.log | awk '{print $7}' | sort | uniq -c | sort -nr\n\n# 每秒请求量统计：统计每秒的请求数前100的时间点(精确到秒)\nroot@zhiqiang.wang:~# # awk '{print $4}' access.log | cut -c14-21 | sort | uniq -c | sort -nr | head -n 100\n\n# 每分钟请求量统计 11、统计每分钟的请求数,top100的时间点(精确到分钟)\nroot@zhiqiang.wang:~# # awk '{print $4}' access.log | cut -c14-18 | sort | uniq -c | sort -nr | head -n 100\n\n# 每小时请求量统计 12、统计每小时的请求数,top100的时间点(精确到小时)\nroot@zhiqiang.wang:~# # awk '{print $4}' access.log | cut -c14-15 | sort | uniq -c | sort -nr | head -n 100\n~~~\n\n### 统计Web服务状态\n\n~~~\n\n# 统计网站爬虫\nroot@zhiqiang.wang:~# # grep -E 'Googlebot|Baiduspider' access.log | awk '{ print $1 }' | sort | uniq\n\n# 统计网站中浏览器的访问情况\nroot@zhiqiang.wang:~# # cat access.log | grep -v -E 'MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon' | sort | uniq -c | sort -r -n | head -n 100\n\n# 统计网段分布情况\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $1}' | awk -F'.' '{print $1\".\"$2\".\"$3\".0\"}' | sort | uniq -c | sort -r -n | head -n 200\n\n# 统计来访域名\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $2}' | sort | uniq -c | sort -rn | more\n\n# 统计HTTP状态\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $9}' | sort | uniq -c | sort -rn | more\n\n# URL访问次数统计\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $7}' | sort | uniq -c | sort -rn | more\n\n# URL访问流量统计\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $7}' | egrep '?|&' | sort | uniq -c | sort -rn | more\n\n# 文件流量统计\nroot@zhiqiang.wang:~# # cat access.log | awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}' | \\\nsort -rn | more | grep '200' access.log | \\\nawk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}' | sort -rn | more\n~~~\n\n### 其他统计组合\n\n~~~\n\n# 列出当天访问次数最多的IP命令\nroot@zhiqiang.wang:~# # cut -d- -f 1 access.log | uniq -c | sort -rn | head -20\n\n# 查看当天有多少个IP访问\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort | uniq | wc -l\n\n# 查看某一个页面总计被访问的次数\nroot@zhiqiang.wang:~# # cat access.log | grep \"index.php\" | wc -l\n\n# 查看每一个IP访问了多少个页面\nroot@zhiqiang.wang:~# # awk '{++S[$1]} END {for (a in S) print a,S[a]}' access.log\n\n# 将每个IP访问的页面数进行从小到大排序\nroot@zhiqiang.wang:~# # awk '{++S[$1]} END {for (a in S) print S[a],a}' access.log | sort -n\n\n# 查看某一个IP访问了哪些页面\nroot@zhiqiang.wang:~# # grep \"^192.168.1.2\" access.log | awk '{print $1,$7}'\n\n# 去掉搜索引擎统计当天的页面\nroot@zhiqiang.wang:~# # awk '{print $12,$1}' access.log | grep ^\"Mozilla\" | awk '{print $2}' |sort | uniq | wc -l\n\n# 查看21/Nov/2019:03:40:26这一个小时内有多少IP访问\nroot@zhiqiang.wang:~# # awk '{print $4,$1}' access.log | grep \"21/Nov/2019:03:40:26\" | awk '{print $2}'| sort | uniq | wc -l\nNginx日志统计：\n\n# 列出所有的IP访问情况\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort -n | uniq\n\n# 查看访问最频繁的前100个IP\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort -n | uniq -c | sort -rn | head -n 100\n\n# 查看访问100次以上的IP\nroot@zhiqiang.wang:~# # awk '{print $1}' access.log | sort -n | uniq -c | awk '{if($1 >100) print $0}' | sort -rn\n\n# 查询某个IP的详细访问情况,按访问频率排序\nroot@zhiqiang.wang:~# # grep '192.168.1.2' access.log | awk '{print $7}' | sort | uniq -c | sort -rn | head -n 100\n\n# 页面访问统计：查看访问最频繁的前100个页面\nroot@zhiqiang.wang:~# # awk '{print $7}' access.log | sort | uniq -c | sort -rn | head -n 100\n\n# 页面访问统计：查看访问最频繁的前100个页面(排除php|py)\nroot@zhiqiang.wang:~# # grep -E -v \".php|.py\"  access.log | awk '{print $7}' | sort |uniq -c | sort -rn | head -n 100\n\n# 页面访问统计：查看页面访问次数超过100次的页面\nroot@zhiqiang.wang:~# # cat access.log | cut -d ' ' -f 7 | sort |uniq -c | awk '{if ($1 > 100) print$0}'\n\n# 页面访问统计：查看最近1000条记录中,访问量最高的页面\nroot@zhiqiang.wang:~# # tail -1000 access.log | awk '{print $7}' | sort | uniq -c | sort -nr\n\n# 每秒请求量统计：统计每秒的请求数前100的时间点(精确到秒)\nroot@zhiqiang.wang:~# # awk '{print $4}' access.log | cut -c14-21 | sort | uniq -c | sort -nr | head -n 100\n\n# 每分钟请求量统计 11、统计每分钟的请求数,top100的时间点(精确到分钟)\nroot@zhiqiang.wang:~# # awk '{print $4}' access.log | cut -c14-18 | sort | uniq -c | sort -nr | head -n 100\n\n# 每小时请求量统计 12、统计每小时的请求数,top100的时间点(精确到小时)\nroot@zhiqiang.wang:~# # awk '{print $4}' access.log | cut -c14-15 | sort | uniq -c | sort -nr | head -n 100\n统计其他页面数据:\n\n# 统计网站爬虫\nroot@zhiqiang.wang:~# # grep -E 'Googlebot|Baiduspider' access.log | awk '{ print $1 }' | sort | uniq\n\n# 统计网站中浏览器的访问情况\nroot@zhiqiang.wang:~# # cat access.log | grep -v -E 'MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon' | sort | uniq -c | sort -r -n | head -n 100\n\n# 统计网段分布情况\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $1}' | awk -F'.' '{print $1\".\"$2\".\"$3\".0\"}' | sort | uniq -c | sort -r -n | head -n 200\n\n# 统计来访域名\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $2}' | sort | uniq -c | sort -rn | more\n\n# 统计HTTP状态\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $9}' | sort | uniq -c | sort -rn | more\n\n# URL访问次数统计\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $7}' | sort | uniq -c | sort -rn | more\n\n# URL访问流量统计\nroot@zhiqiang.wang:~# # cat access.log | awk '{print $7}' | egrep '?|&' | sort | uniq -c | sort -rn | more\n\n# 文件流量统计\nroot@zhiqiang.wang:~# # cat access.log | awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}' | \\\nsort -rn | more | grep '200' access.log | \\\nawk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}' | sort -rn | more\n~~~\n\n### 次数统计\n\n~~~\n查看某一个页面被访问的次数\nroot@zhiqiang.wang:~# # grep \"/index.php\" log_file | wc -l\n\n查看每一个IP访问了多少个页面\nroot@zhiqiang.wang:~# # awk '{++S[$1]} END {for (a in S) print a,S[a]}' log_file\n\n将每个IP访问的页面数进行从小到大排序\nroot@zhiqiang.wang:~# # awk '{++S[$1]} END {for (a in S) print S[a],a}' log_file | sort -n\n\n查看某一个IP访问了哪些页面\nroot@zhiqiang.wang:~# # grep ^111.111.111.111 log_file| awk '{print $1,$7}'\n\n去掉搜索引擎统计当天的页面\nroot@zhiqiang.wang:~# # awk '{print $12,$1}' log_file | grep ^\"Mozilla | awk '{print $2}' |sort | uniq | wc -l\n\n查看2018年6月21日14时这一个小时内有多少IP访问\nroot@zhiqiang.wang:~# # awk '{print $4,$1}' log_file | grep 21/Jun/2018:14 | awk '{print $2}'| sort | uniq | wc -l\n\n统计爬虫\nroot@zhiqiang.wang:~# # grep -E 'Googlebot|Baiduspider'  /www/logs/access.log | awk '{ print $1 }' | sort | uniq\n\n统计浏览器\nroot@zhiqiang.wang:~# # cat /www/logs/access.log | grep -v -E 'MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon' | sort | uniq -c | sort -r -n | head -n 100\n\nIP 统计\nroot@zhiqiang.wang:~# # grep '23/May/2019' /www/logs/access.log | awk '{print $1}' | awk -F'.' '{print $1\".\"$2\".\"$3\".\"$4}' | sort | uniq -c | sort -r -n | head -n 10   2206 219.136.134.13   1497 182.34.15.248   1431 211.140.143.100   1431 119.145.149.106   1427 61.183.15.179   1427 218.6.8.189   1422 124.232.150.171   1421 106.187.47.224   1420 61.160.220.252   1418 114.80.201.18\n\n统计网段\nroot@zhiqiang.wang:~# # cat /www/logs/access.log | awk '{print $1}' | awk -F'.' '{print $1\".\"$2\".\"$3\".0\"}' | sort | uniq -c | sort -r -n | head -n 200\n\n统计域名\nroot@zhiqiang.wang:~# # cat  /www/logs/access.log |awk '{print $2}'|sort|uniq -c|sort -rn|more\n\nHTTP状态\nroot@zhiqiang.wang:~# # cat  /www/logs/access.log |awk '{print $9}'|sort|uniq -c|sort -rn|more5056585 3041125579 200   7602 400      5 301\n\nURL 统计\nroot@zhiqiang.wang:~# # cat  /www/logs/access.log |awk '{print $7}'|sort|uniq -c|sort -rn|more\n\n文件流量统计\nroot@zhiqiang.wang:~# # cat /www/logs/access.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|moregrep ' 200 ' /www/logs/access.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more\n\nURL访问量统计\nroot@zhiqiang.wang:~# # cat /www/logs/access.log | awk '{print $7}' | egrep '?|&' | sort | uniq -c | sort -rn | more\n\n查出运行速度最慢的脚本\nroot@zhiqiang.wang:~# # grep -v 0$ /www/logs/access.log | awk -F '\" ' '{print $4\" \" $1}' web.log | awk '{print $1\" \"$8}' | sort -n -k 1 -r | uniq > /tmp/slow_url.txt\n\nIP, URL 抽取\nroot@zhiqiang.wang:~# # tail -f /www/logs/access.log | grep '/test.html' | awk '{print $1\" \"$7}'\n~~~\n","tags":["nginx","log","Apache"],"categories":["运维"]},{"title":"在mac系统安装swoole扩展","url":"/2024/05/23/php/mac-install-swoole/","content":"\n## 安装准备\n\n安装前必须保证系统已经安装了下列软件\n\n- `php-7.2` 或更高版本\n- `gcc-4.8` 或更高版本\n- `make`\n- `autoconf`\n\n```text\nbrew install gcc\nbrew install make\nbrew install autoconf\n```\n\n## [快速安装](https://wiki.swoole.com/zh-cn/#/environment)\n\n1. #### 下载 swoole 源码\n\n- [https://github.com/swoole/swoole-src/releases](https://github.com/swoole/swoole-src/releases)\n- [https://pecl.php.net/package/swoole](https://pecl.php.net/package/swoole)\n- [https://gitee.com/swoole/swoole/tags](https://gitee.com/swoole/swoole/tags)\n\n2. #### 从源码编译安装\n\n下载源代码包后，在终端进入源码目录，执行下面的命令进行编译和安装\n\n```text\ncd swoole-src && \\\nphpize && \\\n./configure && \\\nmake && sudo make install\n```\n\n带上参数编译安装\n\n[Swoole文档](https://wiki.swoole.com/zh-cn/#/)\n\n```text\nwget https://github.com/swoole/swoole-src/archive/refs/tags/v4.8.13.tar.gz\ntar -xf v4.8.13.tar.gz\ncd swoole-src-4.8.13\nphpize\n./configure -enable-sockets=yes --enable-openssl=yes --enable-http2=yes --enable-mysqlnd=yes --enable-swoole-json=yes --enable-swoole-curl=yes\nmake && sudo make install\n```\n\n> 1. 'pcre2.h' file not found\n>\n> ~~~\n> ln -s /opt/homebrew/opt/pcre2/include/pcre2.h /opt/homebrew/opt/php@7.4/include/php/ext/pcre/\n> ~~~\n>\n> 2.  'openssl/ssl.h' file not found\n>\n> ~~~\n> 查看安装目录\n> % brew --prefix openssl\n> \n> ./configure \\\n>     -enable-sockets=yes \\\n>     --enable-openssl=yes \\\n>     --enable-http2=yes \\\n>     --enable-mysqlnd=yes \\\n>     --enable-swoole-json=yes \\\n>     --enable-swoole-curl=yes \\\n>     --with-openssl-dir=/opt/homebrew/opt/openssl@3 \\\n> ~~~\n\n## [PECL](https://pecl.php.net/package/swoole)\n\n> 注意: PECL 发布时间晚于 GitHub 发布时间\n\nSwoole 项目已收录到 PHP 官方扩展库，除了手动下载编译外，还可以通过 PHP 官方提供的 `pecl` 命令，一键下载安装\n\n```text\npecl install swoole\n```\n\n通过 PECL 安装 Swoole 时，在安装过程中它会询问是否要启用某些功能，这也可以在运行安装之前提供，例如：\n\n```text\npecl install -D 'enable-sockets=\"no\" enable-openssl=\"yes\" enable-http2=\"yes\" enable-mysqlnd=\"yes\" enable-swoole-json=\"no\" enable-swoole-curl=\"yes\" enable-cares=\"yes\"' swoole\n\n#或\npecl install --configureoptions 'enable-sockets=\"no\" enable-openssl=\"yes\" enable-http2=\"yes\" enable-mysqlnd=\"yes\" enable-swoole-json=\"no\" enable-swoole-curl=\"yes\" enable-cares=\"yes\"' swoole\n```\n\n## 加载swoole扩展\n\n~~~\n//查找php.ini配置文件位置\nphp -i| grep php.ini\n//编辑配置\nvi /usr/local/etc/php/7.4/php.ini\n//最后添加\nextension=swoole\n~~~\n\n","tags":["php","swoole"],"categories":["php"]},{"title":"Spring Boot如何优雅实现结果统一封装和异常统一处理","url":"/2024/04/29/java/springboot-unified-response/","content":"\nLombok（Project Lombok）是一个用于 Java 编程语言的开源库，旨在减少 Java 代码中的冗余和样板代码，提高开发人员的生产力。它通过使用注解来自动生成 Java 类的常见方法和代码，从而使开发人员能够编写更简洁、更具可读性和更易维护的代码。Lombok 的主要目标是简化 Java 开发，减少样板代码，使代码更加精炼，从而提高开发效率。\n\n它利用注解方式自动生成 java bean 中 getter、setter、equals 等方法，还能自动生成 logger、toString、hashCode、builder 等 日志相关变量、Object 类方法或设计模式相关的方法，能够让你的 代码更简洁，更美观。\n\n> https://github.com/projectlombok/lombok\n>\n> https://projectlombok.org/\n\n## 依赖下载\n\n~~~\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.16.22</version>\n</dependency>\n~~~\n\n> 使用以下方式注意代码目录，并把需要的包进行导入\n\n## 定义返回统一结构体`ResponseVO`\n\n~~~\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport java.io.Serializable;\n\n@Data\n@AllArgsConstructor\npublic class ResponseVO<T> implements Serializable {\n    private Integer code;\n    private String Message;\n    private T data;\n    public ResponseVO(Integer code, String message) {\n        this.code = code;\n        this.Message = message;\n    }\n    public static <T> ResponseVO<T> success(T data) {\n        return new ResponseVO<>(0, \"success\", data);\n    }\n    public static <T> ResponseVO<T> error( String message) {\n        return new ResponseVO<>(1, message, null);\n    }\n}\n~~~\n\n## 定义一个注解`@ResponseResultBody`\n\n~~~\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n//可以标识类上也可以标识在方法上\n@Target({ElementType.TYPE, ElementType.METHOD})\n//运行时\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ResponseResultBody {\n}\n~~~\n\n## 实现统一结果封装`ResponseBodyAdvice`\n\n~~~\n\nimport org.springframework.core.MethodParameter;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.server.ServerHttpRequest;\nimport org.springframework.http.server.ServerHttpResponse;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\n@RestControllerAdvice\npublic class ResponseBodyAdvice implements org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice<Object> {\n    @Override\n    @SuppressWarnings(\"all\")\n    //是否支持advice功能\n    //true 支持，false 不支持\n    public boolean supports(MethodParameter methodParameter, Class<? extends HttpMessageConverter<?>> aClass) {\n        // 拿到类声明,判断是否被IgnoreResponseAdvice进行标识\n        if (methodParameter.getDeclaringClass().isAnnotationPresent(ResponseResultBody.class)) {\n            return false;\n        }\n        if (methodParameter.getMethod().isAnnotationPresent(ResponseResultBody.class)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    @SuppressWarnings(\"all\")\n    //对返回的数据进行处理\n    public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {\n        ResponseVO<Object> response = ResponseVO.success(\"\");\n        if (o == null) {\n            return response;\n        } else if (o instanceof ResponseVO) {\n            response = (ResponseVO<Object>) o;\n        } else {\n            response.setData(o);\n        }\n        return response;\n    }\n}\n~~~\n\n## 全局异常统一处理\n\n~~~\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.HttpRequestMethodNotSupportedException;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.MissingServletRequestParameterException;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;\nimport org.springframework.web.servlet.NoHandlerFoundException;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ControllerAdvice\n@Slf4j\npublic class ExceptionResponseHandler {\n    @ExceptionHandler(value = Exception.class)\n    public ResponseVO<String> handlerException(HttpServletRequest req, Exception e) {\n    \t\t//自定义异常\n        if (e instanceof BusinessException) {\n            BusinessException bizException = (BusinessException) e;\n            ResponseVO<String> response = ResponseVO.withCodeMessage(bizException.getCode(),bizException.getMessage());\n            response.setData(e.getMessage());\n            return response;\n        } else if (e instanceof MethodArgumentNotValidException) {\n            MethodArgumentNotValidException methodArgumentNotValidException = (MethodArgumentNotValidException) e;\n            Map<String, String> map = new HashMap<>();\n            BindingResult result = methodArgumentNotValidException.getBindingResult();\n            result.getFieldErrors().forEach((item) -> {\n                String message = item.getDefaultMessage();\n                String field = item.getField();\n                map.put(field, message);\n            });\n            log.error(\"数据校验出现错误：\", e);\n            return ResponseVO.error(map.toString());\n        } else if (e instanceof HttpRequestMethodNotSupportedException) {\n            return ResponseVO.error(\"请求方法不正确\");\n        } else if (e instanceof MissingServletRequestParameterException) {\n            log.error(\"请求参数缺失：\", e);\n            MissingServletRequestParameterException ex = (MissingServletRequestParameterException) e;\n            return ResponseVO.error(\"请求参数缺少: \" + ex.getParameterName());\n        } else if (e instanceof MethodArgumentTypeMismatchException) {\n            log.error(\"请求参数类型错误：\", e);\n            MethodArgumentTypeMismatchException ex = (MethodArgumentTypeMismatchException) e;\n            return ResponseVO.error(\"请求参数类型不正确：\" + ex.getName());\n        } else if (e instanceof NoHandlerFoundException) {\n            NoHandlerFoundException ex = (NoHandlerFoundException) e;\n            log.error(\"请求地址不存在：\", e);\n            return ResponseVO.error(ex.getRequestURL());\n        } else {\n            ResponseVO<String> response = ResponseVO.error(\"The server has run away\");\n            response.setData(e.getMessage());\n            return response;\n        }\n    }\n}\n\n~~~\n\n## 统一响应下划线配置\n\n~~~\nspring:\n  # 设置响应返回数据统一为下划线\n  jackson:\n    property-naming-strategy: SNAKE_CASE\n~~~\n\n","tags":["java","springboot"],"categories":["java"]},{"title":"使用kubeadm安装kubernetes","url":"/2024/04/27/k8s/kubeadm-install/","content":"\n### 永久修改主机名\n\n~~~\nhostnamectl set-hostname k8s-master\n~~~\n\n### 禁用swap\n\n#### 临时修改，重启后恢复\n\n~~~\nswapoff -a\n~~~\n\n#### 永久修改\n\n编辑配置文件 /etc/fstab 将swap进行注释\n\n#### 查看是否生效\n\n使用`free -g`命令，Swap 显示都为0表示修改成功了\n\n### 安装docker\n\n~~~\nroot@k8s-master:~# apt install -y docker.io\nroot@k8s-master:~# docker version\nClient:\n Version:           20.10.21\n API version:       1.41\n Go version:        go1.18.1\n Git commit:        20.10.21-0ubuntu1~18.04.3\n Built:             Thu Apr 27 05:50:21 2023\n OS/Arch:           linux/amd64\n Context:           default\n Experimental:      true\n\nServer:\n Engine:\n  Version:          20.10.21\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.18.1\n  Git commit:       20.10.21-0ubuntu1~18.04.3\n  Built:            Thu Apr 27 05:36:22 2023\n  OS/Arch:          linux/amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.12-0ubuntu1~18.04.1\n  GitCommit:        \n runc:\n  Version:          1.1.4-0ubuntu1~18.04.2\n  GitCommit:        \n docker-init:\n  Version:          0.19.0\n  GitCommit:   \n~~~\n\n#### 修改/etc/docker/daemon.json\n\n~~~\nroot@k8s-master:~# cat > /etc/docker/daemon.json << EOF\n{\n    \"registry-mirrors\":[\n        \"https://docker.mirrors.ustc.edu.cn\",\n        \"https://hub-mirror.c.163.com\"\n    ],\n    \"exec-opts\":[\n        \"native.cgroupdriver=systemd\"\n    ]\n}\nEOF\n~~~\n\n#### 重启docker\n\n~~~\nsystemctl daemon-reload\nsystemctl restart docker\n~~~\n\n## 必要组建安装\n\n~~~\n//从远程重新下载进行安装\nsudo sh install install_ubuntu_online.sh\n~~~\n\n~~~\n#!/bin/sh\n# https://v1-23.docs.kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n\n# 指定文件包路径\nK8S_PKG=${PWD}/pkg\n# 可执行文件路径\nDOWNLOAD_DIR=/usr/local/bin\n# cni可执行文件安装目录\nCNI_BIN_DIR=/opt/cni/bin\nARCH=\"amd64\"\n\n# 安装必要的组建\nsudo apt update\nsudo apt install -y conntrack  ebtables ntpdate socat \n\n# 允许 iptables 检查桥接流量\nsudo cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf\nbr_netfilter\nEOF\n\n# 允许 iptables 检查桥接流量\nsudo cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsudo sysctl --system\n\n# 时间同步\nsudo ntpdate time.windows.com\n\n# 安装CNI插件\nCNI_VERSION=\"v0.8.2\"\nsudo mkdir -p $CNI_BIN_DIR\nsudo curl -L \"https://github.com/containernetworking/plugins/releases/download/${CNI_VERSION}/cni-plugins-linux-${ARCH}-${CNI_VERSION}.tgz\" | sudo tar -C /opt/cni/bin -xz\n\n#  安装crictl\nCRICTL_VERSION=\"v1.22.0\"\nsudo curl -L \"https://github.com/kubernetes-sigs/cri-tools/releases/download/${CRICTL_VERSION}/crictl-${CRICTL_VERSION}-linux-${ARCH}.tar.gz\" | sudo tar -C $DOWNLOAD_DIR -xz\n\nRELEASE=\"v1.23.9\"\n# ELEASE=\"$(curl -sSL https://dl.k8s.io/release/stable.txt)\"\ncd  $DOWNLOAD_DIR &&  sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/${RELEASE}/bin/linux/${ARCH}/{kubeadm,kubelet,kubectl}\n\nsudo chmod +x kubeadm kubectl kubelet\n\nRELEASE_VERSION=\"v0.4.0\"\nsudo curl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /etc/systemd/system/kubelet.service\nsudo mkdir -p /etc/systemd/system/kubelet.service.d\nsudo curl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf\n\n# 设置kubelet开启自动自动\nsudo systemctl enable --now kubelet\n\n~~~\n\n### 加载配置文件启动一个集群\n\n#### 启动方式1\n\n~~~\n//指定配置项启动\nroot@k8s-master:~# kubeadm init --apiserver-advertise-address=0.0.0.0 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version 1.23.0 --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=all\n\n~~~\n\n#### 启动方式2\n\n~~~\n// 获取内网重新生成kubeadm-init.yaml\nroot@k8s-master:~# cat kubeadm-init-default.yaml | sed \"s/advertiseAddress:.*/advertiseAddress: $(ip addr show eth0 |grep \"inet \"|awk '{print $2}' | cut -d/ -f1)/\" > kubeadm-init.yaml\n\n//加载配置文件进行启动\nroot@k8s-master:~# kubeadm init --config  kubeadm-init.yaml  \n~~~\n\n配置信息\n\n> 生成默认的配置信息 kube-init.yaml\n>\n> kubeadm config print init-defaults > kubeadm-init-default.yaml\n>\n> 然后进行按照需求进行修改成以下的内容\n\n~~~\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n- groups:\n  - system:bootstrappers:kubeadm:default-node-token\n  token: abcdef.0123456789abcdef\n  ttl: 24h0m0s\n  usages:\n  - signing\n  - authentication\nkind: InitConfiguration\nlocalAPIEndpoint:\n\t#节点访问地址\n  advertiseAddress: 192.168.1.20\n  bindPort: 6443\nnodeRegistration:\n  criSocket: /var/run/dockershim.sock\n  imagePullPolicy: IfNotPresent\n  # 节点的名字\n  name: k8s-master\n  taints: null\n---\napiServer:\n  timeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io/v1beta3\ncertificatesDir: /etc/kubernetes/pki\nclusterName: kubernetes\ncontrollerManager: {}\ndns: {}\netcd:\n  local:\n    dataDir: /var/lib/etcd\n    #etcd访问地址\n    extraArgs:\n     listen-client-urls: \"https://127.0.0.1:2379,https://127.0.0.1:2379\"\n     listen-peer-urls: \"https://127.0.0.1:2380\"\n# 镜像拉去代理地址\nimageRepository: registry.aliyuncs.com/google_containers\nkind: ClusterConfiguration\n# k8s版本\nkubernetesVersion: 1.23.0\nnetworking:\n  dnsDomain: cluster.local\n  serviceSubnet: 10.96.0.0/12\n  podSubnet: 10.244.0.0/16\nscheduler: {}\n---\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nclusterCIDR: \"10.244.0.0/16\"\n# 启用 ipvs 模式\nmode: \"ipvs\"\n~~~\n\n### 配置文件写入到$HOME下\n\n~~~\nroot@k8s-master:~# mkdir -p $HOME/.kube\nroot@k8s-master:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nroot@k8s-master:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config\nroot@k8s-master:~# export KUBECONFIG=/etc/kubernetes/admin.conf\n~~~\n\n### 安装网络组建\n\n~~~\n//安装本地\nroot@k8s-master:~# kubectl apply -f k8s/kube-flannel.yml\n//安装远程\nroot@k8s-master:~# kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml\n~~~\n\n### 检查master节点是否安装成功\n\n~~~\nroot@k8s-master:~# kubectl get node \nNAME         STATUS   ROLES                  AGE   VERSION\nk8s-master   Ready    control-plane,master   13m   v1.23.9\n\nroot@k8s-master:~# kubectl get pod -A\nNAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE\nkube-system   coredns-6d8c4cb4d-d85pk              1/1     Running   0          36m\nkube-system   coredns-6d8c4cb4d-ddp9k              1/1     Running   0          36m\nkube-system   etcd-k8s-master                      1/1     Running   9          36m\nkube-system   kube-apiserver-k8s-master            1/1     Running   8          36m\nkube-system   kube-controller-manager-k8s-master   1/1     Running   10         36m\nkube-system   kube-proxy-h4xnv                     1/1     Running   0          36m\nkube-system   kube-scheduler-k8s-master            1/1     Running   11         36m\n~~~\n","tags":["kubeadm","kubernetes"],"categories":["运维"]},{"title":"mysql用户管理","url":"/2024/04/21/data/mysql-user/","content":"\n\n# 用户\n\n## 创建用户\n\n~~~\n-- 创建用户，并允许其在任何IP登陆\ncreate user 'username'@'%' identified by 'password';\n\n-- 创建用户，并允许其在任何主机登陆，不设置密码\ncreate user 'username'@'%';\n\n-- 创建用户，并仅允许使用domian.com域名的主机登陆\ncreate user 'username'@'domian.com' identified by 'password';\n\n-- 创建用户，并仅允许使用192.168.1.1的主机登陆\ncreate user 'username'@'192.168.1.1' identified by 'password';\n\n-- 创建用户，并仅允许使用192.168.1开头的主机登陆\ncreate user 'username'@'192.168.1.%' identified by 'password';\n~~~\n\n> 密码可以为空，如为空，则可以免密登陆\n>\n> 如果主机位使用 `%`，表示允许任意地址的主机登陆\n>\n> 主机位可以使用域名或者 IP 地址，但是不允许既有数字又有字母\n>\n> 主机位中可以使用 `%` 进行通配，例如：`%.domian.com` 或 `192.168.1.%`\n\n## 修改用户密码\n\n~~~\nrename user 'old_username'@'old_ip_addr' to 'new_username'@'new_ip_addr';\n\nset password for 'username'@'ip_addr'=Password('new_password');\n\n//修改完密码，需将配置刷到内存\nflush privileges;\n~~~\n\n## 用户名重命\n\n~~~\nrename user 'username'@'ip_addr' to 'zhiqiang'@'%'; \n~~~\n\n## 删除用户\n\n~~~\ndrop user 'username'@'ip_addr';\n~~~\n\n## 使用户过期\n\n~~~\n-- 90天过期\nALTER USER 'username'@'ip_addr' PASSWORD EXPIRE INTERVAL 90 DAY; \n-- 密码不过期\nALTER USER 'username'@'ip_addr' PASSWORD EXPIRE NEVER; \n-- 默认过期策略\nALTER USER 'username'@'ip_addr' PASSWORD EXPIRE DEFAULT; \n-- 强制用户密码过期\nALTER USER 'username'@'ip_addr' PASSWORD EXPIRE;\n~~~\n\n# 用户权限\n\n## 查看权限\n\n~~~\nshow grants for 'username'@'ip_addr';\n~~~\n\n## 权限授予\n\n~~~\n-- 授予用户所有库所有表的所有权限\ngrant all privileges on *.* to 'username'@'ip_addr';\n\n-- 授予用户database1库所有表的所有权限\ngrant all privileges on `database1`.* to 'username'@'ip_addr';\n\n-- 授予用户database1库table1表的所有权限\ngrant all privileges on `database1`.`table1` to 'username'@'ip_addr';\n\n-- 授予用户database1库所有表的只读权限\ngrant select on `database1`.* to 'username'@'ip_addr';\n\n-- 授予用户database1库table1表的插入、更新权限\ngrant insert,update on `database1`.`table1` to 'username'@'ip_addr';\n~~~\n\n## 权限回收\n\n~~~\n-- 回收用户所有权限\nrevoke all,grant option from 'username'@'ip_addr';\n\n-- 回收用户database1库所有表的只读权限\nrevoke select ON `database1`.* FROM 'username'@'%';\n~~~\n\n## DDL和DML\n\n> DDL(Data Definition Language 数据定义语言):用来定义数据库的对象,比如创建表、修改表结构等操作。主要的DDL语句有CREATE、ALTER、DROP等。\n>\n> DML(Data Manipulation Language 数据操作语言):用来查询或修改数据库中表记录。主要的DML语句有INSERT、UPDATE、DELETE、SELECT等。\n>\n> 只读权限：SELECT 权限：授予用户查询表数据的权限。是只读权限中最基本的权限。SHOW VIEW 权限：允许用户查看数据库中的视图。REPLICATION CLIENT 权：允许用户查询主从复制状态。EXECUTE 权限：允许用户执行存储过程和函数。该权限无法修改数据。LOCK TABLES 权限：允许用户对表加锁,可用于读操作的性能优化。EVENT 权限：允许用户查看事件的定义,用于只读事件相关信息。TRIGGER 权限：允许用户查看触发器的定义,无法修改触发器。\n\n### 实战：我现在这个数据连接中有 a，b，c三个数据库\n\n#### 将a和b 给zhiqiang用户DDL和DML（zhiqiang只拥有a和b的管理员权限）\n\n~~~\n// 先撤销用户对数据库的所有权限\nREVOKE ALL PRIVILEGES ON *.* FROM 'zhiqiang'@'%';\n//授予zhiqiang用户对a、b数据库的全部权限,包括DDL和DML权限\nGRANT ALL PRIVILEGES ON a.* TO 'zhiqiang'@'%';\nGRANT ALL PRIVILEGES ON b.* TO 'zhiqiang'@'%';\n//最后授权查询mysql.user表的权限,用于确保用户可以验证自己的权限设置\nGRANT SELECT ON mysql.user TO 'zhiqiang'@'%';\n//显示的权限设置情况确认是否符合要求\nSHOW GRANTS FOR 'zhiqiang'@'%';\n//刷新权限\nflush privileges;\n~~~\n\n#### 场景2：将a和b 给zhiqiang用户DDL权限\n\n~~~\n//撤销zhiqiang原有所有数据库权限\nREVOKE ALL PRIVILEGES ON *.* FROM 'zhiqiang'@'%';\n//针对a、b数据库授权常见的DDL操作权限如ALTER、CREATE、DROP等\nGRANT CREATE, DROP, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE ON a.* TO 'zhiqiang'@'%';\nGRANT CREATE, DROP, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE ON b.* TO 'zhiqiang'@'%';  \n//最后再授权查询mysql.user表权限以方便权限验证\nGRANT SELECT ON mysql.user TO 'zhiqiang'@'%';\n//显示的权限设置情况确认是否符合要求\nSHOW GRANTS FOR 'zhiqiang'@'%';\n//刷新权限\nflush privileges;\n~~~\n\n#### 场景3：将a和b 给zhiqiang用户DML权限\n\n~~~\n//撤销zhiqiang用户所有数据库的权限\nREVOKE ALL PRIVILEGES ON *.* FROM 'zhiqiang'@'%';\n//授予zhiqiang对a、b数据库的SELECT/INSERT/UPDATE/DELETE权限\nGRANT SELECT, INSERT, UPDATE, DELETE, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, SHOW VIEW, EVENT, TRIGGER ON a.* TO 'zhiqiang'@'%';\nGRANT SELECT, INSERT, UPDATE, DELETE, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, SHOW VIEW, EVENT, TRIGGER ON b.* TO 'zhiqiang'@'%';\n//授权查询mysql.user表权限用于权限验证\nGRANT SELECT ON mysql.user TO 'zhiqiang'@'%';\n//显示的权限设置情况确认是否符合要求\nSHOW GRANTS FOR 'zhiqiang'@'%';\n//刷新权限\nflush privileges;\n~~~\n\n#### 场景4：将a和b给zhiqiang用户只读权限\n\n~~~\n//撤销zhiqiang所有数据库权限\nREVOKE ALL PRIVILEGES ON *.* FROM 'zhiqiang'@'%';\n//授予zhiqiang用户对a、b数据库的SELECT, SHOW VIEW, EVENT, TRIGGER查询权限\nGRANT SELECT, LOCK TABLES, SHOW VIEW ON a.* TO 'zhiqiang'@'%';  \nGRANT SELECT, LOCK TABLES, SHOW VIEW ON b.* TO 'zhiqiang'@'%';\n//授权查询mysql.user表用于权限验证\nGRANT SELECT ON mysql.user TO 'zhiqiang'@'%';\n//显示的权限设置情况确认是否符合要求\nSHOW GRANTS FOR 'zhiqiang'@'%';\n//刷新权限\nflush privileges;\n~~~\n\n### 场景5: 给当前所有数据库给zhiqiang用户子只读权限\n\n~~~\n//生成只读的sql语句\nSELECT CONCAT('GRANT SELECT, LOCK TABLES, SHOW VIEW ON ', schema_name, '.* TO ''zhiqiang''@''%'';') as sqls FROM information_schema.schemata;\n//按需执行返回的sqls\n.....\n//刷新权限\nflush privileges;\n~~~\n\n# 备份与恢复\n\n~~~\n-- 备份database1库所有表结构+数据\nmysqdump -u username database1 > database1.sql -p\n\n-- 备份database1库所有表结构\nmysqdump -u username -d database1 > database1.sql -p\n\n-- 进入数据库\nuse database1;\n-- 将备份文件恢复到数据库中\nmysqdump -u username -d database1 < database1.sql -p\n\n-- 备份192.168.3.10中的database数据\nmysqldump -h 192.168.3.10 -u root -p123456 database > database.sql\n-- 还原数据库\nmysql -h 192.168.3.11 -P 3306 -u root -p123456 database < database.sql\n~~~\n\n# 常用权限列表\n\n| 权 限                   | 作用范围             | 作 用                         |\n| ----------------------- | -------------------- | ----------------------------- |\n| all                     | 服务器               | 所有权限                      |\n| select                  | 表、列               | 选择行                        |\n| insert                  | 表、列               | 插入行                        |\n| update                  | 表、列               | 更新行                        |\n| delete                  | 表                   | 删除行                        |\n| create                  | 数据库、表、索引     | 创建                          |\n| drop                    | 数据库、表、视图     | 删除                          |\n| reload                  | 服务器               | 允许使用flush语句             |\n| shutdown                | 服务器               | 关闭服务                      |\n| process                 | 服务器               | 查看线程信息                  |\n| file                    | 服务器               | 文件操作                      |\n| grant option            | 数据库、表、存储过程 | 授权                          |\n| references              | 数据库、表           | 外键约束的父表                |\n| index                   | 表                   | 创建/删除索引                 |\n| alter                   | 表                   | 修改表结构                    |\n| show databases          | 服务器               | 查看数据库名称                |\n| super                   | 服务器               | 超级权限                      |\n| create temporary tables | 表                   | 创建临时表                    |\n| lock tables             | 数据库               | 锁表                          |\n| execute                 | 存储过程             | 执行                          |\n| replication client      | 服务器               | 允许查看主/从/二进制日志状态  |\n| replication slave       | 服务器               | 主从复制                      |\n| create view             | 视图                 | 创建视图                      |\n| show view               | 视图                 | 查看视图                      |\n| create routine          | 存储过程             | 创建存储过程                  |\n| alter routine           | 存储过程             | 修改/删除存储过程             |\n| create user             | 服务器               | 创建用户                      |\n| event                   | 数据库               | 创建/更改/删除/查看事件       |\n| trigger                 | 表                   | 触发器                        |\n| create tablespace       | 服务器               | 创建/更改/删除表空间/日志文件 |\n| proxy                   | 服务器               | 代理成为其它用户              |\n| usage                   | 服务器               | 没有权限                      |","tags":["mysql","用户管理"],"categories":["数据库"]},{"title":"clone github代码出现Operation timed out解决","url":"/2024/04/21/git/clone-timeout/","content":"\n\n```text\n➜  ~ git clone git@github.com:pkg6/go-requests.git\nCloning into 'go-requests'...\nssh: connect to host github.com port 22: Operation timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n首先要确定你的ssh证书书否正确，如果正确还是出现上面问题可以按照下面的流程进行解决\n\n```text\n# This should also timeout\n$ ssh -T git@github.com\nssh: connect to host github.com port 22: Connection timed out\n\n# but this might work\n$ ssh -T -p 443 git@ssh.github.com\nHi xxxx! You've successfully authenticated, but GitHub does not provide shell access.\n\n# Override SSH settings\n$ cat > ~/.ssh/config << EOF\n# Add section below to it\nHost github.com\n  Hostname ssh.github.com\n  Port 443\nEOF\n\n\n$ ssh -T git@github.com\nHi xxxx! You've successfully authenticated, but GitHub does not provide shell access.\n\n$ git clone git@github.com:pkg6/go-requests.git\nCloning into 'go-requests'...\nremote: Enumerating objects: 461, done.\nremote: Counting objects: 100% (259/259), done.\nremote: Compressing objects: 100% (115/115), done.\nremote: Total 461 (delta 167), reused 200 (delta 144), pack-reused 202\nReceiving objects: 100% (461/461), 193.29 KiB | 257.00 KiB/s, done.\nResolving deltas: 100% (279/279), done.\n```","tags":["git","time out"],"categories":["git"]},{"title":"在mac系统下golang语言GRPC工具安装","url":"/2024/04/21/golang/grpc-make/","content":"\n## [protoc](https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.4)\n\n```\nhttps://github.com/protocolbuffers/protobuf/releases/tag/v3.19.4\n\n➜  ~ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.4/protoc-3.19.4-osx-x86_64.zip  -O protoc.zip \n➜  ~ unzip protoc.zip -d ~/protoc\n➜  ~ mv ~/protoc/bin/protoc /usr/local/bin/\n➜  ~ chmod a+x /usr/local/bin/protoc\n```\n\n## [protoc-gen-go](https://github.com/protocolbuffers/protobuf-gogithub.com/protocolbuffers/protobuf-go)\n\n```\n➜  ~ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n## [protoc-gen-go-grpc](https://github.com/grpc/grpc-go)\n\n```\n➜  ~ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n```\n\n## [bloomrpc客户端调试工具](https://github.com/bloomrpc/bloomrpcgithub.com/bloomrpc/bloomrpc)\n\n```\n➜  ~ brew install --cask bloomrpc\n```","tags":["google","grpc","mac","环境搭建"],"categories":["golang"]},{"title":"使用golang对接firebase登录流程","url":"/2024/04/21/golang/firebase-flow/","content":"\n客户端sdk： https://firebase.google.com/docs/auth/?hl=zh-cn\n\ngolang sdk: [GitHub - firebase/firebase-admin-go: Firebase Admin Go SDK](https://github.com/firebase/firebase-admin-go)\n\n服务端初始化文档： https://firebase.google.com/docs/admin/setup?hl=zh-cn\n\n服务端解析IdToken文档：https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=zh-cn\n\n后端开发阶段，可以用自定义token调试：https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=zh-cn\n\n授权流程：客户端第三方授权登录，换取idtoken -> 服务端获取idtoken，通过上述文档解析IdToken，拿到用户的授权信息\n\n自定义token换取idToken：https://firebase.google.com/docs/reference/rest/auth?hl=zh-cn\n\n","tags":["firebase","google"],"categories":["golang"]},{"title":"使用fastapi读取docx文件内容","url":"/2024/04/21/python/fastapi-upload-docx/","content":"\n### 需要安装的包\n\n```text\npython-docx==1.1.0\nfastapi==0.110.0\nuvicorn==0.22.0\npython-multipart==0.0.9\n```\n\n### 读取docx文件\n\n```text\nfrom docx import Document\n//打开文档\ndocument = Document(\"dark-and-stormy.docx\")\n//读取第0段的内容\ndocument.paragraphs[0].text\n```\n\n### 启动fastapi\n\n```text\nfrom fastapi import FastAPI\nimport uvicorn\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n    \nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n### 代码实战\n\n> 目标：文件上传读取文件内容\n> 需求：在服务端不存储上传的文件，将docx内容直接进行返回\n\n```text\nfrom fastapi import FastAPI, File, UploadFile\nimport uvicorn\nfrom tempfile import NamedTemporaryFile\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n@app.post(\"/docx\")\nasync def read_docx(docx: UploadFile = File()):\n    # 建立临时文件\n    temp_file = NamedTemporaryFile(delete=True)\n    temp_file.write(await docx.read())\n    temp_file.flush()\n    tmp_name = temp_file.name\n    from docx import Document\n    # 打开文档\n    document = Document(tmp_name)\n    # 将内容进行字符串连接（具体业务具体操作）\n    ret = \"\"\n    for idx, para in enumerate(document.paragraphs):\n        ret += document.paragraphs[idx].text\n    return ret\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```","tags":["fastapi","docx"],"categories":["python"]},{"title":"git免密拉取代码","url":"/2024/04/21/git/no-password-logn-git/","content":"\n## 方式1： 通过公钥和私钥进行ssh拉去代码\n\n生成公钥和私钥命令\n\n```text\nssh-keygen\n```\n\n拉去代码\n\n```text\ngit clone git@github.com:username/repository.git\n```\n\n### 方式1： 配置.netrc\n\n> 来源： [https://go.dev/doc/faq#git_https](https://link.zhihu.com/?target=https%3A//go.dev/doc/faq%23git_https)\n\n在liunx或mac系统下\n\n```text\necho machine github.com login 账号 password 密码 > ~/.netrc\n```\n\n拉去代码\n\n```text\ngit clone https://github.com/username/repository.git\n```","tags":["git","password"],"categories":["git"]},{"title":"在项目中git中常见分支及其作用","url":"/2024/04/21/git/branch-manage/","content":"\n## master/main分支\n\nmaster/main分支是主分支，包含了已经发布到生产环境的稳定，可靠版本的代码。一般情况下，master/main分支应该只用于发布新版本，而不应该直接修改或提交新的功能。\n\n### develop分支\n\ndevelop分支是开发分支，包含了当前正在进行的所有功能和任务。所有新功能开发、改进、优化等都应该从此分支开始，并最终合并回此分支。\n\n### feature分支\n\nfeature分支是从develop分支创建的分支，通常用于开发新功能。每个新功能都应该从develop分支开始，并在一个独立的feature分支上进行开发工作。一旦新功能得到完全实现、测试并且可靠，该分支就会被合并回develop分支。\n\n### release分支\n\nrelease分支是从develop分支创建的分支，通常用于为即将发布的版本做准备工作。在此分支上可以进行最终的测试、修复bug、检查文档等操作，以确保发布版本的质量。一旦准备工作完成并且得到完全测试，该分支就会被合并回master分支，并作为新的发布版本。并将该分支合并回develop分支，以便后续的开发工作。\n\n### hotfix分支\n\nhotfix分支是从master/main分支创建的分支，用于在生产环境中紧急修复问题。修复完毕后，该分支将会被合并回master/main和develop分支。","tags":["branch"],"categories":["git"]},{"title":"通过shell脚本clone组织下所有仓库","url":"/2024/04/21/git/sh-cloen-repos/","content":"\n### 获取github组织下仓库\n\n```text\ncurl --silent \\\n              -H \"Accept: application/vnd.github+json\" \\\n              -H \"Authorization: Bearer <YOUR-TOKEN> \\\n              -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n              https://api.github.com/orgs/{orgs}/repos\n```\n\n###  下载代码\n\n```text\ngit clone --mirror git@github.com:{orgs}/{repos}.git\n```\n\n### 总结完整代码\n\n```text\n#!/bin/bash\norgs=\"<target-orgs>\"\ntoken=\"<YOUR-TOKEN>\"\n# JSON数据\nrepos_json=$(curl --silent \\\n              -H \"Accept: application/vnd.github+json\" \\\n              -H \"Authorization: Bearer ${token}\" \\\n              -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n              https://api.github.com/orgs/${orgs}/repos)\n# 使用jq将JSON数组转换为行\necho \"${repos_json}\" | jq -r '.[] | @json' | while IFS= read -r line; do\n  # 处理每一行（也就是每个JSON对象）\n  # 解析JSON对象以获取ssh地址和name\n  ssh_url=$(echo \"$line\" | jq -r '.ssh_url')\n  name=$(echo \"$line\" | jq -r '.name')\n  dir_pat=\"${orgs}/${name}\"\n  echo \"正在下载 ${ssh_url} 到 ${dir_pat}\"\n  git clone --mirror ${ssh_url}  ${dir_pat}\n  echo \"下载完成 ${ssh_url}\"\ndone\n```","tags":["sh","git","github"],"categories":["sh"]},{"title":"在spring boot框架中使用mybatis操作数据库","url":"/2024/04/21/java/springboot-mybatis/","content":"\n# 加载mybatis依赖\n\n~~~\n<dependency>\n    <!--\n     数据库操作\n     https://github.com/mybatis/spring-boot-starter\n     https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/zh/index.html\n    -->\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.4</version>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n~~~\n\n\n\n# 通过注解的方式\n\n## 在配置文件配置数据库连接application.yml\n\n~~~\nserver:\n  port: 8000\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    url: jdbc:mysql://127.0.0.1:3306/mall?characterEncoding=utf8&useSSL=false\nmybatis:\n  configuration:\n    map-underscore-to-camel-case: true\n\n~~~\n\n## 定义CityMapper\n\n~~~\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\nimport org.apache.ibatis.annotations.Select;\n\n@Mapper\npublic interface CityMapper {\n    @Select(\"SELECT * FROM CITY WHERE state = #{state}\")\n    City findByState(@Param(\"state\") String state);\n}\n~~~\n\n> 当数据库表特别多的时候,我们写一个interface的时候都需要加上`@Mapper`注解，这时候我们只需要在入口加上\n>\n> ~~~\n> import org.mybatis.spring.annotation.MapperScan;\n> import org.springframework.boot.SpringApplication;\n> import org.springframework.boot.autoconfigure.SpringBootApplication;\n> \n> @SpringBootApplication\n> @MapperScan(basePackages = \"com.github.example.mapper\")\n> public class Application {\n>     public static void main(String[] args) {\n>         SpringApplication.run(Application.class,args);\n>     }\n> }\n> ~~~\n\n## 定义City实体\n\n~~~\nimport lombok.Data;\n\n@Data\npublic class City {\n    private Integer id;\n}\n~~~\n\n## 写测试用例\n\n~~~\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class CityMapperTest  {\n\n    @Autowired\n    private CityMapper cityMapper;\n\n    public void testFindByState() {\n        City byState = cityMapper.findByState(\"1\");\n        System.out.println(byState.getId());\n    }\n}\n~~~\n\n# Xml方式使用\n\n在配置文件配置数据库连接application.yml\n\n~~~\nserver:\n  port: 8000\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    url: jdbc:mysql://127.0.0.1:3306/example?characterEncoding=utf8&useSSL=false\nmybatis:\n  configuration:\n    map-underscore-to-camel-case: true\n  mapper-locations: classpath:mapper/*.xml\n~~~\n\n## 首先定义city.xml\n\n~~~\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.github.example.mapper.CityMapper\">\n    <select id=\"queryByState\" resultType=\"com.github.example.model.City\">\n        SELECT * FROM CITY WHERE state = #{state}\n    </select>\n</mapper>\n~~~\n\n> namespace：复制完整的包名并包含class\n>\n> queryByState：class中的queryByState方法\n>\n> resultType：返回结果映射的实体\n\n## 定义CityMapper和City\n\n> 通过注解方式已定义，只需要在CityMapper添加queryByState方法\n\n~~~\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\nimport org.apache.ibatis.annotations.Select;\n\n@Mapper\npublic interface CityMapper {\n    @Select(\"SELECT * FROM CITY WHERE state = #{state}\")\n    City findByState(@Param(\"state\") String state);\n\n    City queryByState(String state);\n}\n~~~\n\n## 写测试用例\n\n~~~\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class CityMapperTest  {\n\n    @Autowired\n    private CityMapper cityMapper;\n\n    public void testqueryByState() {\n        City byState = cityMapper.queryByState(\"1\");\n        System.out.println(byState.getId());\n    }\n}\n~~~\n\n","tags":["java","springboot","mybatis"],"categories":["java"]},{"title":"在mac电脑配置Java环境","url":"/2024/04/21/java/mac-build/","content":"\n### JDK\n\n~~~\nbrew install openjdk@8\n\nexport PATH=\"/usr/local/opt/openjdk@8/bin:$PATH\"\nexport JAVA_HOME=/usr/local/Cellar/openjdk@8/1.8.0+362/libexec/openjdk.jdk/Contents/Home\n~~~\n\n### maven\n\n ~~~\n https://maven.apache.org/download.cgi\n https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.zip\n https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz\n mkdir -p /usr/local/Cellar/maven@3.8\n tar -xzvf apache-maven-3.8.8-bin.tar.gz -C /usr/local/Cellar/maven@3.8 --strip-components=1\n \n export PATH=\"/usr/local/Cellar/maven@3.8/bin:$PATH\"\n ~~~\n\n### IntelliJ IDEA\n\n~~~\nIntelliJ IDEA菜单选择：File->Project Structure->Platform Settings->SDKs->`+`->Add JDK\nCmd+Shift+G切换到/usr/local/Cellar/openjdk@8/1.8.0+362/libexec/openjdk.jdk/Contents/Home目录下\n\nIntelliJ IDEA菜单选择：File->Project Structure->Project Settings\nLanguage level 选中8\n\nIntelliJ IDEA菜单选择：IntelliJ IDEA->settings->Build,Execution,Deployment->Compiler->Java Compiler\n找到 Per-module bytecode version\n将整个列Target bytecode version修改成8\n\n\nIntelliJ IDEA菜单选择：IntelliJ IDEA->settings->Build,Execution,Deployment->Build Tools->Maven\n找到 Maven home path 修改成 /usr/local/Cellar/maven@3.8\n~~~\n\n","tags":["环境搭建","java"],"categories":["java"]},{"title":"springboot-source-code","url":"/2024/04/21/java/springboot-source-code/","content":"\n## 环境搭建\n\n> https://maven.apache.org/download.cgi\n\n~~~\nbrew install openjdk@8\nexport PATH=\"/usr/local/opt/openjdk@8/bin:$PATH\"\nexport JAVA_HOME=/usr/local/Cellar/openjdk@8/1.8.0+362/libexec/openjdk.jdk/Contents/Home\n\n\nhttps://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz\nmkdir -p /usr/local/Cellar/maven@3.8\ntar -xzvf apache-maven-3.8.8-bin.tar.gz -C /usr/local/Cellar/maven@3.8 --strip-components=1\nexport PATH=\"/usr/local/Cellar/maven@3.8/bin:$PATH\"\n~~~\n\n## 下载并编译源码\n\n> https://github.com/spring-projects/spring-boot/releases/tag/v2.1.18.RELEASE\n\n~~~\nwget https://github.com/spring-projects/spring-boot/archive/refs/tags/v2.1.18.RELEASE.tar.gz\ntar -xzvf  v2.1.18.RELEASE.tar.gz\ncd spring-boot-2.1.18.RELEASE\n//跳过测试用例（下载jar包，时间会有点久）\nmvn clean install -DskipTests -Pfast\n~~~\n\n## 打开pom.xml关闭maven代码检查\n\n~~~\n<properties>\n  <revision>2.1.18.RELEASE</revision>\n  <main.basedir>${basedir}</main.basedir>\n  //添加\n  <disable.checks>true</disable.checks>\n</properties>\n~~~\n","tags":["环境搭建","java","springboot","编译"],"categories":["java"]},{"title":"easyswoole实现websocket","url":"/2021/06/18/php/easyswoole-websockey/","content":"\neasyswoole实现websocket的步骤解析\n\n\n配置 Websocket服务\n\n~~~\n'MAIN_SERVER' => [\n  'SERVER_TYPE' => EASYSWOOLE_WEB_SOCKET_SERVER,\n  'SETTING' => [\n    // 该参数项为心跳检测，严格参考swoole 配置说明\n    'heartbeat_check_interval' => 60,\n  ],\n],\n~~~\n\nfd与uuid绑定类`App/Support/FdManager.php`\n\n~~~\n<?php\nnamespace App\\Support;\nuse EasySwoole\\Component\\Singleton;\nuse Swoole\\Table;\n/**\n * Class FdManager\n * @package App\\Support\n */\nclass FdManager\n{\n    use Singleton;\n\n    /**\n     * @var Table\n     */\n    private $fdUuid;\n    /**\n     * @var Table\n     */\n    private $uuidFd;\n\n    /**\n     * FdManager constructor.\n     * @param int $size\n     */\n    public function __construct(int $size = 1024 * 256)\n    {\n        $this->fdUuid = new Table($size);\n        $this->fdUuid->column('uuid', Table::TYPE_STRING, 25);\n        $this->fdUuid->create();\n        $this->uuidFd = new Table($size);\n        $this->uuidFd->column('fd', Table::TYPE_INT, 10);\n        $this->uuidFd->create();\n    }\n\n    /**\n     * fd 绑定\n     * @param int $fd\n     * @param string $uuid\n     * @return mixed\n     */\n    public function bind(int $fd, $uuid)\n    {\n        // TODO: Implement bind() method.\n        $this->fdUuid->set($fd, ['uuid' => $uuid]);\n        $this->uuidFd->set($uuid, ['fd' => $fd]);\n    }\n\n    /**\n     * 删除fd绑定关系\n     * @param int $fd\n     * @return mixed\n     */\n    public function delete(int $fd)\n    {\n        // TODO: Implement delete() method.\n        $uuid = $this->fdUuid($fd);\n        if ($uuid) {\n            $this->uuidFd->del($uuid);\n        }\n        $this->fdUuid->del($fd);\n    }\n\n    /**\n     * 通过fd找到绑定的uuid\n     * @param int $fd\n     * @return mixed\n     */\n    public function fdUuid(int $fd)\n    {\n        // TODO: Implement fdUuid() method.\n        $ret = $this->fdUuid->get($fd);\n        if ($ret) {\n            return $ret['uuid'];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * 通过uuid找到fd\n     * @param  $uuid\n     * @return mixed\n     */\n    public function uuidFd($uuid)\n    {\n        // TODO: Implement uuidFd() method.\n        $ret = $this->uuidFd->get($uuid);\n        if ($ret) {\n            return $ret['fd'];\n        } else {\n            return null;\n        }\n    }\n}\n\n~~~\n\n\n\nwebscoekt 事件类`/App/WebSocket/WebSocketEvent.php`\n\n~~~\n<?php\nnamespace App\\WebSocket;\nuse App\\Support\\FdManager;\n/**\n * Class WebSocketEvent\n * @package App\\WebSocket\n */\nclass WebSocketEvent\n{\n    /**\n     * 握手事件\n     * 所有客户端建立连接时触发的方法\n     * @param \\swoole_http_request $request\n     * @param \\swoole_http_response $response\n     * @return bool\n     */\n    public function onHandShake(\\swoole_http_request $request, \\swoole_http_response $response)\n    {\n        /** 此处自定义握手规则 返回 false 时中止握手 */\n        if (!$this->customHandShake($request, $response)) {\n            $response->end();\n            return false;\n        }\n        /** 此处是  RFC规范中的WebSocket握手验证过程 必须执行 否则无法正确握手 */\n        if ($this->secWebsocketAccept($request, $response)) {\n            $response->end();\n            return true;\n        }\n        $response->end();\n        return false;\n    }\n\n    /**\n     * 关闭事件\n     * 所有客户端关闭时触发的方法\n     * @param \\swoole_server $server\n     * @param int $fd\n     * @param int $reactorId\n     */\n    public function onClose(\\swoole_server $server, int $fd, int $reactorId)\n    {\n        /** @var array $info */\n        $info = $server->getClientInfo($fd);\n        /**\n         * 判断此fd 是否是一个有效的 websocket 连接\n         * 参见 https://wiki.swoole.com/wiki/page/490.html\n         */\n        if ($info && $info['websocket_status'] === WEBSOCKET_STATUS_FRAME) {\n            /**\n             * 判断连接是否是 server 主动关闭\n             * 参见 https://wiki.swoole.com/wiki/page/p-event/onClose.html\n             */\n            if ($reactorId < 0) {\n            }\n            //删除绑定关系\n            FdManager::getInstance()->delete($fd);\n        }\n    }\n\n    /**\n     * RFC规范中的WebSocket握手验证过程\n     * 以下内容必须强制使用\n     *\n     * @param \\swoole_http_request $request\n     * @param \\swoole_http_response $response\n     * @return bool\n     */\n    protected function secWebsocketAccept(\\swoole_http_request $request, \\swoole_http_response $response): bool\n    {\n        // ws rfc 规范中约定的验证过程\n        if (!isset($request->header['sec-websocket-key'])) {\n            // 需要 Sec-WebSocket-Key 如果没有拒绝握手\n            return false;\n        }\n        if (0 === preg_match('#^[+/0-9A-Za-z]{21}[AQgw]==$#', $request->header['sec-websocket-key'])\n            || 16 !== strlen(base64_decode($request->header['sec-websocket-key']))\n        ) {\n            //不接受握手\n            return false;\n        }\n        $key = base64_encode(sha1($request->header['sec-websocket-key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));\n        $headers = array(\n            'Upgrade' => 'websocket',\n            'Connection' => 'Upgrade',\n            'Sec-WebSocket-Accept' => $key,\n            'Sec-WebSocket-Version' => '13',\n            'KeepAlive' => 'off',\n        );\n        if (isset($request->header['sec-websocket-protocol'])) {\n            $headers['Sec-WebSocket-Protocol'] = $request->header['sec-websocket-protocol'];\n        }\n        // 发送验证后的header\n        foreach ($headers as $key => $val) {\n            $response->header($key, $val);\n        }\n        // 接受握手 还需要101状态码以切换状态\n        $response->status(101);\n        // fd 和 uuid 进行绑定\n        FdManager::getInstance()->bind($request->fd, $request->get['uuid']);\n        return true;\n    }\n    \n    /**\n     * 自定义握手事件\n     * @param \\swoole_http_request $request\n     * @param \\swoole_http_response $response\n     * @return bool\n     */\n    private function customHandShake(\\swoole_http_request $request, \\swoole_http_response $response)\n    {\n        return true;\n    }\n}\n\n~~~\n\nWebcoket解析类`App/WebSocket/WebSocketParser.php`\n\n~~~\n<?php\n\n\nnamespace App\\WebSocket;\nuse EasySwoole\\Socket\\AbstractInterface\\ParserInterface;\nuse EasySwoole\\Socket\\Bean\\Caller;\nuse EasySwoole\\Socket\\Bean\\Response;\n\nclass WebSocketParser implements ParserInterface\n{\n    public function decode($raw, $client): ?Caller\n    {\n        // TODO: Implement decode() method.\n        $caller = new Caller;\n        if ($raw !== 'PING') {\n            $payload = json_decode($raw, true);\n            $class = isset($payload['controller']) ? $payload['controller'] : 'index';\n            $action = isset($payload['action']) ? $payload['action'] : 'actionNotFound';\n            $params = isset($payload['params']) ? (array)$payload['params'] : [];\n            $controllerClass = \"\\\\App\\\\WebSocket\\\\Controller\\\\\" . ucfirst($class);\n            if (!class_exists($controllerClass)) $controllerClass = \"\\\\App\\\\WebSocket\\\\Controller\\\\Index\";\n            $caller->setClient($caller);\n            $caller->setControllerClass($controllerClass);\n            $caller->setAction($action);\n            $caller->setArgs($params);\n        } else {\n            // 设置心跳执行的类和方法\n            $caller->setControllerClass(\\App\\WebSocket\\Controller\\Base::class);\n            $caller->setAction('heartbeat');\n        }\n        return $caller;\n    }\n\n    public function encode(Response $response, $client): ?string\n    {\n        // TODO: Implement encode() method.\n        return $response->getMessage();\n    }\n}\n\n~~~\n\n注册 websocket服务 `EasySwooleEvent.php`\n\n~~~\npublic static function mainServerCreate(EventRegister $register)\n{\n        $conf = new \\EasySwoole\\Socket\\Config();\n        //设置Dispatcher为WebSocket 模式\n        $conf->setType(\\EasySwoole\\Socket\\Config::WEB_SOCKET);\n        try {\n            $conf->setParser(new \\App\\WebSocket\\WebSocketParser());//设置解析器对象\n            $dispatch = new \\EasySwoole\\Socket\\Dispatcher($conf);//创建Dispatcher对象并注入config对象\n        } catch (\\Exception $e) {\n            Log::error($e->getMessage());\n        }\n        //给server注册相关事件在WebSocket模式下onMessage事件必须注册 并且交给Dispatcher对象处理\n        $register->set(EventRegister::onMessage, function (\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) use ($dispatch) {\n            $dispatch->dispatch($server, $frame->data, $frame);\n        });\n        $websocketEvent = new \\App\\WebSocket\\WebSocketEvent();\n        //自定义握手事件\n        $register->set(EventRegister::onHandShake, function (\\swoole_http_request $request, \\swoole_http_response $response) use ($websocketEvent) {\n            $websocketEvent->onHandShake($request, $response);\n        });\n        //自定义关闭事件\n        $register->set(EventRegister::onClose, function (\\swoole_server $server, int $fd, int $reactorId) use ($websocketEvent) {\n            $websocketEvent->onClose($server, $fd, $reactorId);\n        });\n\n}\n~~~\n\n创建控制器目录，让easyswoole 的websocket服务像http服务那样调用方便\n\n基类控制器`App/WebSocket/Controller/Base.php`\n\n~~~\n<?php\nnamespace App\\WebSocket\\Controller;\nuse EasySwoole\\Socket\\AbstractInterface\\Controller;\n/**\n * Class Base\n * @package App\\WebSocket\\Controller\n */\nclass Base extends Controller\n{\n    /**\n     * 心跳执行的方法\n     * 该方法建议 迁移到 基类控制器 Base 中\n     * 推荐使用 easyswoole 自带的websocket客户端调试\n     * http://www.easyswoole.com/wstool.html\n     */\n    public function heartbeat()\n    {\n        $this->response()->setMessage('心跳 heartbeat');\n    }\n\n    /**\n     * @param string|null $actionName\n     */\n    protected function actionNotFound(?string $actionName)\n    {\n        $this->response()->setMessage($actionName . ' not find'); // 推送消息\n    }\n}\n~~~\n\n测试控制器`App/WebSocket/Controller/Test.php`\n\n~~~~\n<?php\nnamespace App\\WebSocket\\Controller;\nclass Test extends Base\n{\n    public function index()\n    {\n        $fd = $this->caller()->getClient()->getFd();// 请求用户的fd\n        $data = $this->caller()->getArgs(); // 获取请求参数\n   \t\t\t//\n        \\EasySwoole\\EasySwoole\\ServerManager::getInstance()->getSwooleServer()->worker_id\n        \n        //发送响应消息\n        $this->response()->setMessage(\"响应消息\");\n       \n        $server = ServerManager::getInstance()->getSwooleServer();\n        //推送消息\n        $server->push($fd, “要推送的消息”);\n    }\n}\n~~~~","tags":["swoole","easyswoole","websocket"],"categories":["php"]},{"title":"PHP 获取文件的MimeType","url":"/2021/02/04/php/php-get-mimetype/","content":"\n\n# 本地路径获取\n\n## mime_content_type\n\n如果你的PHP版本是`< 5.3` 的，可以直接使用\n\n```\necho mime_content_type(\"a.jpg\");\n```\n\n> 该方法在`PHP 5.3`就废弃了，如果仍想使用此函数，那么可以对php进行配置启用magic_mime扩展。\n\n## Fileinfo函数\n\n在`PHP 5.3`及以上版本，官方推荐使用`Fileinfo`函数来获取mime-type，需要开启file_info扩展。\n\n```\n$finfo    = finfo_open(FILEINFO_MIME);\n$mimetype = finfo_file($finfo, $filename);\nfinfo_close($finfo);\n```\n\n## image_type_to_mime_type():\n\n 果需要判断MIME类型的文件只有图像文件，那么首先可以使用`exif_imagetype()`函数获取图像类型常量，再用`image_type_to_mime_type()`函数将图像类型常量转换成图片文件的MIME类型。 \n\n>  *注意：需要在php.ini中配置打开php_mbstring.dll(Windows需要)和extension=php_exif.dll。* \n\n# 远程链接获取\n\n## get_headers():\n\n~~~\n$strUrl = \"http://domian.com/demo.png\";\n$arrTmp = get_headers($strUrl,true);\n$mime_type = $arrTmp['Content-Type'];\n~~~\n\n## CURL\n\n~~~\n$strUrl = \"http://domian.com/demo.png\";\n$ch = curl_init($strUrl);\ncurl_setopt($ch,CURLOPT_HEADER,1);\ncurl_setopt($ch,CURLOPT_NOBODY,1);\ncurl_setopt($ch,CURLOPT_RETURNTRANSFER,1);\n$tmp = curl_exec($ch);\n//$mime_type = curl_getinfo($ch,CURLINFO_CONTENT_TYPE);\ncurl_close($ch);\npreg_match('/Content-Type:\\s(.*)\\s/',$tmp,$arr);\n$mime_type = $arr[1];\n~~~","tags":["php函数"],"categories":["php"]},{"title":"响应状态码解释","url":"/2021/01/30/management/httpcode/","content":"\n\n### 201-206都表示服务器成功处理了请求的状态代码，说明网页可以正常访问。\n\n200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。\n\n201（已创建） 请求成功且服务器已创建了新的资源。\n\n202（已接受） 服务器已接受了请求，但尚未对其进行处理。\n\n203（非授权信息） 服务器已成功处理了请求，但返回了可能来自另一来源的信息。\n\n204（无内容） 服务器成功处理了请求，但未返回任何内容。\n\n205（重置内容） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。\n\n206（部分内容） 服务器成功处理了部分 GET 请求。\n\n### 300-307表示的意思是：要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。\n\n300（多种选择） 服务器根据请求可执行多种操作。服务器可根据请求者 来选择一项操作，或提供操作列表供其选择。\n\n301（永久移动） 请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。\n\n302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎页面或网站已被移动。\n\n303（查看其他位置） 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。\n\n304（未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。\n如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应。由于服务器可以告诉 搜索引擎自从上次抓取后网页没有更改过，因此可节省带宽和开销。\n\n305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。\n\n307（临时重定向） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎某个页面或网站已被移动。\n\n### 4XXHTTP状态码表示请求可能出错，会妨碍服务器的处理。\n\n400（错误请求） 服务器不理解请求的语法。\n\n401（身份验证错误） 此页要求授权。您可能不希望将此网页纳入索引。\n\n403（禁止） 服务器拒绝请求。\n\n404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。\n\n405（方法禁用） 禁用请求中指定的方法。\n\n406（不接受） 无法使用请求的内容特性响应请求的网页。\n\n407（需要代理授权） 此状态码与 401 类似，但指定请求者必须授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。\n\n408（请求超时） 服务器等候请求时发生超时。\n\n409（冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。\n\n410（已删除） 请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久删除，您应当使用 301 指定资源的新位置。\n\n411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。\n\n412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。\n\n413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n\n414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。\n\n415（不支持的媒体类型） 请求的格式不受请求页面的支持。\n\n416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态码。\n\n417（未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。\n\n### 500至505表示的意思是：服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n\n500（服务器内部错误） 服务器遇到错误，无法完成请求。\n\n501（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。\n\n502（错误网关） 服务器作为网关或代理，从上游服务器收到了无效的响应。\n\n503（服务不可用） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。\n\n504（网关超时） 服务器作为网关或代理，未及时从上游服务器接收请求。\n\n505（HTTP的 版本不受支持） 服务器不支持请求中所使用的 HTTP 协议版本。","tags":["状态码"],"categories":["网络编程"]},{"title":"windwos10查看wifi密码","url":"/2021/01/30/soft/windwos10-cmd-wifi-info/","content":"\n检查自己连接过的WiFi查看指定wifi信息\n~~~\nC:\\Users\\admin>netsh \nnetsh>wlan show profile\n\nnetsh>wlan show profile WiFi名称 key=clear\n~~~","tags":["windows","wifi"],"categories":["运维"]},{"title":"acme.sh","url":"/2021/01/14/soft/acme-sh/","content":"\nacme.sh 实现了 `acme` 协议, 可以从 letsencrypt 生成免费的证书.\n\n# 1. 安装 acme.sh\n\n~~~\n# sh 安装\ncurl  https://get.acme.sh | sh\n\n# 源码安装\ngit clone https://github.com/acmesh-official/acme.sh.git\ncd ./acme.sh\n./acme.sh --install\n\n#  创建 一个 bash 的 alias\nalias acme.sh=~/.acme.sh/acme.sh\n~~~\n\n# 2. 生成证书\n在生成之前，确保你的域名可以正常访问到webroot目录下\n\n~~~\nacme.sh  --issue -d www.zhiqiang.wang  --webroot  /wwwroot/zhiqiang.wang/\n~~~\n\n# 3. copy/安装 证书\n\n~~~\nmkdir -p /etc/nginx/ssl\n\nacme.sh --installcert -d www.zhiqiang.wang \\\n--key-file /etc/nginx/ssl/www.zhiqiang.wang.key \\\n--fullchain-file /etc/nginx/ssl/www.zhiqiang.wang.cer \\\n--reloadcmd \"service nginx force-reload\"\n~~~\n\n# 4. 更新证书\n\n目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.\n\n> 详细文档\n>\n> https://github.com/acmesh-official/acme.sh/wiki","tags":["ssl证书"],"categories":["运维"]},{"title":"冷热分离","url":"/2020/12/29/data/cold-and-hot/","content":"\n\n## 什么是冷热分离\n\n就是数据分成冷库和热库2个库，冷库只存放那那些走到终态的数据，热库存放还需要去修改字段的数据\n\n## 什么情况下使用冷热分离\n\n- 数据走到终态后，对数据只有读的没有写的需求，比如订单完结状态\n- 用户能接受新旧数据分开查询，比如订单列表默认只能查询三个月内的订单，如果查询更早的状态，需要切换页面进行查询\n\n## 实现思路\n\n### 如果判断数据到底是冷数据还是热数据\n\n   时间维度：在我们订单主表中一定会记录该订单的下单时间，我们可以将三个月之前的作为冷数据，三个月之内的数据作为热数据\n\n   状态维度：我们可以将已完结的订单作为冷数据，其他作为热数据\n\n   在实际工作中，我们可以根据`下单时间`和`订单状态`进行分离\n\n###  如何触发冷热分离以及优缺点\n\n   |      | 修改写操作业务逻辑                                           | 监听数据库变`binlog`更日志                                   | 定时扫描数据库                             |\n   | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |\n   | 优点 | 代码灵活可控 ；保证数据实时性                                | 与业务代码解耦；可以做到低延时                               | 与代码解耦；可以根据时间区分冷热数据的场景 |\n   | 缺点 | 不能按照时间区分冷热，当数据变成冷数据，期间可能没有其他任何操作；需要修改㕛数据库的写操作的代码 | 不能按照时间区分冷热，当数据变成冷数据，期间可能没有其他任何操作；需要考虑数据并发操作，就是业务代码与冷热变更代码同时操作同一个数据 | 不能做到实时                               |\n\n   根据实际场景选择一个最优的方案，个人比较采用定时扫描的方案。\n\n###  如何实现\n\n   1）在热数据中，给要搬的数据添加一个标识\n\n   2）找出待搬的数据，进行标记\n\n   3）使用事务进行包裹，将冷的数据保存在冷库中\n\n   4）删除原数据冷数据部分\n\n   > 在实现的过程中，会遇到各种各样的问题都是值得我们深思熟虑\n   >\n   > 1.同时修改多个数据库，如何保证数据的一致性？\n   >\n   > 2.假设数据量大，一次性处理不完，该怎么办？是否需要使用批量处理？\n   >\n   > 3.假设数据量大到要分到多个地方并行处理，该怎么办？\n\n##  如何使用\n\n   一般都会有一个选项供我们选择需要查询冷数据还是热数据，如果界面上没有提供，我们可以直接在业务代码里区分。","tags":["冷热分离","mysql"],"categories":["数据库"]},{"title":"docker环境下gitlab使用记录","url":"/2020/11/22/docker/gitlab/","content":"\n\n# docker安装运行gitlab\n\n~~~\nmkdir -p /data/gitlab/etc /data/gitlab/logs  /data/gitlab/data\n\ndocker run --name gitlab \\\n-p 8022:22 -p 8443:443 -p 8080:80 \\\n--memory 4g \\\n--restart always \\\n-v /data/gitlab/etc:/etc/gitlab \\\n-v /data/gitlab/logs:/var/log/gitlab \\\n-v /data/gitlab/data:/var/opt/gitlab \\\n-d gitlab/gitlab-ce:12.3.5-ce.0\n~~~\n\n> --name 命令容器的名称\n>\n> -d 报错容器后台持续运行\n>\n> -p 暴露端口\n>\n> -v 挂在目录\n\n\n\n# 配置 GitLab 使用 HTTPS 协议\n\n## 挂在在容器中配置https\n\n修改配置文件`vim /data/gitlab/etc/gitlab.rb`\n\n~~~\n###################################################\n# 添加外部请求的域名(如果不支持https, 可以改成http)\nexternal_url 'https://gitlab.example.com'\n# 修改gitlab对应的时区 \ngitlab_rails['time_zone'] = 'PRC'\n\n# 开启邮件支持 \ngitlab_rails['gitlab_email_enabled'] = true\ngitlab_rails['gitlab_email_from'] = 'gitlab@example.com'\ngitlab_rails['gitlab_email_display_name'] = 'GitLab'\n\n# 配置邮件参数\ngitlab_rails['smtp_enable'] = true\ngitlab_rails['smtp_address'] = \"smtp.163.com\"\ngitlab_rails['smtp_port'] = 25\ngitlab_rails['smtp_user_name'] = \"gitlab@example.com\"\ngitlab_rails['smtp_password'] = \"xxxxxx\"\ngitlab_rails['smtp_domain'] = \"domian.com\"\ngitlab_rails['smtp_authentication'] = \"login\"\ngitlab_rails['smtp_enable_starttls_auto'] = true\ngitlab_rails['smtp_tls'] = false        \n###################################################\n\n#SSL密钥相关配置#\nnginx['redirect_http_to_https'] = true\nnginx['ssl_certificate'] = \"/data/gitlab/ssl/gitlab.example.com.crt\"\nnginx['ssl_certificate_key'] = \"/data/gitlab/ssl/gitlab.example.com.key\"\n~~~\n\n配置https主要修改参数\n\n~~~\n# 域名(https://)\nexternal_url 'https://gitlab.example.com'\n# http重定向到https\nnginx['redirect_http_to_https'] = true\nnginx['ssl_certificate'] = \"/data/gitlab/ssl/gitlab.example.com.crt\"\nnginx['ssl_certificate_key'] = \"/data/gitlab/ssl/gitlab.example.com.key\"\n~~~\n\n修改配置文件就需要进行重启\n\n~~~\ngitlab-ctl reconfigure\n\ndocker restart gitlab\n~~~\n\n\n\n## 挂在在宿主nginx上配置https\n\n配置文件修改\n\n~~~\n# 禁用`gitlab`内置的`nginx`\nnginx['enable'] = false\n# 修改成与`nginx`运行时的用户一致\nweb_server['external_users'] = ['root']\n# 监听方式为 tcp\ngitlab_workhorse['listen_network'] = \"tcp\"\n# 下面的192.168.1.24为本机IP，根据实际情况修改，不能为 localhost 或者 127.0.0.1，否则 docker 访问不到，8181是默认监听的端口\ngitlab_workhorse['listen_addr'] = \"192.168.1.24:8181\"\n~~~\n\n修改完配置重启容器\n\n~~~\ndocker exec gitlab gitlab-ctl reconfigure\ngitlab-ctl reconfigure\ndocker restart gitlab\n~~~\n\n宿主nginx 配置文件`gitlab.conf`  \n\n> 参考：https://gitlab.com/gitlab-org/gitlab-recipes/tree/master/web-server/nginx\n\n需要修改地方\n\n~~~\nupstream gitlab-workhorse {\n  server unix:/data/gitlab/data/gitlab-workhorse/socket fail_timeout=0;\n}\nserver_name gitlab.example.com;\n~~~\n\n# 数据备份\n\n~~~\ndocker exec -t gitlab gitlab-rake gitlab:backup:create\n~~~\n\n命令执行成功后会在 gitlab 容器目录 /var/opt/gitlab/backups 生产文件\n\n# 数据恢复\n\n> 确定gitlab版本是否一致\n>\n> 确保将备份备份文件放在 /var/opt/gitlab/backups目录下\n\n~~~\n# 停止相关数据连接服务\ngitlab-ctl stop unicorn\ngitlab-ctl stop sidekiq\n# 验证是全部停止\ngitlab-ctl status\n\n#恢复数据\ngitlab-rake gitlab:backup:restore BACKUP=1549850985_2019_02_11_11.4.5\n# 启动Gitlab\ngitlab-ctl start\n~~~\n\n# 汉化\n\n> https://gitlab.com/xhang/gitlab\n>\n> 确定版本之后在进行操作\n\n~~~\n# 确定安装的版本\ncat /opt/gitlab/embedded/service/gitlab-rails/VERSION\n\n# 下载汉化包\nwget https://gitlab.com/xhang/gitlab/-/archive/v12.3.5-zh/gitlab-v12.3.5-zh.tar.gz\n# 解压汉化包\ntar -xvf gitlab-v12.3.5-zh.tar.gz\n# 将汉化文件覆盖掉原文件\ncp -rf gitlab-v12.3.5-zh/* /opt/gitlab/embedded/service/gitlab-rails/\n# Docker安装需要清理临时的一些文\nrm -rf /opt/gitlab/embedded/nodes/*\n~~~","tags":["gitlab"],"categories":["docker"]},{"title":"docker环境下solr使用记录","url":"/2020/11/21/docker/solr/","content":"\n\n# 安装solr并创建core\n\n## 下载指定solr版本\nhttps://hub.docker.com/_/solr?tab=tags\n\n~~~\ndocker pull solr:6.6.6\n~~~\n\n## 运行\n~~~\ndocker run --name solr -p 8983:8983 -d solr\n~~~\n\n## 创建 solr 的 core\n访问 `http://localhost:8983/solr/#/~cores/new_core` 点击 `Add Core`，输入`name,instanceDir`，这时候会弹出\n\n~~~\nError CREATEing SolrCore 'new_core': Unable to create core [new_core] Caused by: Can't find resource 'solrconfig.xml' in classpath or '/opt/solr/server/solr/new_core'\n~~~\n\n解决方案：将默认的配置信息拷贝到new_core目录下\n\n~~~\ndocker exec -d solr mkdir -p  /opt/solr/server/solr/new_core\ndocker exec -d solr cp -r /opt/solr/server/solr/configsets/sample_techproducts_configs/conf/   /opt/solr/server/solr/new_core\n~~~\n\n## 重启镜像\n~~~\ndocker restart solr\n~~~\n\n# mysql数据导入到solr中\n\n## 准备条件\n~~~\ndocker exec -d solr  wget  -P /opt/solr/server/solr-webapp/webapp/WEB-INF/lib  https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.9/mysql-connector-java-5.1.9.jar\n\ndocker exec -d solr  cp  /opt/solr/dist/solr-dataimporthandler-6.6.6.jar  /opt/solr/server/solr-webapp/webapp/WEB-INF/lib\n~~~\n\n## 修改配置文件\n\n~~~\ndocker cp solr:/opt/solr/server/solr/new_core/conf/solrconfig.xml .\nvim solrconfig.xml\n~~~\n\n在`/opt/solr/server/solr/new_core/solrconfig.xml` 的`<config></config>`标签里添加下面内容\n\n~~~\n<requestHandler name=\"/dataimport\" class=\"org.apache.solr.handler.dataimport.DataImportHandler\">\n    <lst name=\"defaults\">\n        <str name=\"config\">data-config.xml</str>\n    </lst>\n</requestHandler>\n~~~\n\n添加完成之后\n~~~\ndocker cp solrconfig.xml solr:/opt/solr/server/solr/new_core/conf/solrconfig.xml\n~~~\n\n在同一个目录下面新建一个 data-config.xml 并写入下面内容，这里 column 是指数据库中的列明，name 是指solr中显示的名称\n\n~~~\n<dataConfig>\n    <dataSource name=\"user\" type=\"JdbcDataSource\" driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/hexo\" user=\"root\" password=\"123456\"/>\n    <document>\n        <entity name=\"user\"  query=\"select * from user\"  dataSource=\"source\" >\n            <field column=\"db_name\" name=\"name\" />\n            <field column=\"db_password\" name=\"password\" />\n        </entity>\n    </document>\n</dataConfig>\n~~~\n\n我是在宿主进行编辑需要拷贝到容器中\n\n~~~\ndocker cp data-config.xml solr:/opt/solr/server/solr/new_core/conf/\n~~~\n\n## mysql同步最后一步\n\n访问 `http://localhost:8983/solr/#/new_core/schema` \n点击 `Add Field`:\n在 `db_name`输入`db_name` 在`field type`选择`string`,\n在 `db_name`输入`db_password` 在`field type`选择`string`\n\n## 数据点击同步\n\n访问`http://localhost:8983/solr/#/new_core/dataimport//dataimport` \n执行 `Execute`","tags":["solr"],"categories":["docker"]},{"title":"gitlab&gitlab-runner","url":"/2020/11/21/git/gitlab-gitlab-runner/","content":"\n\n## yum 安装gitlab\n\nhttps://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/\n\n~~~\nwget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-13.4.6-ce.0.el7.x86_64.rpm\n\nrpm -ivh gitlab-ce-13.4.6-ce.0.el7.x86_64.rpm\n\n修改配置文件\nvim /etc/gitlab.rb\n//重新加载配置文件\ngitlab-ctl reconfigure\n\n//服务控制\ngitlab-ctl start\ngitlab-ctl status\ngitlab-ctl stop\n~~~\n\n## docker 安装gitlab\n\n~~~\nmkdir -p /data/gitlab-ce/etc  /data/gitlab-ce/logs  /data/gitlab-ce/data\n\n\ndocker run -d -p 8080:80 -p 443:443 -p 222:22 --name gitlab --restart always\n-v /data/gitlab-ce/etc:/etc/gitlab\n-v /data/gitlab-ce/logs:/var/logs/gitlab\n-v /data/gitlab-ce/data:/var/opt/gitlab\ngitlab/gitlab-ce\n\ndocker exec -it gitlab bash\nvim /etc/gitlab.rb\ngitlab-ctl reconfigure\n\ndocker start gitlab\ndocker stop gitlanb\ndocker rm gitlab\n~~~\n\n## yum 安装 gitlab-runner\t\n\nhttps://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/\n\n~~~\nwget https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/gitlab-runner-13.4.1-1.x86_64.rpm\nrpm -ivh gitlab-runner-13.4.1-1.x86_64.rpm\nsystemctl start gitlab-runner\n~~~\n\n## docker安装gitlab-runner\n\n~~~\ndocker pull gitlab/gitlab-runner:v13.4.1\n\nmkdir -p /data/gitlab-runner/etc\n\ndocker run -d --name gitlab-runner --restart always -v /data/gitlab-runner/etc:/etc/gitlab-runner gitlab/gitlab-runner:v13.4.1\n~~~","tags":["gitlab","centos"],"categories":["运维"]},{"title":"nginx反向代理配置文件","url":"/2020/11/20/soft/nginx-location-proxy/","content":"\n## nginx反向代理配置\n\n\n~~~~\nserver {\n  listen 80;\n  server_name proxy.domain.com;\n  gzip on;\n  error_log logs/proxy.log;\n  location / {\n    proxy_pass http://localhost:4000;\n    proxy_redirect default;\n    proxy_set_header Host $host; \n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header REMOTE-HOST $remote_addr;\n  }\n}\n~~~~\n\n","tags":["nginx","反向代理"],"categories":["运维"]},{"title":"centos安装OpenResty api 网关 Orange","url":"/2020/08/20/soft/openresty-install/","content":"\n\nOpenResty api网关设计，主要涉及api网关介绍、openresty api网关 请求路由（路由判断、路由重写、服务判断、限流）、授权验证（统一认证）、动态Upstream 以及这三部分理论简单实现的Api网关和Api网关admin。\n\n## 安装依赖\n\n```\nyum -y install libuuid-devel pcre-devel openssl-devel gcc-c++ wget perl-Time-HiRes perl-Digest-MD5\n```\n\n## openresty安装\n\n### 编译安装\n\nhttps://openresty.org/cn/download.html\n\n~~~\nwget https://openresty.org/download/openresty-1.13.6.1.tar.gz\ntar xf openresty-1.13.6.1.tar.gz \ncd openresty-1.13.6.1\n./configure  --prefix=/usr/local/openresty --with-http_stub_status_module --with-http_v2_module --with-http_ssl_module\ngmake && gmake install\n~~~\n\n### apt安装\nhttps://openresty.org/cn/linux-packages.html\n~~~\napt install --no-install-recommends wget gnupg ca-certificates\nwget -O - https://openresty.org/package/pubkey.gpg | sudo apt-key add -\nsudo add-apt-repository -y \"deb http://openresty.org/package/ubuntu $(lsb_release -sc) main\"\napt update\napt install -y openresty\n~~~\n\n\n\n## luarocks安装\nhttps://luarocks.org/\n~~~\nwget https://luarocks.org/releases/luarocks-2.4.1.tar.gz\ncd luarocks-2.4.1/\n./configure --prefix=/usr/local/openresty/luajit \\\n    --with-lua=/usr/local/openresty/luajit/ \\\n    --lua-suffix=jit \\\n    --with-lua-include=/usr/local/openresty/luajit/include/luajit-2.1\nmake build\n# 安装需要root权限\nsudo make install\n~~~\n## 环境变量设置\n\n~~~\ncat /etc/profile.d/openresty.sh \nexport OPENRESTY_HOME=/usr/local/openresty\nexport NGINX_HOME=$OPENRESTY_HOME/nginx\nexport PATH=$OPENRESTY_HOME/bin:$NGINX_HOME/sbin:$PATH\nsource /etc/profile\n~~~\n\n## mariadb安装\n\nhttps://downloads.mariadb.org/mariadb/repositories/\n\n~~~\nrpm -e mysql-*\nrpm -qa | grep mariadb\nyum remove mysql mysql-server mysql-libs compat-mysql51\nvi /etc/yum.repos.d/MariaDB.repo\n \n# MariaDB 10.4 CentOS repository list - created 2019-09-28 03:16 UTC\n# http://downloads.mariadb.org/mariadb/repositories/\n[mariadb]\nname = MariaDB\nbaseurl = http://yum.mariadb.org/10.4/centos7-amd64\ngpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB\ngpgcheck=1\nyum -y install MariaDB-server\n \nmysql_secure_installation\n首先是设置密码，会提示先输入密码\n \nEnter current password for root (enter for none):<–初次运行直接回车\nSet root password? [Y/n] <– 是否设置root用户密码，输入y并回车或直接回车\nNew password: <– 设置root用户的密码\nRe-enter new password: <– 再输入一次你设置的密码\nRemove anonymous users? [Y/n] <– 是否删除匿名用户，回车\nDisallow root login remotely? [Y/n] <–是否禁止root远程登录,回车（后面授权配置）\nRemove test database and access to it? [Y/n] <– 是否删除test数据库，回车 \nReload privilege tables now? [Y/n] <– 是否重新加载权限表，回车\n \n \nmysql -uroot -p\nCREATE USER 'orange'@'%' IDENTIFIED BY 'orange';\n \nGRANT ALL PRIVILEGES ON orange.* TO 'orange'@'%';\nFLUSH PRIVILEGES;\n~~~\n\n## 安装lor\n\n~~~\nyum install -y git\ngit clone https://github.com/sumory/lor.git\ncd lor\nmake install\n~~~\n\n## 启动并配置 orange 服务\n\nhttps://github.com/orlabs/orange/blob/master/README_zh.md\n\n```\nservice iptables stop\nchkconfig iptables off\ngit clone https://github.com/sumory/orange.git\ncd orange\n// orange 根目录  \nluarocks install luafilesystem\nluarocks install luasocket\nluarocks install lrandom\n// 安装 orange 依赖包  \nopm --install-dir=./ get zhangbao0325/orangelib  \n//配置文件\ncd conf\ncp orange.conf.example orange.conf\ncp nginx.conf.example nginx.conf\ncd install/\nmysql -u orange -porange -h 127.0.0.1  orange < orange-v0.6.2.sql\n```","tags":["nginx","openresty","orange"],"categories":["运维"]},{"title":"mysql分表","url":"/2020/08/01/data/mysql-sub-table/","content":"\n\n\n> 《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。\n\n\n# 分表的方法\n\n- 中间件方式。如 mysql cluster ，mysql proxy，mysql replication，drdb等等\n- 业务逻辑去分，如果订单按照日期，订单一个用户一张订单表，hash方式等等\n- merge存储引擎来实现分表\n\n# 分表实战\n\n接下来是结合业务逻辑和merge去实现分表实战\n\ncode_1表创建插入数据\n~~~\n\nCREATE TABLE `mm_1` (\n\t`full_code` CHAR (10) NOT NULL,\n\tPRIMARY KEY (`full_code`)\n)ENGINE=MyISAM  DEFAULT CHARACTER SET=utf8;\nINSERT INTO mm_1 VALUES (1), (2), (3);\n~~~\n\ncode_2表创建插入数据\n\n~~~~\nCREATE TABLE `mm_2` (\n\t`full_code` CHAR (10) NOT NULL,\n\tPRIMARY KEY (`full_code`)\n)ENGINE=MyISAM  DEFAULT CHARACTER SET=utf8;\n\n\nINSERT INTO mm_2 VALUES (4), (5), (6);\n~~~~\n\n使用merge创建合表数据\n\n~~~\ncreate table if not exists mm(\n\t`full_code` CHAR (10) NOT NULL,\n\tindex(full_code)\n)engine = merge union=(mm_1,mm_2) insert_method = last auto_increment=1 default charset=utf8;\n~~~\n\n","tags":["mysql","分库分表"],"categories":["数据库"]},{"title":"Mysql设计与开发规范","url":"/2020/07/29/data/mysql-dev-specification/","content":"\n> \n> 本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障\n> \n\n\n## 设计规范\n\n> \n> 以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低\n> \n> 对于不满足【高危】和【强制】两个级别的设计，DBA有权利强制打回要求修改\n> \n\n### 库名\n\n1.【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量体现join的关系，如user表和user_login表\n\n2.【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的库名尽量使用统一前缀\n\n3.【强制】一般分库名称命名格式是库通配名_编号，编号从0开始递增，比如wenda_001以时间进行分库的名称格式是“库通配名_时间”\n\n4.【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：`create database db1 default character set utf8;`\n\n###  表结构\n\n1.【强制】表必须有主键，且设置id为自增主键\n\n2.【强制】表禁止使用外键，如果要保证完整下，应由程序端实现，外键使表之间相互耦合，影响update、delete等性能，有可能造成死锁，高并发环境下容易导致数据库性能瓶颈\n\n3.【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。如表名过长可以采用缩写等方式\n\n4.【强制】创建表时必须显式指定字符集为utf8或utf8mb4\n\n5.【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB/MyISAM/Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB\n\n6.【强制】建表必须有comment，表级别和字段级别都要有comment\n\n7.【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint（为了以后延展性，这里要求新建表统一为bigint），且为auto_increment(2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降\n\n8.【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段create_time和最后更新时间字段update_time，便于查问题\n\n9.【建议】表中所有字段必须都是NOT NULL default 默认值 属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差以及索引失效等问题\n\n10.【建议】建议对表里的blob、text等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select\n\n11.【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如user_name属性在user_account，user_login_log等表里冗余一份，减少join查询\n\n12.【强制】中间表用于保留中间结果集，名称必须以tmp_开头。备份表用于备份或抓取源表快照，名称必须以bak_开头。中间表和备份表定期清理\n\n13.【强制】对于线上执行DDL变更，必须经过DBA审核，并由DBA在业务低峰期执行\n\n### 列数据类型优化\n\n1.【建议】表中的自增列（auto_increment属性），推荐使用bigint类型。因为无符号int存储范围为-2147483648~2147483647（大约21亿左右），溢出后会导致报错\n\n2.【建议】业务中选择性很少的状态status、类型type等字段推荐使用tinytint或者smallint类型节省存储空\n\n3.【建议】业务中IP地址字段推荐使用int类型，不推荐用char(15)。因为int只占4字节，可以用如下函数相互转换，而char(15)占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。 SQL：select inet_aton('192.168.2.12'); select inet_ntoa(3232236044); PHP: ip2long(‘192.168.2.12’); long2ip(3530427185);\n\n4.【建议】不推荐使用enum，set。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用tinyint或smallint\n\n5.【建议】不推荐使用blob，text等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段\n\n6.【建议】存储金钱的字段，建议用int，程序端乘以100和除以100进行存取。或者用decimal类型，而不要用double\n\n7.【建议】文本数据尽量用varchar存储。因为varchar是变长存储，比char更省空间。MySQL server层规定一行所有文本最多存65535字节\n\n8.【建议】时间类型尽量选取datetime。而timestamp虽然占用空间少，但是有时间范围为1970-01-01 00:00:01到2038-01-01 00:00:00的问题\n\n###  索引设计\n\n1.【强制】InnoDB表必须主键为id int/bigint auto_increment,且主键值禁止被更新\n\n2.【建议】唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，一律使用小写格式，以字段的名称或缩写作为后缀\n\n3.【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引\n\n4.【强制】单个索引中每个索引记录的长度不能超过64KB\n\n5.【建议】单个表上的索引个数不能超过5个\n\n6.【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列userid的区分度可由select count(distinct userid)计算出来\n\n7.【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高\n\n8.【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除\n\n###  分库分表、分区表\n\n1.【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列\n\n2.【强制】单个分区表中的分区（包括子分区）个数不能超过1024\n\n3.【强制】上线前RD或者DBA必须指定分区表的创建、清理策略\n\n4.【强制】访问分区表的SQL必须包含分区键\n\n5.【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个\n\n6.【强制】对于分区表执行alter table操作，必须在业务低峰期执行\n\n7.【强制】采用分库策略的，库的数量不能超过1024\n\n8.【强制】采用分表策略的，表的数量不能超过4096\n\n9.【建议】单个分表建议不超过500W行，这样才能保证数据查询性能更佳\n\n10.【建议】水平分表尽量用取模方式，并预留出足够的buffer，以免日后需要重新拆分和迁移，日志、报表类数据建议采用日期进行分表\n\n### 字符集\n\n1.【强制】数据库本身库、表、列所有字符集必须保持一致，为utf8或utf8mb4\n\n2.【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为utf8\n\n\n\n## SQL编写\n\n### DML语句\n\n1.【强制】SELECT语句必须指定具体字段名称，禁止写成*。因为select *会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但程序端没有来得及更新的话，系统会报错\n\n2.【强制】insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上\n\n3.【建议】insert into…values(XX),(XX),(XX)…。这里XX的值不要超过500个。值过多虽然上线很很快，但会引起主从同步延迟\n\n4.【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在3个以内。因为union all不需要去重，节省数据库资源，提高性能\n\n5.【建议】in值列表限制在500以内。例如select… where userid in(….500个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询\n\n6.【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次\n\n7.【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步中断\n\n8.【强制】写入和事务发往主库，只读SQL发往从库，即程序端实现读写分离\n\n9.【强制】DML语句必须有where条件，且使用索引查找\n\n10.【强制】生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等。因为hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，我们要尽量让MySQL优化器自己选择执行计划\n\n11.【强制】where条件里等号左右字段类型必须一致，否则无法利用索引\n\n12.【建议】SELECT|UPDATE|DELETE|REPLACE要有WHERE子句，且WHERE子句的条件必需使用索引查找\n\n13.【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引\n\n14.【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，如果要使用like，请使用like ‘xxxx%’的方式，必须有其他等值或范围查询条件，否则无法利用索引\n\n15.【建议】索引列不要使用函数或表达式，否则无法利用索引。如where length(name)='Admin'或where user_id+2=10023\n\n16.【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)\n\n17.【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select a,b,c from t1 limit 10000,20;优化为: select a,b,c from t1 where id>10000 limit 20;\n\n### 多表连接\n\n1.【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础\n\n2.【强制】禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…\n\n3.【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询\n\n4.【建议】线上环境，多表join不要超过3个表\n\n5.【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如select a from db1.table1 alias1 where …\n\n6.【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表\n\n### 事务\n\n1.【建议】事务中INSERT|UPDATE|DELETE|REPLACE语句操作的行数控制在1000以内，以及WHERE子句中IN列表的传参个数控制在500以内\n\n2.【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值1-2秒\n\n3.【建议】对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内\n\n4.【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为repeatable-read\n\n5.【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题\n\n6.【建议】事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁\n\n7.【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长\n\n8.【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库\n\n### 排序和分组\n\n1.【建议】减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的\n\n2.【建议】order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b)\n\n3.【建议】包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢\n\n### 线上禁止使用的SQL语句\n\n1.【高危】禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。如果是非row格式的binlog格式，会导致主从不一致，导致数据错乱。建议加上order by PK\n\n2.【高危】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下\n\n3.【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现\n\n4.【建议】禁用insert into …on duplicate key update…、replace into等语句，在高并发环境下，极容易导致死锁\n\n5.【强制】禁止联表更新语句，如update t1,t2 where t1.id=t2.id…","tags":["mysql","规范"],"categories":["数据库"]},{"title":"宝塔linux面板命令大全","url":"/2020/07/07/soft/liunx-centos-bt/","content":"\n\n## 安装宝塔\n\nCentos安装脚本\n\n```\nyum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh\n```\n\nUbuntu/Deepin安装脚本\n\n```\nwget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh\n```\n\nDebian安装脚本\n\n```\nwget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh && bash install.sh\n```\n\nFedora安装脚本\n\n```\nwget -O install.sh http://download.bt.cn/install/install_6.0.sh && bash install.sh\n```\n\n\n\n## 管理宝塔\n\n宝塔工具箱(包含下列绝大部分功能 直接ssh中执行bt命令 仅限6.x以上版本面板)\n\n```\nbt\n```\n\n停止\n\n```\n/etc/init.d/bt stop\n```\n\n启动\n\n```\n/etc/init.d/bt start\n```\n\n重启\n\n```\n/etc/init.d/bt restart\n```\n\n卸载\n\n```\n/etc/init.d/bt stop && chkconfig --del bt && rm -f /etc/init.d/bt && rm -rf /www/server/panel\n```\n\n查看当前面板端口\n\n```\ncat /www/server/panel/data/port.pl\n```\n\n修改面板端口，如要改成8881（centos 6 系统）\n\n```\necho '8881' > /www/server/panel/data/port.pl && /etc/init.d/bt restart\niptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 8881 -j ACCEPT\nservice iptables save\nservice iptables restart\n```\n\n修改面板端口，如要改成8881（centos 7 系统）\n\n```\necho '8881' > /www/server/panel/data/port.pl && /etc/init.d/bt restart\nfirewall-cmd --permanent --zone=public --add-port=8881/tcp\nfirewall-cmd --reload\n```\n\n强制修改MySQL管理(root)密码，如要改成123456\n\n```\ncd /www/server/panel && python tools.py root 123456\n```\n\n修改面板密码，如要改成123456\n\n```\ncd /www/server/panel && python tools.py panel 123456\n```\n\n查看宝塔日志\n\n```\ncat /tmp/panelBoot.pl\n```\n\n查看软件安装日志\n\n```\ncat /tmp/panelExec.log\n```\n\n站点配置文件位置\n\n```\n/www/server/panel/vhost\n```\n\n删除域名绑定面板\n\n```\nrm -f /www/server/panel/data/domain.conf\n```\n\n清理登陆限制\n\n```\nrm -f /www/server/panel/data/*.login\n```\n\n查看面板授权IP\n\n```\ncat /www/server/panel/data/limitip.conf\n```\n\n关闭访问限制\n\n```\nrm -f /www/server/panel/data/limitip.conf\n```\n\n查看许可域名\n\n```\ncat /www/server/panel/data/domain.conf\n```\n\n关闭面板SSL\n\n```\nrm -f /www/server/panel/data/ssl.pl && /etc/init.d/bt restart\n```\n\n查看面板错误日志\n\n```\ncat /tmp/panelBoot\n```\n\n查看数据库错误日志\n\n```\ncat /www/server/data/*.err\n```\n\n站点配置文件目录(nginx)\n\n```\n/www/server/panel/vhost/nginx\n```\n\n站点配置文件目录(apache)\n\n```\n/www/server/panel/vhost/apache\n```\n\n站点默认目录\n\n```\n/www/wwwroot\n```\n\n数据库备份目录\n\n```\n/www/backup/database\n```\n\n站点备份目录\n\n```\n/www/backup/site\n```\n\n站点日志\n\n```\n/www/wwwlogs\n```\n\n\n\n## Nginx服务管理\n\nnginx安装目录\n\n```\n/www/server/nginx\n```\n\n启动\n\n```\n/etc/init.d/nginx start\n```\n\n停止\n\n```\n/etc/init.d/nginx stop\n```\n\n重启\n\n```\n/etc/init.d/nginx restart\n```\n\n启载\n\n```\n/etc/init.d/nginx reload\n```\n\nnginx配置文件\n\n```\n/www/server/nginx/conf/nginx.conf\n```\n\n\n\n## Apache服务管理\n\napache安装目录\n\n```\n/www/server/httpd\n```\n\n启动\n\n```\n/etc/init.d/httpd start\n```\n\n停止\n\n```\n/etc/init.d/httpd stop\n```\n\n重启\n\n```\n/etc/init.d/httpd restart\n```\n\n启载\n\n```\n/etc/init.d/httpd reload\n```\n\napache配置文件\n\n```\n/www/server/apache/conf/httpd.conf\n```\n\n\n\n## MySQL服务管理\n\nmysql安装目录\n\n```\n/www/server/mysql\n```\n\nphpmyadmin安装目录\n\n```\n/www/server/phpmyadmin\n```\n\n数据存储目录\n\n```\n/www/server/data\n```\n\n启动\n\n```\n/etc/init.d/mysqld start\n```\n\n停止\n\n```\n/etc/init.d/mysqld stop\n```\n\n重启\n\n```\n/etc/init.d/mysqld restart\n```\n\n启载\n\n```\n/etc/init.d/mysqld reload\n```\n\nmysql配置文件\n\n```\n/etc/my.cnf\n```\n\n\n\n## FTP服务管理\n\nftp安装目录\n\n```\n/www/server/pure-ftpd\n```\n\n启动\n\n```\n/etc/init.d/pure-ftpd start\n```\n\n停止\n\n```\n/etc/init.d/pure-ftpd stop\n```\n\n重启\n\n```\n/etc/init.d/pure-ftpd restart\n```\n\nftp配置文件\n\n```\n/www/server/pure-ftpd/etc/pure-ftpd.conf\n```\n\n\n\n## PHP服务管理\n\nphp安装目录\n\n```\n/www/server/php\n```\n\n启动(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 start)\n\n```\n/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} start\n```\n\n停止(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 stop)\n\n```\n/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} stop\n```\n\n重启(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 restart)\n\n```\n/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} restart\n```\n\n启载(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 reload)\n\n```\n/etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} reload\n```\n\n配置文件(请根据安装PHP版本号做更改，例如：/www/server/php/52/etc/php.ini)\n\n```\n/www/server/php/{52|53|54|55|56|70|71|72|73|74}/etc/php.ini\n```\n\n\n\n## Redis服务管理\n\nredis安装目录\n\n```\n/www/server/redis\n```\n\n启动\n\n```\n/etc/init.d/redis start\n```\n\n停止\n\n```\n/etc/init.d/redis stop\n```\n\nredis配置文件\n\n```\n/www/server/redis/redis.conf\n```\n\n\n\n## Memcached服务管理\n\nmemcached安装目录\n\n```\n/usr/local/memcached\n```\n\n启动\n\n```\n/etc/init.d/memcached start\n```\n\n停止\n\n```\n/etc/init.d/memcached stop\n```\n\n重启\n\n```\n/etc/init.d/memcached restart\n```\n\n启载\n\n```\n/etc/init.d/memcached reload\n```","tags":["宝塔"],"categories":["运维"]},{"title":"thinkphp+mysql无线分类从需求到代码演示","url":"/2020/06/28/php/thinkphp-mysql-tree/","content":"\n\n- 栏目无线分类\n- 无线分销（技术是无罪的，商业请使用三级分销）\n- 省市县联动\n\n\n在我们做任何系统中离不开无线分类这个分类，同样也是老掉牙的问题。为什么又拿来说呢？归功到底还是博客的内容太少。\n\n# 应用场景\n\n- 栏目无线分类\n- 无线分销（技术是无罪的，商业请使用三级分销）\n- 省市县联动\n\n# 需求决定代码\n\n无论你做任何系统都是有需求，你才去研究；没有需求，就是伪需求，自己玩玩就好。无论什么样的 需求都离不开sql和逻辑判断，下面的需求主要是围绕thinkphp+mysql来实现案例\n\n## 表结构\n\n| 字段      | 类型        | NULL | 默认 | 注释   |\n| --------- | ----------- | ---- | ---- | ------ |\n| id        | int(10)     | 否   |      | 自增ID |\n| parent_id | int(10)     | 否   | 0    | 上级ID |\n| name      | varchar(50) | 否   |      | 名称   |\n| order     | int(10)     | 否   | 0    | 排序   |\n\n## 根据子类`ID`获取所有父类\n\n~~~\nfunction get_user_father_array($uid,$array=[]){\n    $user =  \\think\\Db::name('users')->where('id',$uid)->find();\n    $array[] = $user;\n    if($user['parent_id']){\n        return get_user_father_array($user['parent_id'],$array);\n    }\n    return $array;\n}\n~~~\n\n## 根据父类查所有子类\n\n~~~\n// sql 获取子类数据\nfunction get_child_user_sql($uid){\n    $sql = \"SELECT * FROM  \".\n    \"(SELECT id,parent_id FROM users ORDER BY parent_id,id) as t,(SELECT @pv := {$uid}) as pv \".\n    \"WHERE find_in_set(parent_id, @pv) AND LENGTH(@pv := concat(@pv, ',', id))\";\n    return \\think\\Db::query($sql);\n}\n~~~\n\n## 点对点是否在一个枝干上\n\n>XYZ的上级为0，也就是说是顶级树干\n>\n>X 推荐了 B 和 C\n>\n>B 推荐XB1、XB2、XB3、.....XBn\n>\n>C 推荐XC1、XC2、XC3、......XCn\n>\n>问： XB1和XC1 和是否在一枝干上\n>\n>答：某个项目告诉我不是，为什么？\n>\n>XB1的分枝干包含 X、B\n>\n>XC1的分枝干包含 X、C\n>\n>不难看出来 他们的上级是不同的，所有不是，所以我们要实现这个需求，就是通过路径来判断\n\n实现步骤\n\n1. 先找到XB1的所有父类连接成字符串\n2. 然后找到XC1的所有父类连接成字符串\n3. 比较2个字符串是否包含或被包含\n\n代码实现一下\n\n~~~\n$left = array_column(get_user_father_array($left_uid),'id');\n$leftstr = implode(\",\",$left);\n\n$right =  array_column(get_user_father_array(right_uid),'id');\n$rightstr = implode(\",\",$right);\n\nfunction str2strpos($str1 ,$str2){\n    $str1len = strlen($str1);\n    $str2len = strlen($str2);\n    if($str1len  >  $str2len && strpos($str1,$str2) !== false){\n        return true;\n    }\n    if($str1len  <  $str2len && strpos($str2,$str1) !== false){\n        return true;\n    }\n    return false;\n}\n\nif(str2strpos($leftstr,$rightstr)){\n\techo \"在同一枝干上\"\n}\n\n~~~\n\n\n","tags":["mysql","thinkphp"],"categories":["php"]},{"title":"软件开发人员配备与基本流程","url":"/2020/06/27/idea/product-development-personnel-flow/","content":"\n## 技术团队人员配备\n> - PM：产品经理\n> - PM：项目经理\n> - UE：交互设计师，负责页面布局、交互的设计，不负责视图的细节。\n> - UI：视觉设计师，交互确定之后，设计页面样式。注意，很多情况下，UE 和 UI 是一个人。\n> - RD：后端开发人员。\n> - CRD：客户端开发人员，安卓和 ios 都是。\n> - FE：前端开发人员。\n> - QA：测试人员。\n> - OP：服务器运维人员，一般负责审批上线单。\n> \n\n\n## 一、产品爸爸提需求\n\n产品爸爸们通过对用户的分析和反馈，还有多年行业经验，以及同行之间产品分析，YY出了很多的产品需求，做好这些需求设计之后，就得他们的产品总监和其他产品内部评审这份设计。产品总监认可之后的需求。产品爸爸们就会拿着需求来折磨我们这些程序员了。\n\n## 二、需求评审\n\n产品爸爸拉上各种开发人员，比如APP、Java后端、前端、UE交互、UI设计、QA测试等等，进行这个需求的评审。每个人对这个需求各抒己见，哪些地方不合理，哪些地方这期不适合开发等等，产品会做会议记录邮件，然后更改需求，如果改动较小，就以邮件形式通知各位开发们，如果改动较大，还需进行二次评审。\n\n## 三、技术方案设计\n\n产品爸爸发话了，那就得干啊，然后后端开始做技术详细设计，UE做交互稿，QA做测试用例，UI根据UE的交互稿做页面设计。\n\n后端的技术方案设计非常重要，这一步其实是对产品业务的一个梳理过程，让你能够更加了解业务需求，在设计的过程中能够及时发现哪里不合理，哪里有风险，哪里用什么样的技术栈等等。能让你在写代码的时候，速度又快，质量又高的完成开发工作。\n\n## 四、技术设计评审\n\n 这里有几个方面需要评审，UE的交互稿，QA的测试用例，这个是需要全体人员进行参加的。而后端的技术方案设计，只需要技术leader和一些组内技术人员参加评审即可，因为其他人参加也听不懂嘛。这个技术评审能让你学到很多东西，对业务的风险把控，技术栈的选择等等，leader会针对这些给你提一些专业性的意见。所以技术方案一定要做好，这也是领导了解你的一个过程。你每次都做的很详细，很靠谱，那以后有好项目领导肯定会优先考虑交给你做。\n\n## 五、排期\n\n进入开发前要先进行工作量排期，就是工作计划安排，今天干什么，明天干什么，这个排期非常重要，排期有时候能直接影响你是996还是965， 因为严格控制排期，按照排期计划走，能让你比较从容的开发，各个环节有条不紊的进行。但是如果情况特殊，就是有好几个需求并行开发，时间都特别紧急，那排期也救不了你了。比如到了双十一大促，618大促，那都是很忙的时候。\n\n## 六、 开发\n\n以上都搞完之后就可以进入真正的开发了，首先前后端要进行mock接口定义， 提供一些mock数据给前端等等，因为目前都是前后端分离的开发模式，双方定义好接口交互方式，就可以各自干活了，相当于并行开发。这样的工作效率非常高，谁也不用等谁。双方开发完之后就进入联调，前端切换成后端的真实接口，然后双方进行自测。\n\n## 七、 code review\n\n 开发工作全部完毕之后，进入代码review阶段，这个时候一般是叫上leader和组内的其他技术人员参加，他们会根据业务背景，以及你的代码实现提出一些意见，比如这里用工厂设计模式比较好，或者这里的代码逻辑可以在优化一下等等，这个阶段也是一个非常好的学习过程，你写代码都是按照自己的知识储备和风格去写，别人从他们自己的知识储备来看你的代码，会提出不同的思路，这样你就能学习他人的一些知识。\n\n## 八、测试\n\n 以上都做完之后就进入测试阶段了，写个提测邮件给测试爸爸们，心里祈祷着千万别测试bug，结果测试爸爸们立马给你发了一条钉钉消息：英雄来干了这碗bug。测试一般分为测试环境和沙箱环境，测试环境又细分了很多子环境，比如stable环境、betaa环境、betab、betac、betad环境等，为什么要搞这么多测试环境呢，因为可能会有很多需求并行在开发，就需要很多环境来测试这些需求。一般中小型公司就没这么多环境。那么沙箱环境又是什么呢，就是模拟线上环境，几乎和线上环境是一模一样的，就是为了在上线前能够保证不出任何问题，因为上线是一件特别神圣的事，一旦出问题，你就背锅吧。测试完成后产品进行验收，产品爸爸满意了，这个时候就可以上线了。\n\n## 九、上线\n\n上线是一件非常神圣又庄严的事情，一般老哥都会先沐浴更衣之后在执行上线，因为一旦上线出问题，那就没时间洗脸洗澡了。上线前要做很多准备工作，列出一份上线清单，把上线涉及的影响点全部列出来给QA。比如是否有数据库工单，是否申请了ES索引等等，集群上线顺序，出现问题回滚顺序等等，万事俱备之后，就开始神圣的上线了。\n\n## 十、上线后回测\n\n 不要以为上完线就万事大吉可以开溜了，QA还需要回测此次版本涉及的功能点，这个时候就得祈祷了，千万别有什么问题，要不今晚又回不去家了，如果上线出现问题不能短时间解决，最好的方法就是回滚，回滚到上一个可用版本。如果没有任何问题，这个时候产品爸爸就要登场了，来验收你的劳动成果，产品爸爸点头了就可以收拾东西回家睡觉了。","tags":["技术团队搭建","开发流程"],"categories":["项目管理"]},{"title":"xdebug+webgrind对php5.6做性能分析环境搭建","url":"/2020/06/27/php/xdebug-webgrind/","content":"\n\n# python3安装\n\n~~~\nwget https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tar.xz\nmkdir -p /usr/local/code/python3\ntar -xvf Python-3.7.7.tar.xz -C /usr/local/code\ncd /usr/local/code/Python-3.7.7/ && ./configure prefix=/usr/local/python3\nmake && make install\nln -s /usr/local/python3/bin/python3 /usr/bin/python3\n~~~\n\n# dot命令安装\n\n~~~\nyum -y install graphviz\n~~~\n\n# xdebug安装\n\n> https://xdebug.org/docs/install\n\n~~~\npecl install xdebug\n\nmkdir -p /tmp/xdebug\nchown -R www:www /tmp/xdebug/\n\n//修改php.ini\nzend_extension=xdebug.so\n[xdebug]\nxdebug.profiler_append=0\nxdebug.profiler_output_name=\"cachegrind.out.%R%u\"\nxdebug.profiler_enable=On\nxdebug.profiler_output_dir=\"/tmp/xdebug/\"\nxdebug.profiler_enable_trigger=On\n\n~~~\n\n# webgrind可视化界面\n\n~~~\ngit clone https://github.com/jokkedk/webgrind.git\n\n//修改config.php修改成\nstatic $storageDir = '/tmp/xdebug/';\nstatic $profilerDir = '/tmp/xdebug/';\n~~~\n\n","tags":["xdebug","webgrind"],"categories":["php"]},{"title":"压测AB以及监控工具详解","url":"/2020/06/26/soft/ab/","content":"\n\n# 客户端压测工具AB\n\n~~~\nab(选项)(参数) 地址\n~~~\n\n>\n> -A：指定连接服务器的基本的认证凭据；\n> -c：指定一次向服务器发出请求数；\n> -C：添加cookie；\n> -g：将测试结果输出为“gnuolot”文件；\n> -h：显示帮助信息；\n> -H：为请求追加一个额外的头；\n> -i：使用“head”请求方式；\n> -k：激活HTTP中的“keepAlive”特性；\n> -n：指定测试会话使用的请求数；\n> -p：指定包含数据的文件；\n> -q：不显示进度百分比；\n> -T：使用POST数据时，设置内容类型头；\n> -v：设置详细模式等级；\n> -w：以HTML表格方式打印结果；\n> -x：以表格方式输出时，设置表格的属性；\n> -X：使用指定的代理服务器发送请求；\n> -y：以表格方式输出时，设置表格属性。\n>\n\n\n\n~~~\nab -c 200 -n 200 http://127.0.0.1:3000/\n~~~\n\n运行结果\n\n~~~\nThis is ApacheBench, Version 2.3 <$Revision: 1748469 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking 127.0.0.1 (be patient)\nCompleted 100 requests\nCompleted 200 requests\nFinished 200 requests\n\n\nServer Software:\nServer Hostname:        127.0.0.1       #域名\nServer Port:            3000            #请求端口号\n\nDocument Path:          /               #文件路径\nDocument Length:        11 bytes        #页面字节数\n\nConcurrency Level:      200             #请求的并发数\nTime taken for tests:   0.192 seconds   #总访问时间\nComplete requests:      200             #请求成功数量\nFailed requests:        0               #请求失败数量\nTotal transferred:      29400 bytes     #请求总数据大小（包括header头信息）\nHTML transferred:       2200 bytes      #html页面实际总字节数\nRequests per second:    1041.68 [#/sec] (mean)   #每秒多少请求\nTime per request:       191.998 [ms] (mean)      #用户平均请求等待时间 \nTime per request:       0.960 [ms] (mean, across all concurrent requests)    # 服务器平均处理时间\nTransfer rate:          149.54 [Kbytes/sec] received    #每秒获取的数据长度\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.3      0       1\nProcessing:     9   94  49.2     95     179\nWaiting:        3   90  51.0     91     178\nTotal:          9   95  49.2     95     179\n\nPercentage of the requests served within a certain time (ms)\n  50%     95   #50%用户请求在95ms内返回\n  66%    122   #66%用户请求在122ms内返回\n  75%    138   #75%用户请求在138ms内返回\n  80%    146   #80%用户请求在146ms内返回\n  90%    163   #90%用户请求在163ms内返回\n  95%    171   #95%用户请求在171ms内返回\n  98%    176   #98%用户请求在176ms内返回\n  99%    178   #99%用户请求在178ms内返回\n 100%    179 (longest request)\n~~~\n> `Requests per second:    1041.68 [#/sec] (mean)` （吞吐率，简称QPS）每秒服务器承载请求量是多少，以上测试数据表示每秒可以处理 `1041.68`并发量，也就是说有 1100个用户去访问这个服务器，这个服务器是可以抗的住\n> `Time per request:       191.998 [ms] (mean)` 每次请求花费多少毫秒\n> `Time per request:       0.960 [ms] (mean, across all concurrent requests)`并发情况下，0.960毫秒得到结果\n> `Transfer rate:          149.54 [Kbytes/sec] received`(吞吐量) 每秒这个服务器吞/吐的数据量是多少\n\n\n# 性能分析工具\n\n## Node自带 profile\n~~~\nnode --prof index.js\n~~~\n\n## php分析工具xdebug+webgrind\n~~~\npecl install xdebug\nhttps://github.com/jokkedk/webgrind.git\n~~~\n\n## php分析工具 xhprof\n~~~\nhttp://pecl.php.net/package/xhprof\nhttps://github.com/tideways/php-xhprof-extension\n~~~\n\n\n\n\n# 服务端监控\n\n客户端服务端也需要开启监控，检测具体问题所在\n\n## 查看cpu和内存使用率\n\n~~~\n[root@VM_0_4_centos ~]# top\ntop - 01:19:19 up 6 days, 9 min,  1 user,  load average: 0.00, 0.01, 0.05\nTasks: 122 total,   1 running, 121 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3880224 total,   235108 free,   973224 used,  2671892 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.  2615988 avail Mem \n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                              \n    1 root      20   0   43692   3692   2288 S   0.0  0.1   0:32.31 systemd  \n\n~~~\n\n> 第一行：概况\n>\n> 1. 当前时间 ` 01:19:19 `；\n> 2. 从本次开机到现在经过的时间 `up 6 days,9 min`；\n> 3. 当前有几个用户登录到该机器。`1 user`  ；\n> 4. 系统1分钟、5分钟、15分钟内的平均负载值`load average: 0.00, 0.01, 0.05`\n>\n> 第二行：进程计数（Tasks）\n>\n> 1. 进程总数`122 total`；\n> 2. 正在运行的进程数`1 running`；\n> 3. 睡眠的进程数`121 sleeping`；\n> 4. 停止的进程数`0 stopped`；\n> 5. 僵尸进程数` 0 zombie`\n>\n> 第三行：CPU使用率（%Cpu(s)）\n>\n> 1. 进程在用户空间（user）消耗的CPU时间占比，不包含调整过优先级的进程。`%Cpu(s):  0.2 us`\n> 2. 进程在内核空间（system）消耗的CPU时间占比。`0.2 sy`\n> 3. 调整过用户态优先级的（niced）进程的CPU时间占比。` 0.0 ni`\n> 4. 空闲的（idle）CPU时间占比。` 99.7 id`\n> 5. 等待（wait）I/O完成的CPU时间占比。` 0.0 wa`\n> 6. 处理硬中断（hardware interrupt）的CPU时间占比。` 0.0 hi`\n> 7. 处理软中断（software interrupt）的CPU时间占比。`0.0 si`\n> 8. 当Linux系统是在虚拟机中运行时，等待CPU资源的时间（steal time）占比。`0.0 st`\n>\n> 第四、五行：物理内存和交换空间（Mem/Swap）\n>\n> 1. 内存总量。`3880224 total`\n> 2. 空闲内存量。`235108 free`\n> 3. 使用中的内存量。` 973224 used`\n> 4. 缓存和page cache占用的内存量。` 2671892 buff/cache` \n>\n> \n>\n> 接下来就是进程详细信息\n>\n> 1.  `PID`进程ID\n> 2. `USER`进程所有者的用户名。\n> 3. `PR`从系统内核角度看的进程调度优先级。\n> 4. `NI`进程的nice值，即从用户空间角度看的进程优先级。值越低，优先级越高。\n> 5. `VIRT`进程申请使用的虚拟内存量。\n> 6. `RES`进程使用的驻留内存（即未被swap out的内存）量。\n> 7. `SHR`进程使用的共享内存量。\n> 8. `S`进程状态。R=running，S=interruptible sleeping，D=uninterruptible sleeping，T=stopped，Z=zombie。\n> 9. ` %CPU`进程在一个更新周期内占用的CPU时间比例。\n> 10. `%MEM`进程占用的物理内存比例。\n> 11. `TIME+ `进程创建后至今占用的CPU时间长度。\n> 12. `COMMAND`运行进程使用的命令。\n>\n> \n\n\n\n\n\n\n\n\n\n## iostat 查看硬盘带宽命令\n\n~~~\n[root@VM_0_4_centos ~]# yum install -y sysstat\n[root@VM_0_4_centos ~]# iostat\nLinux 3.10.0-1062.18.1.el7.x86_64 (VM_0_4_centos) \t06/27/2020 \t_x86_64_\t(2 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.35    0.00    0.20    0.09    0.00   99.35\n           \nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nvda               3.10         3.39        22.73    1758510   11783276\nvdb               1.69         5.79        14.56    3001589    7547888\nscd0              0.00         0.00         0.00        910          0\n~~~\n\n>%user：CPU处在用户模式下的时间百分比。\n>\n>%nice：CPU处在带NICE值的用户模式下的时间百分比。\n>\n>%system：CPU处在系统模式下的时间百分比。\n>\n>%iowait：CPU等待输入输出完成时间的百分比。\n>\n>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。\n>\n>%idle：CPU空闲时间百分比。\n>\n>tps：该设备每秒的传输次数\n>\n>kB_read/s：每秒从设备（drive expressed）读取的数据量；\n>\n>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；\n>\n>kB_read： 读取的总数据量；\n>\n>kB_wrtn：写入的总数量数据量；\n\n注意：\n\n> 如果%iowait的值过高，表示硬盘存在I/O瓶颈\n>\n> 如果%idle值高，表示CPU较空闲\n>\n> 如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。\n>\n> 如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。\n\n常见命令\n\n~~~\n# 每隔2秒刷新显示，且显示3次\niostat 2  3\n\n# 显示指定磁盘信息\niostat -d /dev/vdb1\n\n# 显示tty和cpu信息\niostat -t\n\n# 以M为单位显示所有信息\niostat -m\n\n# 查看设备使用率（%util）、响应时间（await）\niostat -d -x -k 1 1\n~~~","tags":["AB","压力测试"],"categories":["运维"]},{"title":"Easyswoole中实现think-template模板引擎使用","url":"/2020/06/23/php/easyswoole-think-template/","content":"\n\n五步走，在easyswoole中使用think-template模板引擎\n\n1. 安装\n\n2. 基础功能实现\n\n3. mainServerCreate函数注册初始化\n\n4. 在控制器中使用\n\n5. 模版渲染文件\n\n\n详细语言描述看官网：https://www.easyswoole.com/Cn/Components/template.html\n\n# 安装\n\n~~~\ncomposer require easyswoole/template\ncomposer require topthink/think-template\n~~~\n\n# 基础类实现\n\n`App/Providers/ThinkTpl.php`\n\n~~~\n<?php\nnamespace App\\Providers;\nuse EasySwoole\\Template\\RenderInterface;\nclass ThinkTpl implements RenderInterface\n{\n    protected $template;\n    public function __construct()\n    {\n        $this->template = new  \\think\\Template([\n            'view_path'\t=>\tEASYSWOOLE_ROOT.'/App/Views/',\n            'cache_path'\t=>\tEASYSWOOLE_ROOT.'/Temp/runtime/',\n        ]);\n    }\n    public function render(string $template, array $data = [], array $options = []): ?string\n    {\n        // TODO: Implement render() method.\n        ob_start();\n        $this->template->assign($data);\n        $this->template->fetch($template);\n        $content = ob_get_contents() ;\n        return $content;\n    }\n    public function afterRender(?string $result, string $template, array $data = [], array $options = [])\n    {\n        // TODO: Implement afterRender() method.\n    }\n\n    public function onException(\\Throwable $throwable): string\n    {\n        // TODO: Implement onException() method.\n        $msg = \"{$throwable->getMessage()} at file:{$throwable->getFile()} line:{$throwable->getLine()}\";\n        trigger_error($msg);\n        return $msg;\n    }\n}\n~~~\n\n# mainServerCreate函数注册初始化\n\n~~~\nuse EasySwoole\\Template\\Render;\nuse App\\Providers\\ThinkTpl;\n\n$render = Render::getInstance();\n$render->getConfig()->setRender(new ThinkTpl());\n$render->attachServer(ServerManager::getInstance()->getSwooleServer());\n~~~\n\n# 控制器使用\n\n~~~\n// 该方法放在控制器基类中，为以后提供方便\npublic function fetch($tpl='', $data=[]){\n    if($tpl == ''){\n    \t$tpl = $this->getActionName();\n    }\n    $this->response()->write(Render::getInstance()->render($tpl,$data));\n}\n\n//在某个控制器中的index方法\npublic function index()\n{\n\treturn $this->fetch();\n}\n~~~\n\n页面渲染`App/Views/index.html`\n\n~~~\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>easyswoole think-template</title>\n</head>\n<body>\n Hello EasySwoole think-template\n</body>\n</html>\n~~~\n\n","tags":["swoole","easyswoole"],"categories":["php"]},{"title":"easyswoole 基础入坑进行时","url":"/2020/06/22/php/easyswoole-basis/","content":"\n\n> easyswoole 基础入坑,更多详细文档请参考\n> \n> https://www.easyswoole.com/Cn/Preface/introduction.html\n\n\n# 基础\n\n基础环境需求\n\n- 保证 PHP 版本大于等于 7.1\n- 保证 Swoole 拓展版本大于等于 4.4.15\n- 需要 pcntl 拓展的任意版本\n- 使用 Linux / FreeBSD / MacOS 这三类操作系统\n- 使用 Composer 作为依赖管理工具\n\n## Composer安装\n\n~~~\ncomposer require easyswoole/easyswoole=3.x\nphp vendor/easyswoole/easyswoole/bin/easyswoole install\n~~~\n\n## 目录结构\n\nEasySwoole 的目录结构是非常灵活的，基本上可以任意定制，没有太多的约束，但是仍然建议遵循下面的目录结构，方便开发\n\n~~~\nproject                   项目部署目录\n├─App                     应用目录(可以有多个)\n│  ├─HttpController       控制器目录\n│  │  └─Index.php         默认控制器\n│  └─Model                模型文件目录\n├─Log                     日志文件目录\n├─Temp                    临时文件目录\n├─vendor                  第三方类库目录\n├─composer.json           Composer架构\n├─composer.lock           Composer锁定\n├─EasySwooleEvent.php     框架全局事件\n├─easyswoole              框架管理脚本\n├─dev.php                 开发配置文件\n├─produce.php             生产配置文件\n~~~\n\n# 配置\n\n配置文件`dev.php`\n\nhttps://www.easyswoole.com/Cn/QuickStart/config.html\n\n~~~\n<?php\nreturn [\n    'SERVER_NAME' => \"EasySwoole\",\n    'MAIN_SERVER' => [\n        'LISTEN_ADDRESS' => '0.0.0.0',\n        'PORT' => 9501,\n        'SERVER_TYPE' => EASYSWOOLE_WEB_SERVER,\n        'SOCK_TYPE' => SWOOLE_TCP,\n        'RUN_MODEL' => SWOOLE_PROCESS,\n        'SETTING' => [\n            'worker_num' => 8,\n            'reload_async' => true,\n            'max_wait_time'=>3\n        ],\n        'TASK'=>[\n            'workerNum'=>4,\n            'maxRunningNum'=>128,\n            'timeout'=>15\n        ]\n    ],\n    'TEMP_DIR' => '/tmp/easyswoole/',\n    'LOG_DIR' => null\n];\n\n~~~\n\n服务名称查看\n\n~~~\nps -ef | grep EasySwoole\n~~~\n\n\n\n## 配置文件操作类\n\n配置功能由`\\EasySwoole\\EasySwoole\\Config`类完成。\n\n### 配置加载\n\n在easyswoole配置加载目前支持有三种方式\n\n1. 加载配置配置文件，如：默认的dev.php一样的配置文件\n\n~~~\n \\EasySwoole\\EasySwoole\\Config::getInstance()->loadFile($file);\n~~~\n\n2. 加载env配置文件\n\n~~~\n\\EasySwoole\\EasySwoole\\Config::getInstance()->loadEnv($envfile);\n~~~\n\n3. 加载数组\n\n~~~\n \\EasySwoole\\EasySwoole\\Config::getInstance()->load($conf);\n~~~\n\n### 读取配置\n\n1. 读取单个配置信息\n\n~~~\n \\EasySwoole\\EasySwoole\\Config::getInstance()->getConf($keyPath);\n~~~\n\n2. 读取全部配置信息\n\n~~~\n \\EasySwoole\\EasySwoole\\Config::getInstance()->getConf();\n~~~\n\n### 动态配置\n\n~~~\n\\EasySwoole\\EasySwoole\\Config::getInstance()->setConf($keyPath,$data);\n~~~\n\n### 配置文件驱动方式\n\n~~~\nEasySwoole\\Config\\TableConfig\n\nEasySwoole\\Config\\SplArrayConfig\n~~~\n\n3. 自定义，参考一下官方文档自定义config驱动写法\n\n> 由于swoole是多进程的,如果使用SplArray方式存储,在单个进程修改配置后,其他进程将不会生效,使用swoole_table方式的则会全部生效,需要注意\n\n### 助手函数\n\n~~~\nuse EasySwoole\\EasySwoole\\Config as GlobalConfig;\nif (!function_exists(\"config\")) {\n    function config($name = '', $value = null)\n    {\n        $instance = GlobalConfig::getInstance();\n        if (is_null($value) && is_string($name)) {\n            return $instance->getConf($name);\n        } else {\n            return $instance->setConf($name, $value);\n        }\n    }\n}\n~~~\n\n\n\n\n\n# 控制器\n\n控制器的主要作用是request和response对象进行数据交互，详细的介绍，见官方文档：https://www.easyswoole.com/Cn/HttpServer/controller.html\n\n主要继承`EasySwoole\\Http\\AbstractInterface\\Controller`类和其他的控制器类\n\n定义控制器\n\n~~~\n<?php\nnamespace App\\HttpController;\nuse EasySwoole\\Http\\AbstractInterface\\Controller;\nclass User extends Controller\n{\n    public function onRequest(string $action): ?bool\n    {\n        $this->response()->write(\"this is user onRequest\\n\");\n        return true;\n    }\n    public function index()\n    {\n       $this->response()->write(\"this is user index\\n\");\n    }\n    public function afterAction(string $actionName): void\n    {\n        $this->response()->write(\"this is afterAction\\n\");\n    }\n    public function gc()\n    {\n        $this->response()->write(\"this is gc\\n\");\n    }\n    public function onException(\\Throwable $throwable): void\n    {\n        $this->response()->write($throwable->getMessage());\n    }\n    public function actionNotFound(string $action)\n    {\n        $this->response()->write(\"404\\n\");\n    }\n}\n~~~\n\n控制器类文件的实际位置是\n\n~~~\nApp/HttpController/User.php\n~~~\n\n访问格式：\n\n~~~\nhttp://127.0.0.1:9501/user/index\n~~~\n\n执行的结果\n\n~~~\nthis is user onRequest\nthis is user index\nthis is afterAction\nthis is gc\n~~~\n\n1. `index`方法：是一个抽象方法，可以随意定义，但是导致的结果只会是路由变化，如方法名称是`info`那么你访问的路由也就是`/user/info`\n2. `onRequest`方法：是来源父类的方法，是在请求该控制器该方法之前去执行，我们可以在这里放置权限管理，登录业务逻辑处理等操作\n3. `afterAction`方法，来源于父类的方法，当控制器方法执行结束之后将调用该方法,可自定义数据回收等逻辑‘\n4. gc 方法将在执行`方法`,`afterAction`完之后自动调用,将控制器属性重置为默认值,关闭`session`可自行覆盖实现其他的gc回收逻辑.\n5. `onException`当控制器逻辑抛出异常时将调用该方法进行处理异常(框架默认已经处理了异常)\n   可覆盖该方法,进行自定义的异常处理。\n6. `actionNotFound`当请求方法未找到时,自动调用该方法,可自行覆盖该方法实现自己的逻辑\n\n## 请求Request\n\n~~~\n$req = $this->request();\n// 用于获取用户通过POST或者GET提交的参数\n$data = $req->getRequestParam();\n//获取cookies信息\n$cookies = $req->getCookieParams();\n//获取上传文件信息\n$file = $req->getUploadedFile(\"img\");\n//获取多个文件信息\n$file = $req->getUploadedFiles();\n//获得get内容\n$get = $req->getQueryParams();\n//获得post内容\n$post = $req->getParsedBody();\n//获得raw内容\n$content = $req->getBody()->__toString();\n$raw_array = json_decode($content, true);\n//获得头部\n$header = $req->getHeaders();\n//获得server\n$server = $req->getServerParams();\n//获得cookie\n$cookie = $req->getCookieParams();\n~~~\n\n## 响应Rseponse\n\n~~~\n// 向页面输出hello world 字符串，同时也只能传入字符串\n$this->response()->write('hello world');\n\n//重定向(可路由可外)\n$this->response()->redirect(\"/user\");\n\n// json数据\n$this->writeJson(200,$data,'success');\n{\"code\":200,\"result\":{},\"msg\":\"success\"}\n\n~~~\n\n\n\n\n\n\n\n\n","tags":["swoole","easyswoole"],"categories":["php"]},{"title":"在centos7环境下安装配置php7","url":"/2020/06/20/php/centos-php-install/","content":"\n\n## 安装依赖\n\n~~~\nyum install -y epel-release\nyun update -y\n \nyum install -y autoconf curl-devel openssl openssl-devel openssl openssl-devel gcc gcc-c++ libxml2 libxml2-devel libpng libpng-devel bzip2 bzip2-devel freetype-devel libicu-devel libjpeg-devel\n\nwget https://nih.at/libzip/libzip-1.2.0.tar.gz\ntar -zxvf libzip-1.2.0.tar.gz\ncd libzip-1.2.0\n./configure\nmake && make install\n \ncp /usr/local/lib/libzip/include/zipconf.h /usr/local/include/zipconf.h\n~~~\n\n## 下载解压\n\n~~~\nwget https://www.php.net/distributions/php-7.3.13.tar.gz\ntar -xzvf php-7.3.13.tar.gz\ncd php-php-7.3.13/\n\nwget https://www.php.net/distributions/php-7.2.31.tar.gz\ntar -xzvf php-7.2.31.tar.gz\ncd php-7.2.31/\n~~~\n\n## 参数编译\n\n~~~\n./configure --prefix=/usr/local/php7 \\\n--enable-fpm \\\n--enable-shared \\\n--enable-soap \\\n--enable-bcmath \\\n--enable-calendar \\\n--enable-ftp \\\n--enable-dom \\\n--enable-exif \\\n--enable-fileinfo \\\n--enable-filter \\\n--enable-gd-jis-conv \\\n--enable-json \\\n--enable-mbstring \\\n--enable-mbregex \\\n--enable-mbregex-backtrack \\\n--enable-session \\\n--enable-shmop \\\n--enable-simplexml \\\n--enable-pcntl \\\n--enable-sockets \\\n--enable-sysvmsg \\\n--enable-sysvsem \\\n--enable-sysvshm \\\n--enable-wddx \\\n--enable-zip \\\n--enable-mysqlnd-compression-support \\\n--enable-opcache \\\n--enable-inline-optimization \\\n--enable-intl \\\n--enable-simplexml \\\n--enable-xmlreader \\\n--enable-xmlwriter \\\n--disable-phpdbg \\\n--disable-phpdbg-webhelper \\\n--disable-debug \\\n--disable-rpath \\\n--with-xmlrpc \\\n--with-openssl \\\n--with-pcre-regex \\\n--with-sqlite3 \\\n--with-zlib \\\n--with-iconv \\\n--with-bz2 \\\n--with-curl \\\n--with-cdb \\\n--with-pcre-dir \\\n--with-gd \\\n--with-openssl-dir \\\n--with-jpeg-dir \\\n--with-png-dir \\\n--with-freetype-dir \\\n--with-gettext \\\n--with-mhash \\\n--with-libmbfl \\\n--with-onig \\\n--with-mysqli=shared,mysqlnd \\\n--with-pdo-mysql=shared,mysqlnd \\\n--with-zlib-dir \\\n--with-pdo-sqlite \\\n--with-pear \\\n--with-libxml-dir\n~~~\n\n## 开始make安装\n\n~~~\nmake && make install\n~~~\n\n## 环境变量以及配置文件拷贝\n\n~~~\n//加入永久环境变量中\nvi /etc/profile\nexport PATH=/usr/local/php7/bin:$PATH\nsource /etc/profile\n\n// 为了防止环境变量设置错误导致无法执行ls等基本命令，处理方案\nexport PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin\n\n//配置文件拷贝到指定的目录\nphp -i | grep php.ini\ncp php.ini-development /usr/local/php7/lib/php.ini\n~~~\n\n## 配置php-fpm服务\n\n~~~\n\n# 创建www组\ngroupadd www\n# 创建一个用户归属www组\nuseradd -g www www\n\ncp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf\ncp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf\n//编辑php-fpm.conf 去掉注释\nvim /usr/local/php7/etc/php-fpm.conf\npid = run/php-fpm.pid\n\n~~~\n\n## fpm命令\n\n~~~\n测试php-fpm配置\n/usr/local/php7/sbin/php-fpm -t\n/usr/local/php7/sbin/php-fpm -c /usr/local/php7/etc/php.ini -y  /usr/local/php7/etc/php-fpm.conf -t\n\n\n//自定义加载配置信息启动\n/usr/local/php7/sbin/php-fpm -c /usr/local/php7/lib/php.ini -y /usr/local/php7/etc/php-fpm.conf\n\n\n//pid 获取\nps aux | grep php\ncat /usr/local/php7/var/run/php-fpm.pid\n\n\nphp-fpm信号控制\nINT, TERM 立刻终止\nQUIT 平滑终止\nUSR1 重新打开日志文件\nUSR2 平滑重载所有worker进程并重新载入配置和二进制模块\n\n//重启php-fpm:\nkill -USR2 pid\nkillall -9 php-fpm\n\n//关闭php-fpm\nkill -INT `cat /usr/local/php7/var/run/php-fpm.pid`\n或pkill php-fpm\n~~~\n\n\n\n## 扩展安装\n\n### pecl方式\n\n~~~\npecl install redis\necho extension=redis.so >>/usr/local/php7/lib/php.ini\n~~~\n\n### 编译安装\n\n~~~\ngit clone https://gitee.com/swoole/swoole.git\ncd swoole\nphpize\n\n// 预编译配置\n./configure \\\n--enable-coroutine \\\n--enable-openssl  \\\n--enable-http2  \\\n--enable-async-redis \\\n--enable-sockets \\\n--enable-mysqlnd\n--with-php-config=/usr/local/php7/bin/php-config\n\n//安装\nmake &&  make install\n\necho extension=swoole.so >>/usr/local/php7/lib/php.ini\n\n//查看swoole相关信息\nphp --ri swoole \n~~~\n\n## Composer安装\n\n~~~\nwget https://mirrors.aliyun.com/composer/composer.phar\n\ncurl -sS https://getcomposer.org/installer | php\n\n\nmv composer.phar /usr/local/bin/composer  && chmod +x /usr/local/bin/composer\n\n\n\n//创建一个composer用户\nuseradd composer\nsu composer\n\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n~~~\n","tags":["环境搭建","编译"],"categories":["php"]},{"title":"vue3.x 新特性","url":"/2020/06/18/html/vue3-newfeatures/","content":"\n> 本文主要围绕 `vue-compisition-api`，来讲解大家最关心的、同时也是 vue 3.0 最重要的一些新特性，例如 `setup()` 函数、`reactive()`、`ref()` 等这些 Vue Hooks。\n\n\n## 基础要求\n\n1. 了解常见的 ES6 新特性\n   - ES6 的导入导出语法\n   - 解构赋值\n   - 箭头函数\n   - etc...\n2. 了解 vue 2.x 的基本使用\n   - 组件\n   - 常用的指令\n   - 生命周期函数\n   - computed、watch、ref 等\n\n## 相关资源\n\n- 【github - [vuejs](https://github.com/vuejs)/composition-api】https://github.com/vuejs/composition-api\n- 【github - [composition-api](https://github.com/vuejs/composition-api)/CHANGELOG.md】https://github.com/vuejs/composition-api/blob/master/CHANGELOG.md\n\n## 初始化项目\n\n1. 安装 vue-cli3\n\n```\nnpm install -g @vue/cli\n# OR\nyarn global add @vue/cli\n```\n\n2. 创建项目\n\n```\nvue create my-project\n# OR\nvue ui\n```\n\n3. 在项目中安装 `composition-api` 体验 vue3 新特性\n\n```\nnpm install @vue/composition-api --save\n# OR\nyarn add @vue/composition-api\n```\n\n4. 在使用任何 `@vue/composition-api` 提供的能力前，必须先通过 `Vue.use()` 进行安装\n\n```\nimport Vue from 'vue'\nimport VueCompositionApi from '@vue/composition-api'\n\nVue.use(VueCompositionApi)\n```\n\n   安装插件后，您就可以使用新的 [Composition API](https://vue-composition-api-rfc.netlify.com/) 来开发组件了。\n\n## setup\n\n`setup()` 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 `Composition API` 新特性提供了统一的入口。\n\n### 执行时机\n\nsetup 函数会在 beforeCreate 之后、created 之前执行\n\n### 接收 props 数据\n\n1. 在 `props` 中定义当前组件允许外界传递过来的参数名称：\n\n```\nprops: {\n p1: String\n}\n```\n\n2. 通过 `setup` 函数的第一个形参，接收 `props` 数据：\n\n```\nsetup(props) {\n   console.log(props.p1)\n}\n```\n\n### context\n\n`setup` 函数的第二个形参是一个上下文对象，这个上下文对象中包含了一些有用的属性，这些属性在 `vue 2.x` 中需要通过 `this` 才能访问到，在 `vue 3.x` 中，它们的访问方式如下：\n\n```\nconst MyComponent = {\n  setup(props, context) {\n    context.attrs\n    context.slots\n    context.parent\n    context.root\n    context.emit\n    context.refs\n  }\n}\n```\n\n> 注意：在 `setup()` 函数中无法访问到 `this`\n\n## reactive\n\n`reactive()` 函数接收一个普通对象，返回一个响应式的数据对象。\n\n### 基本语法\n\n等价于 `vue 2.x` 中的 `Vue.observable()` 函数，`vue 3.x` 中提供了 `reactive()` 函数，用来创建响应式的数据对象，基本代码示例如下：\n\n```\nimport { reactive } from '@vue/composition-api'\n\n// 创建响应式数据对象，得到的 state 类似于 vue 2.x 中 data() 返回的响应式对象\nconst state = reactive({ count: 0 })\n```\n\n### 定义响应式数据供 template 使用\n\n1. 按需导入 `reactive` 函数：\n\n```\nimport { reactive } from '@vue/composition-api'\n```\n\n2. 在 `setup()` 函数中调用 `reactive()` 函数，创建响应式数据对象：\n\n```\nsetup() {\n    // 创建响应式数据对象\n   const state = reactive({count: 0})\n\n    // setup 函数中将响应式数据对象 return 出去，供 template 使用\n   return state\n}\n```\n\n3. 在 `template` 中访问响应式数据：\n\n```\n<p>当前的 count 值为：{{count}}</p>\n```\n\n## ref\n\n### 基本语法\n\n`ref()` 函数用来根据给定的值创建一个响应式的数据对象，`ref()` 函数调用的返回值是一个对象，这个对象上只包含一个 `.value` 属性：\n\n```\nimport { ref } from '@vue/composition-api'\n\n// 创建响应式数据对象 count，初始值为 0\nconst count = ref(0)\n\n// 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以\nconsole.log(count.value) // 输出 0\n// 让 count 的值 +1\ncount.value++\n// 再次打印 count 的值\nconsole.log(count.value) // 输出 1\n```\n\n###  在 template 中访问 ref 创建的响应式数据\n\n1. 在 `setup()` 中创建响应式数据：\n\n```\nimport { ref } from '@vue/composition-api'\n\nsetup() {\n   const count = ref(0)\n\n    return {\n        count,\n        name: ref('zs')\n    }\n}\n```\n\n2. 在 `template` 中访问响应式数据：\n\n```\n<template>\n <p>{{count}} --- {{name}}</p>\n</template>\n```\n\n### 在 reactive 对象中访问 ref 创建的响应式数据\n\n当把 `ref()` 创建出来的响应式数据对象，挂载到 `reactive()` 上时，会自动把响应式数据对象展开为原始的值，不需通过 `.value` 就可以直接被访问，例如：\n\n```\nconst count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 输出 0\nstate.count++ // 此处不需要通过 .value 就能直接访问原始值\nconsole.log(count) // 输出 1\n```\n\n> 注意：新的 ref 会覆盖旧的 ref，示例代码如下：\n\n```\n// 创建 ref 并挂载到 reactive 中\nconst c1 = ref(0)\nconst state = reactive({\n  c1\n})\n\n// 再次创建 ref，命名为 c2\nconst c2 = ref(9)\n// 将 旧 ref c1 替换为 新 ref c2\nstate.c1 = c2\nstate.c1++\n\nconsole.log(state.c1) // 输出 10\nconsole.log(c2.value) // 输出 10\nconsole.log(c1.value) // 输出 0\n```\n\n## isRef\n\n`isRef()` 用来判断某个值是否为 `ref()` 创建出来的对象；应用场景：当需要展开某个可能为 `ref()` 创建出来的值的时候，例如：\n\n```\nimport { isRef } from '@vue/composition-api'\n\nconst unwrapped = isRef(foo) ? foo.value : foo\n```\n\n## toRefs\n\n`toRefs()` 函数可以将 `reactive()` 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 `ref()` 类型的响应式数据，最常见的应用场景如下：\n\n```\nimport { toRefs } from '@vue/composition-api'\n\nsetup() {\n    // 定义响应式数据对象\n    const state = reactive({\n      count: 0\n    })\n\n    // 定义页面上可用的事件处理函数\n    const increment = () => {\n      state.count++\n    }\n\n    // 在 setup 中返回一个对象供页面使用\n    // 这个对象中可以包含响应式的数据，也可以包含事件处理函数\n    return {\n      // 将 state 上的每个属性，都转化为 ref 形式的响应式数据\n      ...toRefs(state),\n      // 自增的事件处理函数\n      increment\n    }\n}\n```\n\n页面上可以直接访问 `setup()` 中 return 出来的响应式数据：\n\n```\n<template>\n  <div>\n    <p>当前的count值为：{{count}}</p>\n    <button @click=\"increment\">+1</button>\n  </div>\n</template>\n```\n\n## computed\n\n`computed()` 用来创建计算属性，`computed()` 函数的返回值是一个 `ref` 的实例。使用 `computed` 之前需要按需导入：\n\n```\nimport { computed } from '@vue/composition-api'\n```\n\n### 创建只读的计算属性\n\n在调用 `computed()` 函数期间，传入一个 `function` 函数，可以得到一个只读的计算属性，示例代码如下：\n\n```\n// 创建一个 ref 响应式数据\nconst count = ref(1)\n\n// 根据 count 的值，创建一个响应式的计算属性 plusOne\n// 它会根据依赖的 ref 自动计算并返回一个新的 ref\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 输出 2\nplusOne.value++ // error\n```\n\n### 创建可读可写的计算属性\n\n在调用 `computed()` 函数期间，传入一个包含 `get` 和 `set` 函数的对象，可以得到一个可读可写的计算属性，示例代码如下：\n\n```\n// 创建一个 ref 响应式数据\nconst count = ref(1)\n\n// 创建一个 computed 计算属性\nconst plusOne = computed({\n  // 取值函数\n  get: () => count.value + 1,\n  // 赋值函数\n  set: val => {\n    count.value = val - 1\n  }\n})\n\n// 为计算属性赋值的操作，会触发 set 函数\nplusOne.value = 9\n// 触发 set 函数后，count 的值会被更新\nconsole.log(count.value) // 输出 8\n```\n\n## watch\n\n`watch()` 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入：\n\n```js\nimport { watch } from '@vue/composition-api'\n```\n\n### 基本用法\n\n```\nconst count = ref(0)\n\n// 定义 watch，只要 count 值变化，就会触发 watch 回调\n// watch 会在创建时会自动调用一次\nwatch(() => console.log(count.value))\n// 输出 0\n\nsetTimeout(() => {\n  count.value++\n  // 输出 1\n}, 1000)\n```\n\n### 监视指定的数据源\n\n监视 `reactive` 类型的数据源：\n\n```\n// 定义数据源\nconst state = reactive({ count: 0 })\n// 监视 state.count 这个数据节点的变化\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)\n```\n\n监视 `ref` 类型的数据源：\n\n```\n// 定义数据源\nconst count = ref(0)\n// 指定要监视的数据源\nwatch(count, (count, prevCount) => {\n  /* ... */\n})\n```\n\n### 监视多个数据源\n\n监视 `reactive` 类型的数据源：\n\n```\nconst state = reactive({ count: 0, name: 'zs' })\n\nwatch(\n  [() => state.count, () => state.name], // Object.values(toRefs(state)),\n  ([count, name], [prevCount, prevName]) => {\n    console.log(count) // 新的 count 值\n    console.log(name) // 新的 name 值\n    console.log('------------')\n    console.log(prevCount) // 旧的 count 值\n    console.log(prevName) // 新的 name 值\n  },\n  {\n    lazy: true // 在 watch 被创建的时候，不执行回调函数中的代码\n  }\n)\n\nsetTimeout(() => {\n  state.count++\n  state.name = 'ls'\n}, 1000)\n```\n\n监视 `ref` 类型的数据源：\n\n```\nconst count = ref(0)\nconst name = ref('zs')\n\nwatch(\n  [count, name], // 需要被监视的多个 ref 数据源\n  ([count, name], [prevCount, prevName]) => {\n    console.log(count)\n    console.log(name)\n    console.log('-------------')\n    console.log(prevCount)\n    console.log(prevName)\n  },\n  {\n    lazy: true\n  }\n)\n\nsetTimeout(() => {\n  count.value++\n  name.value = 'xiaomaolv'\n}, 1000)\n```\n\n### 清除监视\n\n在 `setup()` 函数内创建的 `watch` 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 `watch()` 函数的返回值即可，语法如下：\n\n```\n// 创建监视，并得到 停止函数\nconst stop = watch(() => {\n  /* ... */\n})\n\n// 调用停止函数，清除对应的监视\nstop()\n```\n\n### 在 watch 中清除无效的异步任务\n\n有时候，当被 `watch` 监视的值发生变化时，或 `watch` 本身被 `stop` 之后，我们期望能够清除那些无效的异步任务，此时，`watch` 回调函数中提供了一个 `cleanup registrator function` 来执行清除的工作。这个清除函数会在如下情况下被调用：\n\n- watch 被重复执行了\n- watch 被强制 `stop` 了\n\nTemplate 中的代码示例如下：\n\n```\n/* template 中的代码 */ <input type=\"text\" v-model=\"keywords\" />\n```\n\nScript 中的代码示例如下：\n\n```\n// 定义响应式数据 keywords\nconst keywords = ref('')\n\n// 异步任务：打印用户输入的关键词\nconst asyncPrint = val => {\n  // 延时 1 秒后打印\n  return setTimeout(() => {\n    console.log(val)\n  }, 1000)\n}\n\n// 定义 watch 监听\nwatch(\n  keywords,\n  (keywords, prevKeywords, onCleanup) => {\n    // 执行异步任务，并得到关闭异步任务的 timerId\n    const timerId = asyncPrint(keywords)\n\n    // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务\n    onCleanup(() => clearTimeout(timerId))\n  },\n  // watch 刚被创建的时候不执行\n  { lazy: true }\n)\n\n// 把 template 中需要的数据 return 出去\nreturn {\n  keywords\n}\n```\n\n## LifeCycle Hooks\n\n新版的生命周期函数，可以按需导入到组件中，且只能在 `setup()` 函数中使用，代码示例如下：\n\n```\nimport { onMounted, onUpdated, onUnmounted } from '@vue/composition-api'\n\nconst MyComponent = {\n  setup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n}\n```\n\n下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系：\n\n- ~~`beforeCreate`~~ -> use `setup()`\n- ~~`created`~~ -> use `setup()`\n- `beforeMount` -> `onBeforeMount`\n- `mounted` -> `onMounted`\n- `beforeUpdate` -> `onBeforeUpdate`\n- `updated` -> `onUpdated`\n- `beforeDestroy` -> `onBeforeUnmount`\n- `destroyed` -> `onUnmounted`\n- `errorCaptured` -> `onErrorCaptured`\n\n## provide & inject\n\n`provide()` 和 `inject()` 可以实现嵌套组件之间的数据传递。这两个函数只能在 `setup()` 函数中使用。父级组件中使用 `provide()` 函数向下传递数据；子级组件中使用 `inject()` 获取上层传递过来的数据。\n\n### 共享普通数据\n\n`App.vue` 根组件：\n\n```\n<template>\n  <div id=\"app\">\n    <h1>App 根组件</h1>\n    <hr />\n    <LevelOne />\n  </div>\n</template>\n\n<script>\nimport LevelOne from './components/LevelOne'\n// 1. 按需导入 provide\nimport { provide } from '@vue/composition-api'\n\nexport default {\n  name: 'app',\n  setup() {\n    // 2. App 根组件作为父级组件，通过 provide 函数向子级组件共享数据（不限层级）\n    //    provide('要共享的数据名称', 被共享的数据)\n    provide('globalColor', 'red')\n  },\n  components: {\n    LevelOne\n  }\n}\n</script>\n```\n\n`LevelOne.vue` 组件：\n\n```\n<template>\n  <div>\n    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->\n    <h3 :style=\"{color: themeColor}\">Level One</h3>\n    <hr />\n    <LevelTwo />\n  </div>\n</template>\n\n<script>\nimport LevelTwo from './LevelTwo'\n// 1. 按需导入 inject\nimport { inject } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据\n    const themeColor = inject('globalColor')\n\n    // 3. 把接收到的共享数据 return 给 Template 使用\n    return {\n      themeColor\n    }\n  },\n  components: {\n    LevelTwo\n  }\n}\n</script>\n```\n\n`LevelTwo.vue` 组件：\n\n```\n<template>\n  <div>\n    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->\n    <h5 :style=\"{color: themeColor}\">Level Two</h5>\n  </div>\n</template>\n\n<script>\n// 1. 按需导入 inject\nimport { inject } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据\n    const themeColor = inject('globalColor')\n\n    // 3. 把接收到的共享数据 return 给 Template 使用\n    return {\n      themeColor\n    }\n  }\n}\n</script>\n```\n\n### 共享 ref 响应式数据\n\n如下代码实现了点按钮切换主题颜色的功能，主要修改了 `App.vue` 组件中的代码，`LevelOne.vue` 和 `LevelTwo.vue` 中的代码不受任何改变：\n\n```\n<template>\n  <div id=\"app\">\n    <h1>App 根组件</h1>\n\n    <!-- 点击 App.vue 中的按钮，切换子组件中文字的颜色 -->\n    <button @click=\"themeColor='red'\">红色</button>\n    <button @click=\"themeColor='blue'\">蓝色</button>\n    <button @click=\"themeColor='orange'\">橘黄色</button>\n\n    <hr />\n    <LevelOne />\n  </div>\n</template>\n\n<script>\nimport LevelOne from './components/LevelOne'\nimport { provide, ref } from '@vue/composition-api'\n\nexport default {\n  name: 'app',\n  setup() {\n    // 定义 ref 响应式数据\n    const themeColor = ref('red')\n\n    // 把 ref 数据通过 provide 提供的子组件使用\n    provide('globalColor', themeColor)\n\n    // setup 中 return 数据供当前组件的 Template 使用\n    return {\n      themeColor\n    }\n  },\n  components: {\n    LevelOne\n  }\n}\n</script>\n```\n\n## template refs\n\n通过 `ref()` 还可以引用页面上的元素或组件。\n\n### 元素的引用\n\n示例代码如下：\n\n```\n<template>\n  <div>\n    <h3 ref=\"h3Ref\">TemplateRefOne</h3>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 创建一个 DOM 引用\n    const h3Ref = ref(null)\n\n    // 在 DOM 首次加载完毕之后，才能获取到元素的引用\n    onMounted(() => {\n      // 为 dom 元素设置字体颜色\n      // h3Ref.value 是原生DOM对象\n      h3Ref.value.style.color = 'red'\n    })\n\n    // 把创建的引用 return 出去\n    return {\n      h3Ref\n    }\n  }\n}\n</script>\n```\n\n### 组件的引用\n\n`TemplateRefOne.vue` 中的示例代码如下：\n\n```\n<template>\n  <div>\n    <h3>TemplateRefOne</h3>\n\n    <!-- 4. 点击按钮展示子组件的 count 值 -->\n    <button @click=\"showNumber\">获取TemplateRefTwo中的count值</button>\n\n    <hr />\n    <!-- 3. 为组件添加 ref 引用 -->\n    <TemplateRefTwo ref=\"comRef\" />\n  </div>\n</template>\n\n<script>\nimport { ref } from '@vue/composition-api'\nimport TemplateRefTwo from './TemplateRefTwo'\n\nexport default {\n  setup() {\n    // 1. 创建一个组件的 ref 引用\n    const comRef = ref(null)\n\n    // 5. 展示子组件中 count 的值\n    const showNumber = () => {\n      console.log(comRef.value.count)\n    }\n\n    // 2. 把创建的引用 return 出去\n    return {\n      comRef,\n      showNumber\n    }\n  },\n  components: {\n    TemplateRefTwo\n  }\n}\n</script>\n```\n\n`TemplateRefTwo.vue` 中的示例代码：\n\n```jsx\n<template>\n  <div>\n    <h5>TemplateRefTwo --- {{count}}</h5>\n    <!-- 3. 点击按钮，让 count 值自增 +1 -->\n    <button @click=\"count+=1\">+1</button>\n  </div>\n</template>\n\n<script>\nimport { ref } from '@vue/composition-api'\n\nexport default {\n  setup() {\n    // 1. 定义响应式的数据\n    const count = ref(0)\n\n    // 2. 把响应式数据 return 给 Template 使用\n    return {\n      count\n    }\n  }\n}\n</script>\n```\n\n## createComponent\n\n> 这个函数不是必须的，除非你想要完美结合 TypeScript 提供的类型推断来进行项目的开发。\n\n这个函数仅仅提供了类型推断，方便在结合 TypeScript 书写代码时，能为 `setup()` 中的 `props` 提供完整的类型推断。\n\n```\nimport { createComponent } from 'vue'\n\nexport default createComponent({\n  props: {\n    foo: String\n  },\n  setup(props) {\n    props.foo // <- type: string\n  }\n})\n```\n","tags":["css","vue"],"categories":["前端"]},{"title":"Rsync文件同步工具介绍","url":"/2020/06/08/soft/rsync-use/","content":"\nRsync介绍\n\n\n### Rsync介绍\n\n> 是一款开源的、快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具。软件适用于unix、linux、windows等多种操作系统平台。全称为Remote Rynchronization。\n> ssh带的scp,但优于scp命令的功能，scp每次都是全量拷贝，而rsync可以增量拷贝。\n> Rsync还可以在本地主机的不同分区或目录之间全量及增量的复制数据，类型cp命令。\n> Rsync还可以实现删除文件和目录的功能。\n> 一个rsync相当于scp,cp,rm，但是还优于他们每一个命令。\n\n### Rsync同步\n\n> 在同步备份数据时，默认情况下，Rsync通过其独特的“quick check”算法，它仅同步大小或者最后修改时间发生变化的文件或目录。也可以根据权限，属主等属性的变化同步，但需要制定相应的参数，甚至可以实现只同步一个文件里有变化的内容部分，所以能实现快速的同步备份数据。\n> 版本区别：\n> version2版本会把要同步的文件加载和已有的文件比较，如果发生变化就同步过去。version3版本边比较边同步。\n> Rsync是文件系统之上，基于文件的同步；基于block的同步用drbd。\n> union双机互相同步，csync2多机同步。\n\n### Rsync特性\n\n- 支持拷贝特殊文件如链接文件、设备等。\n- 可以有排除指定文件或目录同步的功能，相当于打包命令tar的排除功能。\n- 可以做到保持源文件或目录的权限、时间、软硬链接、属主、组等所有属性均不改变-P。\n- 可以实现增量同步，既只同步发生变化的数据，因此数据传输效率高。\n- 可以使用rcp、rsh、ssh等方式来配合传输文件（rsync本身不对数据加密）\n- 可以通过socket（进程方式）传输文件和数据。（服务端与客户端）\n- 支持匿名的或认证（无需系统用户）的进程模式传输，可实现方便安全的进行数据备份及镜像。\n\n### Rsync企业应用\n\n- 两台服务器之间的数据同步\n- 集群服务器的数据同步\n- 定时同步（cron+rsync）与实时同步（rsync+inotify、rsync+sersync）\n\n### Rsync工作方式\n\n- 单个主机本地之间的数据传输（此时类似于cp命令的功能）\n- 借助rcp、ssh等通道来传输数据（此时类似于scp命令的功能）\n- 以守护进程（socket）的方式传输数据（这个是rsync自身的重要功能）\n\n### Rsync优缺点\n\n- 优点：增量备份同步、支持socket（daemon）、集中备份\n- 缺点：大量小文件同步的时候比对时间较长，有的时候rsync进程会停止。解决方式可以打包同步或者通过drbd方式。同步大文件（10G）这样的大文件有时候也会有问题。（发生同步中断）未完成同步前，是隐藏文件。\n\n### 常用参数\n\n```\n语法：  rsync [option...] src... [dest]\n说明：\n[option]为同步时的参数选项 -avz\n-z --compress 传输时进行压缩以提高传输效率，--compress-level=NUM可按级别压缩。\n-v --verbose 详细模式输出，传输时的进度等信息。\n-a --archive归档模式，表示以递归方式传输文件，并保持所有文件属性。等于-rtopgDl\n-r --对子目录以递归模式，及目录下的所有目录都同样传输。\n-t --保持文件时间信息。\n-o --保持文件属主信息。\n-p --保持文件权限。\n-g --保持文件属组信息。\n-P --显示同步的过程及传输时的进度信息。\n-D --保持设备文件信息。\n-l --保留软连接。\n-e   使用的信道协议，指定替代rsh的shell。\n--exclude=PATTERN 指定排除不需要传输的文件模式。\n\n[src]为源，即需要拷贝的分区、文件或目录等。\n[dest]为目的分区、文件或目录等。\n```\n\n### 常见使用方法\n\n单个主机本地之间的数据传输 本地传输模式（local-only mode）\n\n~~~\nrsync -az /home/e-books/ /home/books/\n~~~\n\n将远程目录复制/同步到本地计算机\n\n~~~\nrsync -avzh root@192.168.1.100:/www/rsync/php7 /home/php7/\n~~~\n\n将文件和目录复制/同步到服务器或从服务器同步\n\n~~~\nrsync -avz /home/rsync/ root@192.168.0.101:/www/rsync/\n\n//带进度条\nrsync -avz ssh --progress /home/rsync/ root@192.168.0.101:/www/rsync/\n~~~\n","tags":["rsync","文件同步"],"categories":["运维"]},{"title":"css-垂直居中布局解决方案","url":"/2020/06/08/html/css-verticalcenterlayout/","content":"\n\n\n> 指当前元素在父级元素容器中，垂直方向居中显示\n\n\n\n- 方案一：table-cell + vertical-algin 属性配合使用\n\n\n\n~~~\n<div class=\"parent\">\n\t<div class=\"child\">居中文字</div>\n</div>\n<style>\n        /*\n        table 设置table元素\n        table-cell 设置元素td元素\n        */\n        display: table-cell;\n       /* \n       * vertical-align属性 用于设置文本内容垂直方向对齐方式\n       * top 顶部对齐\n       * middle 居中对齐 \n       * bottom 底部对齐\n       */\n        vertical-align: middle;\n</style>\n~~~\n\n\n\n- 方案二：absolute + transfrom属性配合使用\n\n\n\n~~~\n.parent {\n\tposition: relative;\n}\n.child {\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%);\n}\n~~~\n\n","tags":["css"],"categories":["前端"]},{"title":"css-居中布局解决方案","url":"/2020/06/08/html/css-centerlayout/","content":"\n\n> 指当前元素在父级元素容器中，水平方向是居中显示\n\n## 方案一：inline-block + text-algin 属性配合使用\n\n优缺点：\n\n兼容性好\n\ntext-algin属性具有继承性，导致子元素的文本也是居中显示\n\n~~~\n#parent{\n    width: 100%;\n    height: 200px;\n    background: #ccc;\n    /*\n    * text-aglign属性值 \n    * - left(左对齐)\n    * - center（居中）\n    * - right（右对齐）\n    * display属性值：\n    * - block 块级元素\n    * - inline 内联元素\n    * - inline-block 行内块级元素（块级+内联）\n    */\n    text-align:center;\n}\n#child{\n    width: 200px;\n    height: 200px;\n    background: red;\n    display: inline-block;\n}\n/*在上面代码中child无论是块还是文本都会显示居中，如果想要文本左对齐，那么就需要*/\n#child{\n    text-align:left;\n}\n</style>\n\n<div id=\"parent\">\n\t<div id=\"child\">我是谁</div>\n</div>\n~~~\n\n## 方案二：table+margin 属性配合使用\n\n优：只需要对子元素进行设置可以实现水平居中布局\n\n缺：子元素脱离文档流，导致margin属性值无效\n\n~~~\n<style>\n#parent{\n    width: 100%;\n    height: 300px;\n    background:aquamarine;\n} \n#child{\n    width: 300px;\n    height: 300px;\n    background:red;\n    /**\n    * margin属性:外边距\n    * - 一个值： 上右下左\n    * - 两个值： 上下，左右\n    * - 三个值： 上，左右，下\n    * - 四个值： 上，右，左，下\n    */\n    display:table;\n    margin: 0 auto;\n}\n</style>\n<div id=\"parent\">\n    <div id=\"child\">我是谁</div>\n</div>\n~~~\n\n\n\n## 方案三：absolute+ transform 属性配合使用\n\n优缺点\n\n优：父级元素是否脱离文档流，不影响子级元素水平居中\n\n缺：transform属性css3中新增的属性，浏览器支持不友好\n\n~~~\n<style>\n#parent{\n    width: 100%;\n    height: 200px;\n    background: #ccc;\n    /*\n    *  开启定位\n    *  absolute 绝对定位\n    *  fixed 相对固定定位\n    *  relative 相对定位\n    * */\n    position: relative;\n}\n#child{\n    width: 200px;\n    height: 200px;\n    background: red;\n    /*\n    * 当前元素设置绝对定位之后:\n    * 若父级没有开启定位，当前元素相当于页面定位\n    * 若父级开启定位的话，当前元素相当于当前父类进行定位\n    * \n    * */\n    position: absolute;\n    left: 50%;\n    /*\n    *  水平方向平移 （向左移动）\n    *  移动的大小是根据当前元素的宽度来决定\n    */\n    transform:  translateX(-50%);\n}\n\n</style>\n\n<div id=\"parent\">\n\t<div id=\"child\">我是谁</div>\n</div>\n~~~","tags":["css"],"categories":["前端"]},{"title":"node-sequelize基本使用","url":"/2020/06/08/nodejs/node-sequelize/","content":"\n\n\n# 安装Sequelize\n\n~~~\nnpm i sequelize\n~~~\n\n> 驱动安装（选择以下其一）\n>\n> ~~~\n> npm install --save pg pg-hstore # Postgres\n> npm install --save mysql2\n> npm install --save mariadb\n> npm install --save sqlite3\n> npm install --save tedious # Microsoft SQL Server\n> ~~~\n\n# 连接数据库测试连接初次体验\n\n导入sequelize包\n\n创建sequelize实例（通过实例构造方法传入参数创建连接数据库地址）\n\n`.authenticate()`函数测试连接是否正常\n\n~~~\nconst Sequelize = require('sequelize');\nconst sequelize = new Sequelize('dog', 'root', '123456', {\n    host: 'localhost',\n    /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */\n    dialect: 'mysql' \n});\ntry {\n    sequelize.authenticate();\n    console.log(\"ok\");\n} catch (err) {\n    console.log(err)\n}\n~~~\n\n> 构造函数参数详解\n>\n> https://sequelize.org/master/class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor\n\n# 关闭连接\n\n默认情况下，在保持连接打开的状态，并对所有的查询使用相同的连接\n\n~~~\nsequelize.close()\n~~~\n\n# 模型模型\n\n模型的本质其实是代表的是数据库中表的抽象，包含数据库表的`名称`以及该名称下所具有的`列`（以及列的数据类型）\n\n## 模型定义-define方式\n\n~~~\nsequelize.define(modelName, attributes, options)\n~~~\n\n> 函数详解\n>\n> https://sequelize.org/master/class/lib/sequelize.js~Sequelize.html#instance-method-define\n>\n> https://sequelize.org/master/class/lib/model.js~Model.html#static-method-init\n\neg：定义一个user模型\n\n~~~\nconst {Sequelize,DataTypes} = require('sequelize');\nconst sequelize = new Sequelize('dog', 'root', '123456', {\n    host: 'localhost',\n    dialect: 'mysql' \n});\nconst User = sequelize.define('User',{\n    firstname:{\n        type:DataTypes.STRING,\n        allowNull:false\n    },\n    lastname:{\n        type:DataTypes.STRING,\n        //allowNull 默认 true\n    }\n},{\n    //其他模型参数\n});\nconsole.log(User === sequelize.models.User)\n~~~\n\n## 模型定义-init方式\n\n~~~\nconst {\n    Sequelize,\n    DataTypes,\n    Model\n} = require('sequelize');\nconst sequelize = new Sequelize('sequelize', 'root', '123456', {\n    host: 'localhost',\n    /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */\n    dialect: 'mysql'\n});\n\nclass User extends Model {}\nUser.init({\n    firstname: {\n        type: DataTypes.STRING,\n        allowNull: false,\n    },\n    lastname: {\n        type: DataTypes.STRING,\n    }\n}, {\n    sequelize,\n    modelName: 'User'\n});\nconsole.log(User === sequelize.models.User)\n~~~\n\n> `sequelize.define`和`model.init`是等效的\n\n## 字段属性设置\n\n### 默认值\n\n~~~\nconst User = sequelize.define('User', {\n    firstname: {\n        type: DataTypes.STRING,\n        defaultValue:\"zhiqiang\"\n    },\n    ........\n}, {\n    //其他模型参数\n});\n~~~\n\n### 注释\n\n~~~\nconst User = sequelize.define('User', {\n    firstname: {\n        type: DataTypes.STRING,\n        defaultValue:\"zhiqiang\",\n        comment:\"注释\"\n    },\n}, {\n    //其他模型参数\n});\n\n~~~\n\n\n\n### Type可用的字段类型\n\n数据库结构生成器包含构建表时可以指定的各种字段类型：\n\n| 数据类型 | 方法名称                            | 描述                                     |\n| -------- | ----------------------------------- | ---------------------------------------- |\n| 字符串   | DataTypes.STRING                    | VARCHAR(255)                             |\n|          | DataTypes.STRING(100)               | VARCHAR(100)                             |\n|          | DataTypes.STRING.BINARY             | VARCHAR BINARY                           |\n|          | DataTypes.TEXT                      | TEXT                                     |\n|          | DataTypes.TEXT('tiny')              | TINYTEXT                                 |\n|          | DataTypes.CITEXT                    | CITEXT          仅 PostgreSQL 和 SQLite. |\n| 布尔     | DataTypes.BOOLEAN                   | TINYINT(1)                               |\n| 数字     | DataTypes.INTEGER                   | INTEGER                                  |\n|          | DataTypes.BIGINT                    | BIGINT                                   |\n|          | DataTypes.BIGINT(11)                | BIGINT(11)                               |\n|          | DataTypes.FLOAT                     | FLOAT                                    |\n|          | DataTypes.FLOAT(11)                 | FLOAT(11)                                |\n|          | DataTypes.FLOAT(11, 10)             | FLOAT(11,10)                             |\n|          | DataTypes.REAL                      | REAL            仅 PostgreSQL            |\n|          | DataTypes.REAL(11)                  | REAL(11)     仅 PostgreSQL.              |\n|          | DataTypes.REAL(11, 12)              | REAL(11,12)     仅 PostgreSQL.           |\n|          | DataTypes.DOUBLE                    | DOUBLE                                   |\n|          | DataTypes.DOUBLE(11)                | DOUBLE(11)                               |\n|          | DataTypes.DOUBLE(11, 10)            | DOUBLE(11,10)                            |\n|          | DataTypes.DECIMAL                   | DECIMAL                                  |\n|          | DataTypes.DECIMAL(10, 2)            | DECIMAL(10,2)                            |\n|          | DataTypes.INTEGER.UNSIGNED          | MySQL 和 MariaDB 设置为无符号或零填充    |\n|          | DataTypes.INTEGER.ZEROFILL          | MySQL 和 MariaDB设置为无符号或零填充     |\n|          | DataTypes.INTEGER.UNSIGNED.ZEROFILL | MySQL 和 MariaDB设置为无符号或零填充     |\n| 日期     | DataTypes.DATE                      | DATETIME 适用于 mysql / sqlite,          |\n|          | DataTypes.DATE(6)                   | DATETIME(6) 适用于 mysql 5.6.4+          |\n|          | DataTypes.DATEONLY                  | 不带时间的 DATE                          |\n| UUID     | DataTypes.UUID                      |                                          |\n\n对于 PostgreSQL 和 SQLite,它会是 `UUID` 数据类型，对于mysql会变成`char(36)`,UUID默认值设置\n\n~~~\n{\n  type: DataTypes.UUID,\n  defaultValue: Sequelize.UUIDV4 // 或 Sequelize.UUIDV1\n}\n~~~\n\n## 其他属性设置\n\n表名复数\n\n自定义表名\n\n### 表名复数\n\n在默认情况下，关联到数据库的表名为`Users`\n\n增加配置 去掉复数的方式\n\n方式一：全局配置，在实例化的时候增加freezeTableName配置\n\n~~~\nconst sequelize = new Sequelize('sequelize', 'root', '123456', {\n    host: 'localhost',\n    dialect: 'mysql',\n    define: {\n        freezeTableName :true\n    }\n});\n~~~\n\n方式二：单独模型配置\n\n~~~\n// define 方式定义模型\nconst User = sequelize.define('User', {\n\t.........\n}, {\n    //其他模型参数\n    //强制表名和模型名称保持一致\n    freezeTableNAme: true\n});\n~~~\n\n### 自定义表名\n\n~~~\nconst User = sequelize.define('User', {\n\t.....\n}, {\n    //其他模型参数\n    // 自定义表名\n    tableName:\"zq_user\"\n});\n~~~\n\n### 时间戳createdAt/updatedAt\n\n~~~\n// define 方式定义模型\nconst User = sequelize.define('User', {\n\t.....\n}, {\n    // 去掉createdAt/updatedAt\n    // timestamps:false\n    // 去掉 createdAt\n    // createdAt:false,\n    // //去掉 updatedAt\n    // updatedAt:false,\n});\n~~~\n\n## 模型同步表\n\n~~~\n// //用户模型同步到数据库中\n// User.sync({force:true})\n\n//生成的sql\nCREATE TABLE IF NOT EXISTS `zq_user` (`id` INTEGER NOT NULL auto_increment , `firstname` VARCHAR(255) NOT NULL, `lastname` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;\n\n\n// //一次性同步所有的\n// sequelize.sync({force:true})\n~~~\n\n## 删除表\n\n~~~\n// 删除指定用户表\n// User.drop();\n// 删除所有的表\n// sequelize.drop();\n~~~\n\n","tags":["node-sequelize","orm","nodejs"],"categories":["nodejs"]},{"title":"think-swoole基本使用","url":"/2020/06/04/php/think-swoole/","content":"\n\n## 官网文档\n> thinkphp6文档\n> https://www.kancloud.cn/manual/thinkphp6_0/1037479\n>\n> swoole文档\n> https://wiki.swoole.com/#/\n>\n> think-swoole文档\n> https://www.kancloud.cn/manual/thinkphp6_0/1359700\n\n## 安装\n\n~~~\ncomposer require topthink/think-swoole\n~~~\n\n## 命令行\n\n```\nphp think swoole [start|stop|reload|restart]\n```\n\n## 服务启动\n\n当你在命令行`php think swoole`下执行完成之后就会启动一个HTTP Server，可以直接访问当前的应用\n\n~~~\n'server'     => [\n    'host'      => env('SWOOLE_HOST', '0.0.0.0'), // 监听地址\n    'port'      => env('SWOOLE_PORT', 9501), // 监听端口\n    'mode'      => SWOOLE_PROCESS, // 运行模式 默认为SWOOLE_PROCESS\n    'sock_type' => SWOOLE_SOCK_TCP, // sock type 默认为SWOOLE_SOCK_TCP\n    'options'   => [\n    \t// 服务启动后，进程ID存放文件\n        'pid_file'              => runtime_path() . 'swoole.pid',\n        // swoole 的日志文件\n        'log_file'              => runtime_path() . 'swoole.log',\n        // 守护进程模式设置 true 后台运行\n        'daemonize'             => false,\n        // 设置启动的reactor线程数\n        'reactor_num'           => swoole_cpu_num(),\n        // 设置启动的worker进程数\n        'worker_num'            => swoole_cpu_num(),\n        //配置Task进程的数量\n        'task_worker_num'       => swoole_cpu_num(),\n        //开启静态文件请求处理，需配合document_root\n        'enable_static_handler' => true,\n        //静态文件根目录\n        'document_root'         => root_path('public'),\n        // 设置最大数据包尺寸，单位字节\n        'package_max_length'    => 20 * 1024 * 1024,\n        //配置发送输出缓冲区内存尺寸\n        'buffer_output_size'    => 10 * 1024 * 1024,\n        //设置客户端连接最大允许占用的内存数量\n        'socket_buffer_size'    => 128 * 1024 * 1024,\n    ],\n],\n~~~\n\n## 热更新\n\nswoole服务器运行过程中php文件是常驻内存运行，这样就可以避免重复的读取磁盘，重复的解释编译php，以便达到最高的性能，所以修改代码需要重启服务\n\nthink-swoole扩展提供热更新功能，在检测相关文件有更新会自动重启，不在需要手动完成重启，方便开发调试\n\n生产环境下不建议开始文件监控，性能损耗，正常情况下你所修改的文件需要确认无误才能进行更新部署\n\n`.env`里面设置`APP_DEBUG = true`会默认开启热更新\n\n~~~\n'hot_update' => [\n    'enable'  => env('APP_DEBUG', false),\n    'name'    => ['*.php'],\n    'include' => [app_path()],\n    'exclude' => [],\n],\n~~~\n\n参数说明\n\n| 参数    | 说明                     |\n| ------- | ------------------------ |\n| enable  | 是否开启热更新           |\n| name    | 监听哪些类型的文件变动   |\n| include | 监听哪些目录下的文件变动 |\n| exclude | 排除目录                 |\n\n## websocket\n\n先来一个官方的例子\n\n~~~\n$server = new Swoole\\WebSocket\\Server(\"0.0.0.0\", 9501);\n$server->on('open', function (Swoole\\WebSocket\\Server $server, $request) {\n    echo \"server: handshake success with fd{$request->fd}\\n\";\n});\n$server->on('message', function (Swoole\\WebSocket\\Server $server, $frame) {\n    echo \"receive from {$frame->fd}:{$frame->data}\\n\";\n    $server->push($frame->fd, \"this is server\");\n});\n$server->on('close', function ($ser, $fd) {\n    echo \"client {$fd} closed\\n\";\n});\n$server->start();\n~~~\n\n开启think-swoole的websocket功能 `\\config\\swoole.php`\n\n~~~\n'websocket'  => [\n\t'enable'        => true,\n],\n~~~\n\n创建三个事件\n\n~~~\nphp think make:listener SwWsConnect\nphp think make:listener SwWsClose\nphp think make:listener SwWsMessage\n~~~\n\n然后将这三个事件写到到事件监听中，分别有以下2中文件可以修改方式，注意二选一\n\nthinkphp6自带的事件绑定`app\\event.php`\n\n~~~\n    'listen'    => [\n\t\t........\n        // 监听链接\n        'swoole.websocket.Connect' => [\n            \\app\\listener\\SwWsConnect::class\n        ],\n        //关闭连接\n        'swoole.websocket.Close' => [\n            \\app\\listener\\SwWsClose::class\n        ],\n        //发送消息场景\n        'swoole.websocket.Message' => [\n            \\app\\listener\\SwWsMessage::class\n        ]\n    ],\n~~~\n\nthink-swoole事件绑定`config\\swoole.php`\n\n~~~\n'listen'        => [\n    'connect'=>\\app\\listener\\SwWsConnect::class,\n    'close'=>\\app\\listener\\SwWsClose::class,\n    'message'=> \\app\\listener\\SwWsMessage::class\n],\n~~~\n\n> 怎么选择是保存在`config\\swoole.php`还是`app\\event.php`配置中呢？\n>\n> 首先我们 我们确定一下我们这个项目中存在有几个实时通讯，\n>\n> 如果只是存在一个实时通讯 个人建议 保存在`config\\swoole.php`\n>\n> 如果是存在多个实时通讯，就保存在`app\\event.php`\n>\n> key值 必须是`swoole.websocket.事件名称` 例如 `swoole.websocket.Message`\n\n开始写事件中中方法\n\n连接事件`app\\listener\\SwWsConnect.php`\n\n~~~\npublic function handle($event, \\think\\swoole\\websocket $ws)\n{\n    // 获取当前发送者的fd\n    $fd = $ws->getSender();\n    echo \"server: handshake success with fd{$fd}\\n\";\n}\n~~~\n\n关闭事件`app\\listener\\SwWsClose.php`\n\n~~~\n\npublic function handle($event, \\think\\swoole\\websocket $ws)\n{\n    $fd = $ws->getSender();\n    echo \"client {$fd} closed\\n\";\n}\n~~~\n\nmessage事件`app\\listener\\SwWsMessage.php`\n\n~~~\npublic function handle($event, \\think\\swoole\\websocket $ws)\n{\n\t$fd = $ws->getSender();\n\t$data = json_encode($event);\n\techo \"receive from {$fd}:{$data}\\n\";\n    $ws->emit(\"this is server\", $fd);\n}\n~~~\n\n启动`php think swoole`进行测试\n\n\n\nthink-swoole中的websocket方法总结\n\n~~~\n//给自己发消息\n$ws->emit(\"this is server\", $ws->getSender());\n//给指定一个fd发消息\n$ws->to($to)->emit(\"messagecallback\",$data);\n//给指定多个人发消息\n$ws->to([1,2,3])->emit(\"messagecallback\",$data);\n//发送给所有的(不包含自己)\n$ws->broadcast()->emit(\"messagecallback\",$data);\n//模拟formfd 给tofd 发送消息\n$ws->setSender($formfd)->to($tofd)->emit(\"messagecallback\",$data);\n~~~\n\n> 注意：在多个实时通讯场景下使用 `emit`\n>\n> 第一个参数传入  传入 事件名称callback 例如 `messagecallback`\n\n\n\n如果你发现你think-swoole中有些没有swoole中的方法可以这么干\n\n~~~\n$sw = app('swoole.server');\n$sw = app(\"think\\swoole\\Manager\")->getServer();\n//以上二选一\n\n$es = $sw->isEstablished($fd); //检查连接是否为有效的WebSocket客户端连接\nvar_dump($es);\n~~~\n\n\n\n## 聊天室room实现\n\n前端文件参考 `html\\room.html` 或 `html\\room-socket-io.html`\n\n~~~\nphp think make:listener SwRoomJoin\nphp think make:listener SwRoomLeave\nphp think make:listener SwRoomMessage\n~~~\n\n事件绑定\n\n~~~\n// 加入房间\n'swoole.websocket.RoomJoin' => [\n\t\\app\\listener\\SwRoomJoin::class\n],\n// 离开房间\n'swoole.websocket.Roomleave' => [\n\t\\app\\listener\\SwRoomLeave::class\n],\n// 在房间发消息\n'swoole.websocket.RoomMessage' => [\n\t\\app\\listener\\SwRoomMessage::class\n]\n~~~\n\n加入房间逻辑\n\n~~~\npublic function handle($event, \\think\\swoole\\websocket $ws, \\think\\swoole\\websocket\\room $room)\n{\n    $fd = $ws->getSender();\n    //客户端假如定的room\n    $roomid = $event['room'];\n    //获取指定房间下有哪些客户端\n    $roomfds = $room->getClients($roomid);\n    // 判断这个房间有没有自己 如果有自己就不需要再次发送通知\n    if (in_array($fd, $roomfds)) {\n        $ws->to($roomfds)->emit(\"roomjoincallback\", \"房间{$roomid}已加入\");\n        return;\n    }\n    //加入房间\n    $ws->join($roomid);\n    $ws->to($roomfds)->emit(\"roomjoincallback\", \"{$fd}加入房间{$roomid}成功\");\n}\n~~~\n\n离开房间逻辑\n\n~~~\npublic function handle($event, \\think\\swoole\\websocket $ws, \\think\\swoole\\websocket\\Room $room)\n{\n    $roomid = $event['room'];\n    $fd = $ws->getSender();\n    $roomfds = $room->getClients($roomid);\n    if (!in_array($fd, $roomfds)) {\n        $ws->emit(\"roomleavecallback\", \"{$fd}不在{$roomid}房间内，怎么离开~\");\n        return;\n    }\n    //离开房间\n    $ws->leave($roomid);\n    //获取当前客户端加入了哪些客户端\n    $rooms = $room->getRooms($fd);\n    $ws->to($roomfds)->emit(\"roomleavecallback\", \"{$fd}已离开了~~\");\n}\n~~~\n\n在房间发布聊天逻辑\n\n~~~\n    public function handle($event, \\think\\swoole\\websocket $ws, \\think\\swoole\\websocket\\room $room)\n    {\n        //\n        $roomid = $event['room'];\n        $text = $event['text'];\n        $fd = $ws->getSender();\n        $roomfds = $room->getClients($roomid);\n        if (!in_array($fd, $roomfds)) {\n            $ws->emit(\"roommessagecallback\", \"{$fd}不在{$roomid}房间内，无法进入发布聊天~\");\n            return;\n        }\n        $ws->to($roomfds)->emit(\"roommessagecallback\",  $text);\n    }\n~~~\n\n\n\n## 事件订阅\n\n~~~\nphp think make:listener SwSubscribe\n~~~\napp\\listener\\SwSubscribe.php\n~~~\n<?php\ndeclare (strict_types = 1);\n\nnamespace app\\listener;\n\nclass SwSubscribe\n{\n    protected $ws = null;\n\n    // public function __construct()\n    // {\n    //     $this->ws = app('think\\swoole\\Websocket');\n    // }\n\n    public function __construct(\\think\\Container $c)\n    {\n        $this->ws = $c->make(\\think\\swoole\\Websocket::class);\n    }\n    \n    public function onConnect()\n    {\n        $fd = $this->ws->getSender();\n        echo \"server: handshake success with fd{$fd}\\n\";\n    }\n    public function onClose()\n    {\n        $fd = $this->ws->getSender();\n        echo \"client {$fd} closed\\n\";\n    }\n    public function onMessage($event)\n    {\n        $fd = $this->ws->getSender();\n        var_dump($event);\n        echo \"server: handshake success with fd{$fd}\\n\";\n        $this->ws->emit(\"this is server\", $fd);\n    }\n}\n\n~~~\n\n> 有点类似 将原生的swoole代码改成面向对象代码，生效方法 `config\\swoole.php`中在`subscribe` 加入`\\app\\listener\\SwSubscribe::class`\n>\n> ~~~\n> 'subscribe'     => [\n> \t\\app\\listener\\SwSubscribe::class\n> ],\n> ~~~\n>\n> 在`app\\event.php`文件中的 `swoole.websocket.Connect` 相当于 `app\\listener\\SwSubscribe.php`文件中的`onConnect`函数。如果同时存在的存在的话，就会向客户端发送2次以上的消息\n\n\n\n\n\n## Task任务投递\n\nhttps://wiki.swoole.com/#/start/start_task\n\n生成事件\n\n~~~\nphp think make:listener SwSendEmailTask\n~~~\n\n编写发送邮件方法`app\\listener\\SwSendEmailTask.php`\n\n~~~\npublic function handle($event)\n{\n    var_dump($event);\n    //\n    echo \"开发发送邮件\".time();\n    sleep(3);\n    echo \"结束发送邮件\".time();\n}  \n~~~\n\n注册事件`app\\event.php`\n\n~~~\n'swoole.task'=>[\n\t\\app\\listener\\SwSendEmailTask::class\n],\n~~~\n\n在控制器中投递任务\n\n~~~\npublic function doRegister()\n{\n    $server = app('swoole.server');\n    $server->task(\\app\\listener\\SwSendEmailTask::class);\n    return \"注册成功\";\n}\n\npublic function doRegister(\\think\\swoole\\Manager $manager)\n{\n    $server = $manager->getServer();\n    $server->task(\\app\\listener\\SwSendEmailTask::class);\n    return \"注册成功\";\n}\npublic function doRegister(\\Swoole\\Server $server)\n{\n    $server->task(\\app\\listener\\SwSendEmailTask::class);\n    return \"注册成功\";\n}\n~~~\n\n> 三种获取`\\Swoole\\Server`,任意选其一\n\n在swoole中还有一个事件叫`finish`，它的作用就是把异步任务的结果返回，在think-swool是这么处理的\n\n定义一个发送邮件异步任务处理结果的事件\n\n~~~\nphp think make:listener SwSendEmailFinish\n~~~\n\n注册事件`app\\event.php`\n\n~~~\n'swoole.finish'=>[\n\t\\app\\listener\\SwSendEmailFinish::class\n],\n~~~\n\n在task任务中调用\n\n~~~\npublic function handle($event)\n{\n    var_dump($event);\n    //\n    echo \"开发发送邮件\".time();\n    sleep(3);\n    echo \"结束发送邮件\".time();\n    $event->finish(\\app\\listener\\SwSendEmailFinish::class);\n} \n~~~\n\n## 高性能共享内存 Table\n\nhttps://wiki.swoole.com/#/memory/table\n\n先定结构在进行操作数据（原生swoole操作）\n\n~~~\n$table = new Swoole\\Table(1024);\n//创建表\n$table->column(\"id\", Swoole\\Table::TYPE_INT);\n$table->column(\"name\", Swoole\\Table::TYPE_STRING);\n$table->column(\"money\", Swoole\\Table::TYPE_FLOAT);\n$table->create();\n\n//添加数据\n$table->set(\"zq\", [\n    'id' => 1,\n    'name' => \"zhiqiang\",\n    'money' => 100,\n]);\n//获取一行数据\n$table->get(\"zq\");\n// 修改数据\n// 字段递增\n$table->incr(\"zq\",\"money\",2);\n//递减\n$table->decr(\"zq\",\"money\",2);\n// 返回 table 中存在的条目数。\n$table->count();\n//遍历table中的数据\nforeach($table as $item){\n    var_dump($item);\n}\n~~~\n\nthink-swoole中的操作\n\n先对table表结构进行初始化`config\\swoole.php`\n\n~~~\n    'tables'     => [\n        'user'=>[\n            'size'=>1024,\n            'columns'=>[\n                [\n                    'name'=>'id',\n                    'type'=>\\Swoole\\Table::TYPE_INT\n                ],\n                [\n                    'name'=>'name',\n                    'type'=>\\Swoole\\Table::TYPE_STRING,\n                    'size'=>32\n                ],\n                [\n                    'name'=>'money',\n                    'type'=>\\Swoole\\Table::TYPE_FLOAT\n                ],\n\n            ],\n        ],\n    ],\n~~~\n\n操作数据\n\n~~~\n$table =  app('swoole.table.user');\n$table->set(\"zq\", [\n    'id' => 1,\n    'name' => \"zhiqiang\",\n    'money' => 100\n]);\n//获取一行数据\n$table->get(\"zq\");\n// 修改数据\n// 字段递增\n$table->incr(\"zq\", \"money\", 2);\n//递减\n$table->decr(\"zq\", \"money\", 2);\n// 返回 table 中存在的条目数。\n$table->count();\n//遍历table中的数据\nforeach ($table as $item) {\nvar_dump($item);\n}\n// 检查 table 中是否存在某一个 key。\n$table->exist('zq');\n//获取实际占用内存尺寸,单位字节\n$table->momorySize();\n~~~\n\n## RPC\n\nRPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。\n\n详细介绍：https://developer.51cto.com/art/201906/597963.htm\n\n- 解决分布式系统中，服务之间的调用问题。\n- 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。\n- 节点角色说明：\n- Server: 暴露服务的服务提供方\n- Client: 调用远程服务的服务消费方\n- Registry: 服务注册与发现的注册中心\n\nthink-swoole实现RPC功能\n\n### 服务器端\n\n#### 接口定义`app/rpc/interfaces/UserInterface.php`\n\n~~~\n<?php\nnamespace app\\rpc\\interfaces;\ninterface UserInterface\n{\n    public function create();\n    public function find(int $id);\n}\n~~~\n\n#### 实现接口`app/rpc/services/UserService.php`\n\n~~~\n<?php\nnamespace app\\rpc\\services;\nuse app\\rpc\\interfaces\\UserInterface;\nclass UserService implements UserInterface\n{\n    public function create()\n    {\n        // TODO: Implement create() method.\n        return \"service create success\";\n    }\n    public function find(int $id)\n    {\n        // TODO: Implement find() method.\n        return $id. \"查询数据遍历\";\n    }\n}\n~~~\n\n#### 注册rpc服务`config/swoole.php`\n\n~~~\n    'rpc'        => [\n        'server' => [\n        \t//开启rpc服务\n            'enable'   => true,\n            //rpc端口\n            'port'     => 9000,\n            'services' => [\n            \t//注册服务\n                \\app\\rpc\\services\\UserService::class\n            ],\n        ],\n        // 如果填写也是可以调用其他服务端\n        'client' => [\n        ],\n    ],\n~~~\n\n启动服务端\n\n~~~\nphp think swoole start /  php think swoole:rpc\n~~~\n\n### 客户端\n\n~~~\n    'rpc'        => [\n        'server' => [\n        ],\n        'client' => [\n            'tp6'=>[\n            \t//服务端的ip地址\n                'host'=>'127.0.0.1',\n                //服务端对应的端口\n                'port'=>'9000'\n            ]\n            // 更多服务端\n        ],\n    ],\n~~~\n\n运行`php think rpc:interface`生成RPC接口文件`app\\rpc.php`\n\n~~~\n<?php\n/**\n * This file is auto-generated.\n */\ndeclare(strict_types=1);\nnamespace rpc\\contract\\tp6;\ninterface UserInterface\n{\n\tpublic function create();\n\tpublic function find(int $id);\n}\nreturn ['tp6' => ['rpc\\contract\\tp6\\UserInterface']];\n~~~\n\n在控制器调用\n\n~~~\n    public function index(\\rpc\\contract\\tp6\\UserInterface $user)\n    {\n        //\n        $user->find(1);\n//        $user->create();\n    }\n~~~\n\n## 定时任务\n\n在think-swoole 2.0版本的时候还是支持自定义定时任务配置,详细参考https://github.com/top-think/think-swoole/tree/2.0  \n\n在3.0就不支持了，在这里介绍一个通用的命令行启动定时任务\n\n~~~\nphp think make:command SwooleTimer\n~~~\n\n加载命令行`config/console.php`\n\n~~~\n'commands' => [\n\t'swooletimer'=>app\\command\\SwooleTimer::class\n\t...........\n],\n~~~\n\n书写命令脚本`app/command/SwooleTimer.php`\n\n~~~\n<?php\ndeclare (strict_types = 1);\n\nnamespace app\\command;\n\nuse think\\console\\Command;\nuse think\\console\\input\\Argument;\n\n\nclass SwooleTimer extends Command\n{\n    protected function configure()\n    {\n        // 指令配置\n        $this->setName('app\\command\\swooletimer')\n            ->addArgument('action', Argument::OPTIONAL, \"start | stop\", 'start')\n            ->setDescription('Swoole Timer for ThinkPHP');\n    }\n\n\n    public function handle()\n    {\n        $action = $this->input->getArgument('action');\n        if (in_array($action, ['start','stopall'])) {\n            $this->app->invokeMethod([$this, $action], [], true);\n        } else {\n            $this->output->writeln(\"<error>Invalid argument action:{$action}, Expected start</error>\");\n        }\n    }\n\n    /**\n     * 启动定时任务 主要任务计划在这里书写\n     */\n    protected function start()\n    {\n        // https://wiki.swoole.com/#/timer\n        $timer_id=swoole_timer_tick(2000,function (){\n            echo \"2s循环执行需要做的事情\".time().\"\\n\";\n        });\n        $this->output->writeln(\"Swoole Timer_id:{$timer_id} \");\n    }\n\n    /**\n     * 清除所有的定时任务\n     */\n    protected  function stop(){\n        swoole_timer_clear_all();\n        $this->output->writeln(\"Swoole Timer  clear all ok\");\n    }\n}\n~~~","tags":["swoole","think-swoole"],"categories":["php"]},{"title":"mysql索引类型","url":"/2020/06/03/data/mysql-index/","content":"\n\n# 1 普通索引\n\n最基本的缩影，他没有任何限制，只是用于加速查询\n\n~~~\ncreate table table_1_1(name varchar(32),INDEX index_table_1_1_name(name));\n\n\ncreate table table_1_2 (name varchar(32));\ncreate INDEX index_table_1_2_name ON table_1_2(name);\n~~~\n\n\n# 2唯一索引\n\n索引列的值必须是唯一的，但是允许为空值，如果组合索引，则列支的组合必须是唯一的\n\n~~~\ncreate table table_2_1(name varchar(32),UNIQUE index_unique_table_2_1_name(name));\n\n\ncreate table table_2_2 (name varchar(32));\ncreate unique index index_unique_table_2_2_name ON table_2_2(name);\n~~~\n\n\n# 3.主键索引\n\n是一种特殊的唯一索引，一个表只能有一个主键，不允许为空，一般在建表的时候就需要同时创建主键索引\n\n~~~\ncreate table table_3_1 (id int(11) not null auto_increment,name varchar(32),PRIMARY KEY(id));\n~~~\n\n# 4组合索引\n\n多个字段上创建索引，只有在查询条件中使用创建索引的第一个字段，索引才会被使用，使用组合索引遵循最左前缀集合\n\n~~~\ncreate table table_4_1(id int(11),name varchar(32),index index_id_name(id,name) );\n\n\n\ncreate table table_4_2 (id int(11),name varchar(32));\ncreate index index_id_name on table_4_2(id,name);\n~~~\n\n# 5 全文索引\n\n主要是查找文本中的关键字，目前只支持char、varchar、text列可以创建索引\n\n~~~\ncreate table article_1 (content text null , fulltext(content));\n\n\ncreate table article_2 (content text null);\ncreate fulltext index index_artice_content on article_2(content);\n~~~\n\n","tags":["mysql","索引"],"categories":["数据库"]},{"title":"Hello World","url":"/2020/06/01/hello-world/","content":"\nHexo Hello World\n\n<!-- more -->\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]